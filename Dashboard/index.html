<!DOCTYPE html>
<html lang="en">
<head>
    <base href="./">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <meta name="description" content="CoreUI - Open Source Bootstrap Admin Template">
    <meta name="keyword" content="Bootstrap,Admin,Template,Open,Source,jQuery,CSS,HTML,RWD,Dashboard">
    <title>CoreUI Free Bootstrap Admin Template</title>
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="theme-color" content="#ffffff">
    <style>
        @charset "UTF-8";
        /*!
 * CoreUI - HTML, CSS, and JavaScript UI Components Library
 * @version v3.2.0
 * @link https://coreui.io/
 * Copyright (c) 2020 creativeLabs ≈Åukasz Holeczek
 * License MIT  (https://coreui.io/license/)
 */
        :root {
            --breakpoint-xs: 0;
            --breakpoint-sm: 576px;
            --breakpoint-md: 768px;
            --breakpoint-lg: 992px;
            --breakpoint-xl: 1200px;
            --font-family-sans-serif: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            --font-family-monospace: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        :root,.c-app {
            --primary: #321fdb;
            --secondary: #ced2d8;
            --success: #2eb85c;
            --info: #39f;
            --warning: #f9b115;
            --danger: #e55353;
            --light: #ebedef;
            --dark: #636f83;
        }

        .c-app {
            overflow-x: hidden;
            color: #3c4b64;
            background-color: #ebedef;
            --color: #3c4b64;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: row;
            flex-direction: row;
            min-height: 100vh;
        }

        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        html {
            font-family: sans-serif;
            line-height: 1.15;
            -webkit-text-size-adjust: 100%;
            -webkit-tap-highlight-color: rgba(0, 0, 21, 0);
        }

        article, aside, figcaption, figure, footer, header, hgroup, main, nav, section {
            display: block;
        }

        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            font-size: 0.875rem;
            font-weight: 400;
            line-height: 1.5;
            text-align: left;
            color: #3c4b64;
            background-color: #ebedef;
            -moz-osx-font-smoothing: grayscale;
            -webkit-font-smoothing: antialiased;
        }

        [tabindex="-1"]:focus:not(:focus-visible) {
            outline: 0 !important;
        }

        hr {
            box-sizing: content-box;
            height: 0;
            overflow: visible;
            margin-top: 1rem;
            margin-bottom: 1rem;
            border: 0;
            border-top: 1px solid rgba(0, 0, 21, 0.2);
        }

        h1, h2, h3, h4, h5, h6 {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        p {
            margin-top: 0;
            margin-bottom: 1rem;
        }

        abbr[title],
        abbr[data-original-title] {
            text-decoration: underline;
            -webkit-text-decoration: underline dotted;
            text-decoration: underline dotted;
            cursor: help;
            border-bottom: 0;
            -webkit-text-decoration-skip-ink: none;
            text-decoration-skip-ink: none;
        }

        address {
            font-style: normal;
            line-height: inherit;
        }

        address,ol,
        ul,
        dl {
            margin-bottom: 1rem;
        }

        ol,
        ul,
        dl {
            margin-top: 0;
        }

        ol ol,
        ul ul,
        ol ul,
        ul ol {
            margin-bottom: 0;
        }

        dt {
            font-weight: 700;
        }

        dd {
            margin-bottom: .5rem;
        }

        html:not([dir="rtl"]) dd {
            margin-left: 0;
        }

        *[dir="rtl"] dd {
            margin-right: 0;
        }

        blockquote {
            margin: 0 0 1rem;
        }

        b,
        strong {
            font-weight: bolder;
        }

        small {
            font-size: 80%;
        }

        sub,
        sup {
            position: relative;
            font-size: 75%;
            line-height: 0;
            vertical-align: baseline;
        }

        sub {
            bottom: -.25em;
        }

        sup {
            top: -.5em;
        }

        a {
            text-decoration: none;
            background-color: transparent;
            color: #321fdb;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            a:hover {
                text-decoration: underline;
                color: #321fdb;
            }
        }

        a:not([href]) {
            color: inherit;
            text-decoration: none;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            a:not([href]):hover {
                color: inherit;
                text-decoration: none;
            }
        }

        pre,
        code,
        kbd,
        samp {
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 1em;
        }

        pre {
            margin-top: 0;
            margin-bottom: 1rem;
            overflow: auto;
            -ms-overflow-style: scrollbar;
            display: block;
            font-size: 87.5%;
            color: #4f5d73;
        }

        figure {
            margin: 0 0 1rem;
        }

        img {
            border-style: none;
        }

        img,svg {
            vertical-align: middle;
        }

        svg {
            overflow: hidden;
        }

        table {
            border-collapse: collapse;
        }

        caption {
            padding-top: 0.75rem;
            padding-bottom: 0.75rem;
            color: #768192;
            text-align: left;
            caption-side: bottom;
        }

        th {
            text-align: inherit;
        }

        label {
            display: inline-block;
            margin-bottom: 0.5rem;
        }

        button {
            border-radius: 0;
        }

        button:focus {
            outline: 1px dotted;
            outline: 5px auto -webkit-focus-ring-color;
        }

        input,
        button,
        select,
        optgroup,
        textarea {
            margin: 0;
            font-family: inherit;
            font-size: inherit;
            line-height: inherit;
        }

        button,
        input {
            overflow: visible;
        }

        button,
        select {
            text-transform: none;
        }

        [role="button"] {
            cursor: pointer;
        }

        select {
            word-wrap: normal;
        }

        button,
        [type="button"],
        [type="reset"],
        [type="submit"] {
            -webkit-appearance: button;
        }

        button:not(:disabled),
        [type="button"]:not(:disabled),
        [type="reset"]:not(:disabled),
        [type="submit"]:not(:disabled) {
            cursor: pointer;
        }

        button::-moz-focus-inner,
        [type="button"]::-moz-focus-inner,
        [type="reset"]::-moz-focus-inner,
        [type="submit"]::-moz-focus-inner {
            padding: 0;
            border-style: none;
        }

        input[type="radio"],
        input[type="checkbox"] {
            box-sizing: border-box;
            padding: 0;
        }

        textarea {
            overflow: auto;
            resize: vertical;
        }

        fieldset {
            min-width: 0;
            padding: 0;
            margin: 0;
            border: 0;
        }

        legend {
            display: block;
            width: 100%;
            max-width: 100%;
            padding: 0;
            margin-bottom: .5rem;
            font-size: 1.5rem;
            line-height: inherit;
            color: inherit;
            white-space: normal;
        }

        progress {
            vertical-align: baseline;
        }

        [type="number"]::-webkit-inner-spin-button,
        [type="number"]::-webkit-outer-spin-button {
            height: auto;
        }

        [type="search"] {
            outline-offset: -2px;
            -webkit-appearance: none;
        }

        [type="search"]::-webkit-search-decoration {
            -webkit-appearance: none;
        }

        ::-webkit-file-upload-button {
            font: inherit;
            -webkit-appearance: button;
        }

        output {
            display: inline-block;
        }

        summary {
            display: list-item;
            cursor: pointer;
        }

        template {
            display: none;
        }

        [hidden] {
            display: none !important;
        }

        .ps {
            overflow: hidden !important;
            -ms-touch-action: auto;
            touch-action: auto;
            -ms-overflow-style: none;
            overflow-anchor: none;
        }

        .ps__rail-x {
            bottom: 0;
            height: 15px;
        }

        .ps__rail-x,.ps__rail-y {
            position: absolute;
            display: none;
            opacity: 0;
            transition: background-color .2s linear, opacity .2s linear;
        }

        .ps__rail-y {
            width: 15px;
        }

        html:not([dir="rtl"]) .ps__rail-y {
            right: 0;
        }

        *[dir="rtl"] .ps__rail-y {
            left: 0;
        }

        .ps--active-x > .ps__rail-x,
        .ps--active-y > .ps__rail-y {
            display: block;
            background-color: transparent;
        }

        .ps:hover > .ps__rail-x,
        .ps:hover > .ps__rail-y,
        .ps--focus > .ps__rail-x,
        .ps--focus > .ps__rail-y,
        .ps--scrolling-x > .ps__rail-x,
        .ps--scrolling-y > .ps__rail-y {
            opacity: .6;
        }

        .ps__rail-x:hover,
        .ps__rail-y:hover,
        .ps__rail-x:focus,
        .ps__rail-y:focus {
            background-color: #eee;
            opacity: .9;
        }

        /*
 * Scrollbar thumb styles
 */
        .ps__thumb-x {
            bottom: 2px;
            height: 6px;
            transition: background-color .2s linear, height .2s ease-in-out;
        }

        .ps__thumb-x,.ps__thumb-y {
            position: absolute;
            background-color: #aaa;
            border-radius: 6px;
        }

        .ps__thumb-y {
            width: 6px;
            transition: background-color .2s linear, width .2s ease-in-out;
        }

        html:not([dir="rtl"]) .ps__thumb-y {
            right: 2px;
        }

        *[dir="rtl"] .ps__thumb-y {
            left: 2px;
        }

        .ps__rail-x:hover > .ps__thumb-x,
        .ps__rail-x:focus > .ps__thumb-x {
            height: 11px;
            background-color: #999;
        }

        .ps__rail-y:hover > .ps__thumb-y,
        .ps__rail-y:focus > .ps__thumb-y {
            width: 11px;
            background-color: #999;
        }

        @supports (-ms-overflow-style: none) {
            .ps {
                overflow: auto !important;
            }
        }

        @media screen and (-ms-high-contrast: active), (-ms-high-contrast: none) {
            .ps {
                overflow: auto !important;
            }
        }

        .alert {
            position: relative;
            padding: 0.75rem 1.25rem;
            margin-bottom: 1rem;
            border: 1px solid transparent;
            border-radius: 0.25rem;
        }

        .alert-heading {
            color: inherit;
        }

        .alert-link {
            font-weight: 700;
        }

        html:not([dir="rtl"]) .alert-dismissible {
            padding-right: 3.8125rem;
        }

        *[dir="rtl"] .alert-dismissible {
            padding-left: 3.8125rem;
        }

        .alert-dismissible .close {
            position: absolute;
            top: 0;
            padding: 0.75rem 1.25rem;
            color: inherit;
        }

        html:not([dir="rtl"]) .alert-dismissible .close {
            right: 0;
        }

        *[dir="rtl"] .alert-dismissible .close {
            left: 0;
        }

        .alert-primary {
            color: #1a107c;
            background-color: #d6d2f8;
            border-color: #c6c0f5;
        }

        .alert-primary hr {
            border-top-color: #b2aaf2;
        }

        .alert-primary .alert-link {
            color: #110a4f;
        }

        .alert-secondary {
            color: #6b6d7a;
            background-color: #f5f6f7;
            border-color: #f1f2f4;
        }

        .alert-secondary hr {
            border-top-color: #e3e5e9;
        }

        .alert-secondary .alert-link {
            color: #53555f;
        }

        .alert-success {
            color: #18603a;
            background-color: #d5f1de;
            border-color: #c4ebd1;
        }

        .alert-success hr {
            border-top-color: #b1e5c2;
        }

        .alert-success .alert-link {
            color: #0e3721;
        }

        .alert-info {
            color: #1b508f;
            background-color: #d6ebff;
            border-color: #c6e2ff;
        }

        .alert-info hr {
            border-top-color: #add5ff;
        }

        .alert-info .alert-link {
            color: #133864;
        }

        .alert-warning {
            color: #815c15;
            background-color: #feefd0;
            border-color: #fde9bd;
        }

        .alert-warning hr {
            border-top-color: #fce1a4;
        }

        .alert-warning .alert-link {
            color: #553d0e;
        }

        .alert-danger {
            color: #772b35;
            background-color: #fadddd;
            border-color: #f8cfcf;
        }

        .alert-danger hr {
            border-top-color: #f5b9b9;
        }

        .alert-danger .alert-link {
            color: #521d24;
        }

        .alert-light {
            color: #7a7b86;
            background-color: #fbfbfc;
            border-color: #f9fafb;
        }

        .alert-light hr {
            border-top-color: #eaedf1;
        }

        .alert-light .alert-link {
            color: #62626b;
        }

        .alert-dark {
            color: #333a4e;
            background-color: #e0e2e6;
            border-color: #d3d7dc;
        }

        .alert-dark hr {
            border-top-color: #c5cad1;
        }

        .alert-dark .alert-link {
            color: #1f232f;
        }

        .c-avatar {
            position: relative;
            display: -ms-inline-flexbox;
            display: inline-flex;
            -ms-flex-align: center;
            align-items: center;
            -ms-flex-pack: center;
            justify-content: center;
            border-radius: 50em;
            width: 36px;
            height: 36px;
            font-size: 14.4px;
        }

        .c-avatar .c-avatar-status {
            width: 10px;
            height: 10px;
        }

        .c-avatar-img {
            width: 100%;
            height: auto;
            border-radius: 50em;
        }

        .c-avatar-status {
            position: absolute;
            bottom: 0;
            display: block;
            border: 1px solid #fff;
            border-radius: 50em;
        }

        html:not([dir="rtl"]) .c-avatar-status {
            right: 0;
        }

        *[dir="rtl"] .c-avatar-status {
            left: 0;
        }

        .c-avatar-sm {
            width: 24px;
            height: 24px;
            font-size: 9.6px;
        }

        .c-avatar-sm .c-avatar-status {
            width: 8px;
            height: 8px;
        }

        .c-avatar-lg {
            width: 48px;
            height: 48px;
            font-size: 19.2px;
        }

        .c-avatar-lg .c-avatar-status {
            width: 12px;
            height: 12px;
        }

        .c-avatar-xl {
            width: 64px;
            height: 64px;
            font-size: 25.6px;
        }

        .c-avatar-xl .c-avatar-status {
            width: 14px;
            height: 14px;
        }

        .c-avatars-stack {
            display: -ms-flexbox;
            display: flex;
        }

        .c-avatars-stack .c-avatar {
            margin-right: -18px;
            transition: margin-right 0.3s;
        }

        .c-avatars-stack .c-avatar:hover {
            margin-right: 0;
        }

        .c-avatars-stack .c-avatar-sm {
            margin-right: -12px;
        }

        .c-avatars-stack .c-avatar-lg {
            margin-right: -24px;
        }

        .c-avatars-stack .c-avatar-xl {
            margin-right: -32px;
        }

        .c-avatar-rounded {
            border-radius: 0.25rem;
        }

        .c-avatar-square {
            border-radius: 0;
        }

        .badge {
            display: inline-block;
            padding: 0.25em 0.4em;
            font-size: 75%;
            font-weight: 700;
            line-height: 1;
            text-align: center;
            white-space: nowrap;
            vertical-align: baseline;
            border-radius: 0.25rem;
            transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        @media (prefers-reduced-motion: reduce) {
            .badge {
                transition: none;
            }
        }

        a.badge:hover, a.badge:focus {
            text-decoration: none;
        }

        .badge:empty {
            display: none;
        }

        .btn .badge {
            position: relative;
            top: -1px;
        }

        .badge-pill {
            padding-right: 0.6em;
            padding-left: 0.6em;
            border-radius: 10rem;
        }

        .badge-primary {
            color: #fff;
            background-color: #321fdb;
        }

        a.badge-primary:hover, a.badge-primary:focus {
            color: #fff;
            background-color: #2819ae;
        }

        a.badge-primary:focus, a.badge-primary.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.5);
        }

        .badge-secondary {
            color: #4f5d73;
            background-color: #ced2d8;
        }

        a.badge-secondary:hover, a.badge-secondary:focus {
            color: #4f5d73;
            background-color: #b2b8c1;
        }

        a.badge-secondary:focus, a.badge-secondary.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(206, 210, 216, 0.5);
        }

        .badge-success {
            color: #fff;
            background-color: #2eb85c;
        }

        a.badge-success:hover, a.badge-success:focus {
            color: #fff;
            background-color: #248f48;
        }

        a.badge-success:focus, a.badge-success.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.5);
        }

        .badge-info {
            color: #fff;
            background-color: #39f;
        }

        a.badge-info:hover, a.badge-info:focus {
            color: #fff;
            background-color: #0080ff;
        }

        a.badge-info:focus, a.badge-info.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(51, 153, 255, 0.5);
        }

        .badge-warning {
            color: #4f5d73;
            background-color: #f9b115;
        }

        a.badge-warning:hover, a.badge-warning:focus {
            color: #4f5d73;
            background-color: #d69405;
        }

        a.badge-warning:focus, a.badge-warning.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(249, 177, 21, 0.5);
        }

        .badge-danger {
            color: #fff;
            background-color: #e55353;
        }

        a.badge-danger:hover, a.badge-danger:focus {
            color: #fff;
            background-color: #de2727;
        }

        a.badge-danger:focus, a.badge-danger.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.5);
        }

        .badge-light {
            color: #4f5d73;
            background-color: #ebedef;
        }

        a.badge-light:hover, a.badge-light:focus {
            color: #4f5d73;
            background-color: #cfd4d8;
        }

        a.badge-light:focus, a.badge-light.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(235, 237, 239, 0.5);
        }

        .badge-dark {
            color: #fff;
            background-color: #636f83;
        }

        a.badge-dark:hover, a.badge-dark:focus {
            color: #fff;
            background-color: #4d5666;
        }

        a.badge-dark:focus, a.badge-dark.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(99, 111, 131, 0.5);
        }

        html:not([dir="rtl"]) .breadcrumb-menu {
            margin-left: auto;
            margin-right: auto;
        }

        .breadcrumb-menu::before {
            display: none;
        }

        .breadcrumb-menu .btn-group,.breadcrumb-menu .btn {
            vertical-align: top;
        }

        .breadcrumb-menu .btn {
            padding: 0 0.75rem;
            color: #768192;
            border: 0;
        }

        .breadcrumb-menu .btn:hover, .breadcrumb-menu .btn.active,.breadcrumb-menu .show .btn {
            color: #4f5d73;
            background: transparent;
        }

        .breadcrumb-menu .dropdown-menu {
            min-width: 180px;
            line-height: 1.5;
        }

        .breadcrumb {
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            padding: 0.75rem 1rem;
            margin-bottom: 1.5rem;
            list-style: none;
            border-radius: 0;
            border-bottom: 1px solid;
            background-color: transparent;
            border-color: #d8dbe0;
        }

        .breadcrumb,.breadcrumb-item {
            display: -ms-flexbox;
            display: flex;
        }

        html:not([dir="rtl"]) .breadcrumb-item + .breadcrumb-item {
            padding-left: 0.5rem;
        }

        *[dir="rtl"] .breadcrumb-item + .breadcrumb-item {
            padding-right: 0.5rem;
        }

        .breadcrumb-item + .breadcrumb-item::before {
            display: inline-block;
            color: #8a93a2;
            content: "/";
        }

        html:not([dir="rtl"]) .breadcrumb-item + .breadcrumb-item::before {
            padding-right: 0.5rem;
        }

        *[dir="rtl"] .breadcrumb-item + .breadcrumb-item::before {
            padding-left: 0.5rem;
        }

        .breadcrumb-item + .breadcrumb-item:hover::before {
            text-decoration: underline;
            text-decoration: none;
        }

        .breadcrumb-item.active {
            color: #8a93a2;
        }

        .btn-group,
        .btn-group-vertical {
            position: relative;
            display: -ms-inline-flexbox;
            display: inline-flex;
            vertical-align: middle;
        }

        .btn-group > .btn,
        .btn-group-vertical > .btn {
            position: relative;
            -ms-flex: 1 1 auto;
            flex: 1 1 auto;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-group > .btn:hover,
            .btn-group-vertical > .btn:hover {
                z-index: 1;
            }
        }

        .btn-group > .btn:focus, .btn-group > .btn:active, .btn-group > .btn.active,
        .btn-group-vertical > .btn:focus,
        .btn-group-vertical > .btn:active,
        .btn-group-vertical > .btn.active,.btn-group:not(.show),
        .btn-group-vertical:not(.show) {
            z-index: 1;
        }

        .btn-group .btn-group,
        .btn-group .btn-group-vertical,
        .btn-group-vertical .btn-group,
        .btn-group-vertical .btn-group-vertical {
            z-index: initial;
        }

        .btn-toolbar {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .btn-toolbar .input-group {
            width: auto;
        }

        html:not([dir="rtl"]) .btn-group > .btn:not(:first-child), html:not([dir="rtl"])
        .btn-group > .btn-group:not(:first-child) {
            margin-left: -1px;
        }

        *[dir="rtl"] .btn-group > .btn:not(:first-child), *[dir="rtl"]
        .btn-group > .btn-group:not(:first-child) {
            margin-right: -1px;
        }

        html:not([dir="rtl"]) .btn-group > .btn:not(:last-child):not(.dropdown-toggle),
        html:not([dir="rtl"]) .btn-group > .btn-group:not(:last-child) > .btn {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        html:not([dir="rtl"]) .btn-group > .btn:not(:first-child),
        html:not([dir="rtl"]) .btn-group > .btn-group:not(:first-child) > .btn,*[dir="rtl"] .btn-group > .btn:not(:last-child):not(.dropdown-toggle),
        *[dir="rtl"] .btn-group > .btn-group:not(:last-child) > .btn {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        *[dir="rtl"] .btn-group > .btn:not(:first-child),
        *[dir="rtl"] .btn-group > .btn-group:not(:first-child) > .btn {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .dropdown-toggle-split {
            padding-right: 0.5625rem;
            padding-left: 0.5625rem;
        }

        html:not([dir="rtl"]) .dropdown-toggle-split::after, html:not([dir="rtl"])
        .dropup .dropdown-toggle-split::after, html:not([dir="rtl"])
        .dropright .dropdown-toggle-split::after {
            margin-left: 0;
        }

        *[dir="rtl"] .dropdown-toggle-split::after, *[dir="rtl"]
        .dropup .dropdown-toggle-split::after, *[dir="rtl"]
        .dropright .dropdown-toggle-split::after,html:not([dir="rtl"]) .dropleft .dropdown-toggle-split::before {
            margin-right: 0;
        }

        *[dir="rtl"] .dropleft .dropdown-toggle-split::before {
            margin-left: 0;
        }

        .btn-sm + .dropdown-toggle-split, .btn-group-sm > .btn + .dropdown-toggle-split {
            padding-right: 0.375rem;
            padding-left: 0.375rem;
        }

        .btn-lg + .dropdown-toggle-split, .btn-group-lg > .btn + .dropdown-toggle-split {
            padding-right: 0.75rem;
            padding-left: 0.75rem;
        }

        .btn-group-vertical {
            -ms-flex-direction: column;
            flex-direction: column;
            -ms-flex-align: start;
            align-items: flex-start;
            -ms-flex-pack: center;
            justify-content: center;
        }

        .btn-group-vertical > .btn,
        .btn-group-vertical > .btn-group {
            width: 100%;
        }

        .btn-group-vertical > .btn:not(:first-child),
        .btn-group-vertical > .btn-group:not(:first-child) {
            margin-top: -1px;
        }

        .btn-group-vertical > .btn:not(:last-child):not(.dropdown-toggle),
        .btn-group-vertical > .btn-group:not(:last-child) > .btn {
            border-bottom-right-radius: 0;
            border-bottom-left-radius: 0;
        }

        .btn-group-vertical > .btn:not(:first-child),
        .btn-group-vertical > .btn-group:not(:first-child) > .btn {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }

        .btn-group-toggle > .btn,
        .btn-group-toggle > .btn-group > .btn {
            margin-bottom: 0;
        }

        .btn-group-toggle > .btn input[type="radio"],
        .btn-group-toggle > .btn input[type="checkbox"],
        .btn-group-toggle > .btn-group > .btn input[type="radio"],
        .btn-group-toggle > .btn-group > .btn input[type="checkbox"] {
            position: absolute;
            clip: rect(0, 0, 0, 0);
            pointer-events: none;
        }

        .btn {
            display: inline-block;
            font-weight: 400;
            color: #4f5d73;
            text-align: center;
            vertical-align: middle;
            cursor: pointer;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            background-color: transparent;
            border: 1px solid transparent;
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            line-height: 1.5;
            border-radius: 0.25rem;
            transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        .btn i,
        .btn .c-icon {
            width: 0.875rem;
            height: 0.875rem;
            margin: 0.21875rem 0;
            height: 0.875rem;
            margin: 0.21875rem 0;
        }

        @media (prefers-reduced-motion: reduce) {
            .btn {
                transition: none;
            }
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn:hover {
                color: #4f5d73;
                text-decoration: none;
            }
        }

        .btn:focus, .btn.focus {
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        .btn.disabled, .btn:disabled {
            opacity: 0.65;
        }

        .btn:not(:disabled):not(.disabled) {
            cursor: pointer;
        }

        a.btn.disabled,
        fieldset:disabled a.btn {
            pointer-events: none;
        }

        .btn-primary {
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-primary:hover {
                color: #fff;
                background-color: #2a1ab9;
                border-color: #2819ae;
            }
        }

        .btn-primary:focus, .btn-primary.focus {
            color: #fff;
            background-color: #2a1ab9;
            border-color: #2819ae;
            box-shadow: 0 0 0 0.2rem rgba(81, 65, 224, 0.5);
        }

        .btn-primary.disabled, .btn-primary:disabled {
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .btn-primary:not(:disabled):not(.disabled):active,
        .show > .btn-primary.dropdown-toggle {
            color: #fff;
            background-color: #2819ae;
            border-color: #2517a3;
        }

        .btn-primary:not(:disabled):not(.disabled):active:focus,
        .show > .btn-primary.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(81, 65, 224, 0.5);
        }

        .show > .btn-primary.dropdown-toggle {
            color: #fff;
            background-color: #2819ae;
            border-color: #2517a3;
        }

        .show > .btn-primary.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(81, 65, 224, 0.5);
        }

        .btn-secondary {
            color: #4f5d73;
            background-color: #ced2d8;
            border-color: #ced2d8;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-secondary:hover {
                color: #4f5d73;
                background-color: #b9bec7;
                border-color: #b2b8c1;
            }
        }

        .btn-secondary:focus, .btn-secondary.focus {
            color: #4f5d73;
            background-color: #b9bec7;
            border-color: #b2b8c1;
            box-shadow: 0 0 0 0.2rem rgba(187, 192, 201, 0.5);
        }

        .btn-secondary.disabled, .btn-secondary:disabled {
            color: #4f5d73;
            background-color: #ced2d8;
            border-color: #ced2d8;
        }

        .btn-secondary:not(:disabled):not(.disabled):active,
        .show > .btn-secondary.dropdown-toggle {
            color: #4f5d73;
            background-color: #b2b8c1;
            border-color: #abb1bc;
        }

        .btn-secondary:not(:disabled):not(.disabled):active:focus,
        .show > .btn-secondary.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(187, 192, 201, 0.5);
        }

        .show > .btn-secondary.dropdown-toggle {
            color: #4f5d73;
            background-color: #b2b8c1;
            border-color: #abb1bc;
        }

        .show > .btn-secondary.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(187, 192, 201, 0.5);
        }

        .btn-success {
            color: #fff;
            background-color: #2eb85c;
            border-color: #2eb85c;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-success:hover {
                color: #fff;
                background-color: #26994d;
                border-color: #248f48;
            }
        }

        .btn-success:focus, .btn-success.focus {
            color: #fff;
            background-color: #26994d;
            border-color: #248f48;
            box-shadow: 0 0 0 0.2rem rgba(77, 195, 116, 0.5);
        }

        .btn-success.disabled, .btn-success:disabled {
            color: #fff;
            background-color: #2eb85c;
            border-color: #2eb85c;
        }

        .btn-success:not(:disabled):not(.disabled):active,
        .show > .btn-success.dropdown-toggle {
            color: #fff;
            background-color: #248f48;
            border-color: #218543;
        }

        .btn-success:not(:disabled):not(.disabled):active:focus,
        .show > .btn-success.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(77, 195, 116, 0.5);
        }

        .show > .btn-success.dropdown-toggle {
            color: #fff;
            background-color: #248f48;
            border-color: #218543;
        }

        .show > .btn-success.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(77, 195, 116, 0.5);
        }

        .btn-info {
            color: #fff;
            background-color: #39f;
            border-color: #39f;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-info:hover {
                color: #fff;
                background-color: #0d86ff;
                border-color: #0080ff;
            }
        }

        .btn-info:focus, .btn-info.focus {
            color: #fff;
            background-color: #0d86ff;
            border-color: #0080ff;
            box-shadow: 0 0 0 0.2rem rgba(82, 168, 255, 0.5);
        }

        .btn-info.disabled, .btn-info:disabled {
            color: #fff;
            background-color: #39f;
            border-color: #39f;
        }

        .btn-info:not(:disabled):not(.disabled):active,
        .show > .btn-info.dropdown-toggle {
            color: #fff;
            background-color: #0080ff;
            border-color: #0079f2;
        }

        .btn-info:not(:disabled):not(.disabled):active:focus,
        .show > .btn-info.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(82, 168, 255, 0.5);
        }

        .show > .btn-info.dropdown-toggle {
            color: #fff;
            background-color: #0080ff;
            border-color: #0079f2;
        }

        .show > .btn-info.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(82, 168, 255, 0.5);
        }

        .btn-warning {
            color: #4f5d73;
            background-color: #f9b115;
            border-color: #f9b115;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-warning:hover {
                color: #4f5d73;
                background-color: #e29c06;
                border-color: #d69405;
            }
        }

        .btn-warning:focus, .btn-warning.focus {
            color: #4f5d73;
            background-color: #e29c06;
            border-color: #d69405;
            box-shadow: 0 0 0 0.2rem rgba(224, 164, 35, 0.5);
        }

        .btn-warning.disabled, .btn-warning:disabled {
            color: #4f5d73;
            background-color: #f9b115;
            border-color: #f9b115;
        }

        .btn-warning:not(:disabled):not(.disabled):active,
        .show > .btn-warning.dropdown-toggle {
            color: #4f5d73;
            background-color: #d69405;
            border-color: #c98b05;
        }

        .btn-warning:not(:disabled):not(.disabled):active:focus,
        .show > .btn-warning.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(224, 164, 35, 0.5);
        }

        .show > .btn-warning.dropdown-toggle {
            color: #4f5d73;
            background-color: #d69405;
            border-color: #c98b05;
        }

        .show > .btn-warning.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(224, 164, 35, 0.5);
        }

        .btn-danger {
            color: #fff;
            background-color: #e55353;
            border-color: #e55353;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-danger:hover {
                color: #fff;
                background-color: #e03232;
                border-color: #de2727;
            }
        }

        .btn-danger:focus, .btn-danger.focus {
            color: #fff;
            background-color: #e03232;
            border-color: #de2727;
            box-shadow: 0 0 0 0.2rem rgba(233, 109, 109, 0.5);
        }

        .btn-danger.disabled, .btn-danger:disabled {
            color: #fff;
            background-color: #e55353;
            border-color: #e55353;
        }

        .btn-danger:not(:disabled):not(.disabled):active,
        .show > .btn-danger.dropdown-toggle {
            color: #fff;
            background-color: #de2727;
            border-color: #d82121;
        }

        .btn-danger:not(:disabled):not(.disabled):active:focus,
        .show > .btn-danger.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(233, 109, 109, 0.5);
        }

        .show > .btn-danger.dropdown-toggle {
            color: #fff;
            background-color: #de2727;
            border-color: #d82121;
        }

        .show > .btn-danger.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(233, 109, 109, 0.5);
        }

        .btn-light {
            color: #4f5d73;
            background-color: #ebedef;
            border-color: #ebedef;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-light:hover {
                color: #4f5d73;
                background-color: #d6dade;
                border-color: #cfd4d8;
            }
        }

        .btn-light:focus, .btn-light.focus {
            color: #4f5d73;
            background-color: #d6dade;
            border-color: #cfd4d8;
            box-shadow: 0 0 0 0.2rem rgba(212, 215, 220, 0.5);
        }

        .btn-light.disabled, .btn-light:disabled {
            color: #4f5d73;
            background-color: #ebedef;
            border-color: #ebedef;
        }

        .btn-light:not(:disabled):not(.disabled):active,
        .show > .btn-light.dropdown-toggle {
            color: #4f5d73;
            background-color: #cfd4d8;
            border-color: #c8cdd3;
        }

        .btn-light:not(:disabled):not(.disabled):active:focus,
        .show > .btn-light.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(212, 215, 220, 0.5);
        }

        .show > .btn-light.dropdown-toggle {
            color: #4f5d73;
            background-color: #cfd4d8;
            border-color: #c8cdd3;
        }

        .show > .btn-light.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(212, 215, 220, 0.5);
        }

        .btn-dark {
            color: #fff;
            background-color: #636f83;
            border-color: #636f83;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-dark:hover {
                color: #fff;
                background-color: #535d6d;
                border-color: #4d5666;
            }
        }

        .btn-dark:focus, .btn-dark.focus {
            color: #fff;
            background-color: #535d6d;
            border-color: #4d5666;
            box-shadow: 0 0 0 0.2rem rgba(122, 133, 150, 0.5);
        }

        .btn-dark.disabled, .btn-dark:disabled {
            color: #fff;
            background-color: #636f83;
            border-color: #636f83;
        }

        .btn-dark:not(:disabled):not(.disabled):active,
        .show > .btn-dark.dropdown-toggle {
            color: #fff;
            background-color: #4d5666;
            border-color: #48505f;
        }

        .btn-dark:not(:disabled):not(.disabled):active:focus,
        .show > .btn-dark.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(122, 133, 150, 0.5);
        }

        .show > .btn-dark.dropdown-toggle {
            color: #fff;
            background-color: #4d5666;
            border-color: #48505f;
        }

        .show > .btn-dark.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(122, 133, 150, 0.5);
        }

        .btn-transparent {
            color: rgba(255, 255, 255, 0.8);
        }

        .btn-transparent:hover {
            color: white;
        }

        .btn-outline-primary {
            color: #321fdb;
            border-color: #321fdb;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-outline-primary:hover {
                color: #fff;
                background-color: #321fdb;
                border-color: #321fdb;
            }
        }

        .btn-outline-primary:focus, .btn-outline-primary.focus {
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.5);
        }

        .btn-outline-primary.disabled, .btn-outline-primary:disabled {
            color: #321fdb;
            background-color: transparent;
        }

        .btn-outline-primary:not(:disabled):not(.disabled):active, .btn-outline-primary:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .btn-outline-primary:not(:disabled):not(.disabled):active:focus, .btn-outline-primary:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.5);
        }

        .show > .btn-outline-primary.dropdown-toggle {
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .show > .btn-outline-primary.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.5);
        }

        .btn-outline-secondary {
            color: #ced2d8;
            border-color: #ced2d8;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-outline-secondary:hover {
                color: #4f5d73;
                background-color: #ced2d8;
                border-color: #ced2d8;
            }
        }

        .btn-outline-secondary:focus, .btn-outline-secondary.focus {
            box-shadow: 0 0 0 0.2rem rgba(206, 210, 216, 0.5);
        }

        .btn-outline-secondary.disabled, .btn-outline-secondary:disabled {
            color: #ced2d8;
            background-color: transparent;
        }

        .btn-outline-secondary:not(:disabled):not(.disabled):active, .btn-outline-secondary:not(:disabled):not(.disabled).active {
            color: #4f5d73;
            background-color: #ced2d8;
            border-color: #ced2d8;
        }

        .btn-outline-secondary:not(:disabled):not(.disabled):active:focus, .btn-outline-secondary:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(206, 210, 216, 0.5);
        }

        .show > .btn-outline-secondary.dropdown-toggle {
            color: #4f5d73;
            background-color: #ced2d8;
            border-color: #ced2d8;
        }

        .show > .btn-outline-secondary.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(206, 210, 216, 0.5);
        }

        .btn-outline-success {
            color: #2eb85c;
            border-color: #2eb85c;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-outline-success:hover {
                color: #fff;
                background-color: #2eb85c;
                border-color: #2eb85c;
            }
        }

        .btn-outline-success:focus, .btn-outline-success.focus {
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.5);
        }

        .btn-outline-success.disabled, .btn-outline-success:disabled {
            color: #2eb85c;
            background-color: transparent;
        }

        .btn-outline-success:not(:disabled):not(.disabled):active, .btn-outline-success:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #2eb85c;
            border-color: #2eb85c;
        }

        .btn-outline-success:not(:disabled):not(.disabled):active:focus, .btn-outline-success:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.5);
        }

        .show > .btn-outline-success.dropdown-toggle {
            color: #fff;
            background-color: #2eb85c;
            border-color: #2eb85c;
        }

        .show > .btn-outline-success.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.5);
        }

        .btn-outline-info {
            color: #39f;
            border-color: #39f;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-outline-info:hover {
                color: #fff;
                background-color: #39f;
                border-color: #39f;
            }
        }

        .btn-outline-info:focus, .btn-outline-info.focus {
            box-shadow: 0 0 0 0.2rem rgba(51, 153, 255, 0.5);
        }

        .btn-outline-info.disabled, .btn-outline-info:disabled {
            color: #39f;
            background-color: transparent;
        }

        .btn-outline-info:not(:disabled):not(.disabled):active, .btn-outline-info:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #39f;
            border-color: #39f;
        }

        .btn-outline-info:not(:disabled):not(.disabled):active:focus, .btn-outline-info:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(51, 153, 255, 0.5);
        }

        .show > .btn-outline-info.dropdown-toggle {
            color: #fff;
            background-color: #39f;
            border-color: #39f;
        }

        .show > .btn-outline-info.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(51, 153, 255, 0.5);
        }

        .btn-outline-warning {
            color: #f9b115;
            border-color: #f9b115;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-outline-warning:hover {
                color: #4f5d73;
                background-color: #f9b115;
                border-color: #f9b115;
            }
        }

        .btn-outline-warning:focus, .btn-outline-warning.focus {
            box-shadow: 0 0 0 0.2rem rgba(249, 177, 21, 0.5);
        }

        .btn-outline-warning.disabled, .btn-outline-warning:disabled {
            color: #f9b115;
            background-color: transparent;
        }

        .btn-outline-warning:not(:disabled):not(.disabled):active, .btn-outline-warning:not(:disabled):not(.disabled).active {
            color: #4f5d73;
            background-color: #f9b115;
            border-color: #f9b115;
        }

        .btn-outline-warning:not(:disabled):not(.disabled):active:focus, .btn-outline-warning:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(249, 177, 21, 0.5);
        }

        .show > .btn-outline-warning.dropdown-toggle {
            color: #4f5d73;
            background-color: #f9b115;
            border-color: #f9b115;
        }

        .show > .btn-outline-warning.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(249, 177, 21, 0.5);
        }

        .btn-outline-danger {
            color: #e55353;
            border-color: #e55353;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-outline-danger:hover {
                color: #fff;
                background-color: #e55353;
                border-color: #e55353;
            }
        }

        .btn-outline-danger:focus, .btn-outline-danger.focus {
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.5);
        }

        .btn-outline-danger.disabled, .btn-outline-danger:disabled {
            color: #e55353;
            background-color: transparent;
        }

        .btn-outline-danger:not(:disabled):not(.disabled):active, .btn-outline-danger:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #e55353;
            border-color: #e55353;
        }

        .btn-outline-danger:not(:disabled):not(.disabled):active:focus, .btn-outline-danger:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.5);
        }

        .show > .btn-outline-danger.dropdown-toggle {
            color: #fff;
            background-color: #e55353;
            border-color: #e55353;
        }

        .show > .btn-outline-danger.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.5);
        }

        .btn-outline-light {
            color: #ebedef;
            border-color: #ebedef;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-outline-light:hover {
                color: #4f5d73;
                background-color: #ebedef;
                border-color: #ebedef;
            }
        }

        .btn-outline-light:focus, .btn-outline-light.focus {
            box-shadow: 0 0 0 0.2rem rgba(235, 237, 239, 0.5);
        }

        .btn-outline-light.disabled, .btn-outline-light:disabled {
            color: #ebedef;
            background-color: transparent;
        }

        .btn-outline-light:not(:disabled):not(.disabled):active, .btn-outline-light:not(:disabled):not(.disabled).active {
            color: #4f5d73;
            background-color: #ebedef;
            border-color: #ebedef;
        }

        .btn-outline-light:not(:disabled):not(.disabled):active:focus, .btn-outline-light:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(235, 237, 239, 0.5);
        }

        .show > .btn-outline-light.dropdown-toggle {
            color: #4f5d73;
            background-color: #ebedef;
            border-color: #ebedef;
        }

        .show > .btn-outline-light.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(235, 237, 239, 0.5);
        }

        .btn-outline-dark {
            color: #636f83;
            border-color: #636f83;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-outline-dark:hover {
                color: #fff;
                background-color: #636f83;
                border-color: #636f83;
            }
        }

        .btn-outline-dark:focus, .btn-outline-dark.focus {
            box-shadow: 0 0 0 0.2rem rgba(99, 111, 131, 0.5);
        }

        .btn-outline-dark.disabled, .btn-outline-dark:disabled {
            color: #636f83;
            background-color: transparent;
        }

        .btn-outline-dark:not(:disabled):not(.disabled):active, .btn-outline-dark:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #636f83;
            border-color: #636f83;
        }

        .btn-outline-dark:not(:disabled):not(.disabled):active:focus, .btn-outline-dark:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(99, 111, 131, 0.5);
        }

        .show > .btn-outline-dark.dropdown-toggle {
            color: #fff;
            background-color: #636f83;
            border-color: #636f83;
        }

        .show > .btn-outline-dark.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(99, 111, 131, 0.5);
        }

        .btn-link {
            font-weight: 400;
            color: #321fdb;
            text-decoration: none;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-link:hover {
                color: #231698;
                text-decoration: underline;
            }
        }

        .btn-link:focus, .btn-link.focus {
            text-decoration: underline;
        }

        .btn-link:disabled, .btn-link.disabled {
            color: #8a93a2;
            pointer-events: none;
        }

        .btn-lg, .btn-group-lg > .btn {
            padding: 0.5rem 1rem;
            font-size: 1.09375rem;
            line-height: 1.5;
            border-radius: 0.3rem;
        }

        .btn-lg i, .btn-group-lg > .btn i,
        .btn-lg .c-icon,
        .btn-group-lg > .btn .c-icon {
            width: 1.09375rem;
            height: 1.09375rem;
            margin: 0.2734375rem 0;
        }

        .btn-sm, .btn-group-sm > .btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.765625rem;
            line-height: 1.5;
            border-radius: 0.2rem;
        }

        .btn-sm i, .btn-group-sm > .btn i,
        .btn-sm .c-icon,
        .btn-group-sm > .btn .c-icon {
            width: 0.765625rem;
            height: 0.765625rem;
            margin: 0.19140625rem 0;
        }

        .btn-block {
            display: block;
            width: 100%;
        }

        .btn-block + .btn-block {
            margin-top: 0.5rem;
        }

        input[type="submit"].btn-block,
        input[type="reset"].btn-block,
        input[type="button"].btn-block {
            width: 100%;
        }

        .btn-pill {
            border-radius: 50em;
        }

        .btn-square {
            border-radius: 0;
        }

        .btn-ghost-primary {
            color: #321fdb;
            background-color: transparent;
            background-image: none;
            border-color: transparent;
        }

        .btn-ghost-primary:hover {
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .btn-ghost-primary:focus, .btn-ghost-primary.focus {
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.5);
        }

        .btn-ghost-primary.disabled, .btn-ghost-primary:disabled {
            color: #321fdb;
            background-color: transparent;
            border-color: transparent;
        }

        .btn-ghost-primary:not(:disabled):not(.disabled):active, .btn-ghost-primary:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .btn-ghost-primary:not(:disabled):not(.disabled):active:focus, .btn-ghost-primary:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.5);
        }

        .show > .btn-ghost-primary.dropdown-toggle {
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .show > .btn-ghost-primary.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.5);
        }

        .btn-ghost-secondary {
            color: #ced2d8;
            background-color: transparent;
            background-image: none;
            border-color: transparent;
        }

        .btn-ghost-secondary:hover {
            color: #4f5d73;
            background-color: #ced2d8;
            border-color: #ced2d8;
        }

        .btn-ghost-secondary:focus, .btn-ghost-secondary.focus {
            box-shadow: 0 0 0 0.2rem rgba(206, 210, 216, 0.5);
        }

        .btn-ghost-secondary.disabled, .btn-ghost-secondary:disabled {
            color: #ced2d8;
            background-color: transparent;
            border-color: transparent;
        }

        .btn-ghost-secondary:not(:disabled):not(.disabled):active, .btn-ghost-secondary:not(:disabled):not(.disabled).active {
            color: #4f5d73;
            background-color: #ced2d8;
            border-color: #ced2d8;
        }

        .btn-ghost-secondary:not(:disabled):not(.disabled):active:focus, .btn-ghost-secondary:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(206, 210, 216, 0.5);
        }

        .show > .btn-ghost-secondary.dropdown-toggle {
            color: #4f5d73;
            background-color: #ced2d8;
            border-color: #ced2d8;
        }

        .show > .btn-ghost-secondary.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(206, 210, 216, 0.5);
        }

        .btn-ghost-success {
            color: #2eb85c;
            background-color: transparent;
            background-image: none;
            border-color: transparent;
        }

        .btn-ghost-success:hover {
            color: #fff;
            background-color: #2eb85c;
            border-color: #2eb85c;
        }

        .btn-ghost-success:focus, .btn-ghost-success.focus {
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.5);
        }

        .btn-ghost-success.disabled, .btn-ghost-success:disabled {
            color: #2eb85c;
            background-color: transparent;
            border-color: transparent;
        }

        .btn-ghost-success:not(:disabled):not(.disabled):active, .btn-ghost-success:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #2eb85c;
            border-color: #2eb85c;
        }

        .btn-ghost-success:not(:disabled):not(.disabled):active:focus, .btn-ghost-success:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.5);
        }

        .show > .btn-ghost-success.dropdown-toggle {
            color: #fff;
            background-color: #2eb85c;
            border-color: #2eb85c;
        }

        .show > .btn-ghost-success.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.5);
        }

        .btn-ghost-info {
            color: #39f;
            background-color: transparent;
            background-image: none;
            border-color: transparent;
        }

        .btn-ghost-info:hover {
            color: #fff;
            background-color: #39f;
            border-color: #39f;
        }

        .btn-ghost-info:focus, .btn-ghost-info.focus {
            box-shadow: 0 0 0 0.2rem rgba(51, 153, 255, 0.5);
        }

        .btn-ghost-info.disabled, .btn-ghost-info:disabled {
            color: #39f;
            background-color: transparent;
            border-color: transparent;
        }

        .btn-ghost-info:not(:disabled):not(.disabled):active, .btn-ghost-info:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #39f;
            border-color: #39f;
        }

        .btn-ghost-info:not(:disabled):not(.disabled):active:focus, .btn-ghost-info:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(51, 153, 255, 0.5);
        }

        .show > .btn-ghost-info.dropdown-toggle {
            color: #fff;
            background-color: #39f;
            border-color: #39f;
        }

        .show > .btn-ghost-info.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(51, 153, 255, 0.5);
        }

        .btn-ghost-warning {
            color: #f9b115;
            background-color: transparent;
            background-image: none;
            border-color: transparent;
        }

        .btn-ghost-warning:hover {
            color: #4f5d73;
            background-color: #f9b115;
            border-color: #f9b115;
        }

        .btn-ghost-warning:focus, .btn-ghost-warning.focus {
            box-shadow: 0 0 0 0.2rem rgba(249, 177, 21, 0.5);
        }

        .btn-ghost-warning.disabled, .btn-ghost-warning:disabled {
            color: #f9b115;
            background-color: transparent;
            border-color: transparent;
        }

        .btn-ghost-warning:not(:disabled):not(.disabled):active, .btn-ghost-warning:not(:disabled):not(.disabled).active {
            color: #4f5d73;
            background-color: #f9b115;
            border-color: #f9b115;
        }

        .btn-ghost-warning:not(:disabled):not(.disabled):active:focus, .btn-ghost-warning:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(249, 177, 21, 0.5);
        }

        .show > .btn-ghost-warning.dropdown-toggle {
            color: #4f5d73;
            background-color: #f9b115;
            border-color: #f9b115;
        }

        .show > .btn-ghost-warning.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(249, 177, 21, 0.5);
        }

        .btn-ghost-danger {
            color: #e55353;
            background-color: transparent;
            background-image: none;
            border-color: transparent;
        }

        .btn-ghost-danger:hover {
            color: #fff;
            background-color: #e55353;
            border-color: #e55353;
        }

        .btn-ghost-danger:focus, .btn-ghost-danger.focus {
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.5);
        }

        .btn-ghost-danger.disabled, .btn-ghost-danger:disabled {
            color: #e55353;
            background-color: transparent;
            border-color: transparent;
        }

        .btn-ghost-danger:not(:disabled):not(.disabled):active, .btn-ghost-danger:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #e55353;
            border-color: #e55353;
        }

        .btn-ghost-danger:not(:disabled):not(.disabled):active:focus, .btn-ghost-danger:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.5);
        }

        .show > .btn-ghost-danger.dropdown-toggle {
            color: #fff;
            background-color: #e55353;
            border-color: #e55353;
        }

        .show > .btn-ghost-danger.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.5);
        }

        .btn-ghost-light {
            color: #ebedef;
            background-color: transparent;
            background-image: none;
            border-color: transparent;
        }

        .btn-ghost-light:hover {
            color: #4f5d73;
            background-color: #ebedef;
            border-color: #ebedef;
        }

        .btn-ghost-light:focus, .btn-ghost-light.focus {
            box-shadow: 0 0 0 0.2rem rgba(235, 237, 239, 0.5);
        }

        .btn-ghost-light.disabled, .btn-ghost-light:disabled {
            color: #ebedef;
            background-color: transparent;
            border-color: transparent;
        }

        .btn-ghost-light:not(:disabled):not(.disabled):active, .btn-ghost-light:not(:disabled):not(.disabled).active {
            color: #4f5d73;
            background-color: #ebedef;
            border-color: #ebedef;
        }

        .btn-ghost-light:not(:disabled):not(.disabled):active:focus, .btn-ghost-light:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(235, 237, 239, 0.5);
        }

        .show > .btn-ghost-light.dropdown-toggle {
            color: #4f5d73;
            background-color: #ebedef;
            border-color: #ebedef;
        }

        .show > .btn-ghost-light.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(235, 237, 239, 0.5);
        }

        .btn-ghost-dark {
            color: #636f83;
            background-color: transparent;
            background-image: none;
            border-color: transparent;
        }

        .btn-ghost-dark:hover {
            color: #fff;
            background-color: #636f83;
            border-color: #636f83;
        }

        .btn-ghost-dark:focus, .btn-ghost-dark.focus {
            box-shadow: 0 0 0 0.2rem rgba(99, 111, 131, 0.5);
        }

        .btn-ghost-dark.disabled, .btn-ghost-dark:disabled {
            color: #636f83;
            background-color: transparent;
            border-color: transparent;
        }

        .btn-ghost-dark:not(:disabled):not(.disabled):active, .btn-ghost-dark:not(:disabled):not(.disabled).active {
            color: #fff;
            background-color: #636f83;
            border-color: #636f83;
        }

        .btn-ghost-dark:not(:disabled):not(.disabled):active:focus, .btn-ghost-dark:not(:disabled):not(.disabled).active:focus {
            box-shadow: 0 0 0 0.2rem rgba(99, 111, 131, 0.5);
        }

        .show > .btn-ghost-dark.dropdown-toggle {
            color: #fff;
            background-color: #636f83;
            border-color: #636f83;
        }

        .show > .btn-ghost-dark.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(99, 111, 131, 0.5);
        }

        .btn-facebook {
            color: #fff;
            background-color: #3b5998;
            border-color: #3b5998;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-facebook:hover {
                color: #fff;
                background-color: #30497c;
                border-color: #2d4373;
            }
        }

        .btn-facebook:focus, .btn-facebook.focus {
            color: #fff;
            background-color: #30497c;
            border-color: #2d4373;
            box-shadow: 0 0 0 0.2rem rgba(88, 114, 167, 0.5);
        }

        .btn-facebook.disabled, .btn-facebook:disabled {
            color: #fff;
            background-color: #3b5998;
            border-color: #3b5998;
        }

        .btn-facebook:not(:disabled):not(.disabled):active,
        .show > .btn-facebook.dropdown-toggle {
            color: #fff;
            background-color: #2d4373;
            border-color: #293e6a;
        }

        .btn-facebook:not(:disabled):not(.disabled):active:focus,
        .show > .btn-facebook.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(88, 114, 167, 0.5);
        }

        .show > .btn-facebook.dropdown-toggle {
            color: #fff;
            background-color: #2d4373;
            border-color: #293e6a;
        }

        .show > .btn-facebook.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(88, 114, 167, 0.5);
        }

        .btn-twitter {
            color: #fff;
            background-color: #00aced;
            border-color: #00aced;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-twitter:hover {
                color: #fff;
                background-color: #0090c7;
                border-color: #0087ba;
            }
        }

        .btn-twitter:focus, .btn-twitter.focus {
            color: #fff;
            background-color: #0090c7;
            border-color: #0087ba;
            box-shadow: 0 0 0 0.2rem rgba(38, 184, 240, 0.5);
        }

        .btn-twitter.disabled, .btn-twitter:disabled {
            color: #fff;
            background-color: #00aced;
            border-color: #00aced;
        }

        .btn-twitter:not(:disabled):not(.disabled):active,
        .show > .btn-twitter.dropdown-toggle {
            color: #fff;
            background-color: #0087ba;
            border-color: #007ead;
        }

        .btn-twitter:not(:disabled):not(.disabled):active:focus,
        .show > .btn-twitter.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(38, 184, 240, 0.5);
        }

        .show > .btn-twitter.dropdown-toggle {
            color: #fff;
            background-color: #0087ba;
            border-color: #007ead;
        }

        .show > .btn-twitter.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(38, 184, 240, 0.5);
        }

        .btn-linkedin {
            color: #fff;
            background-color: #4875b4;
            border-color: #4875b4;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-linkedin:hover {
                color: #fff;
                background-color: #3d6399;
                border-color: #395d90;
            }
        }

        .btn-linkedin:focus, .btn-linkedin.focus {
            color: #fff;
            background-color: #3d6399;
            border-color: #395d90;
            box-shadow: 0 0 0 0.2rem rgba(99, 138, 191, 0.5);
        }

        .btn-linkedin.disabled, .btn-linkedin:disabled {
            color: #fff;
            background-color: #4875b4;
            border-color: #4875b4;
        }

        .btn-linkedin:not(:disabled):not(.disabled):active,
        .show > .btn-linkedin.dropdown-toggle {
            color: #fff;
            background-color: #395d90;
            border-color: #365786;
        }

        .btn-linkedin:not(:disabled):not(.disabled):active:focus,
        .show > .btn-linkedin.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(99, 138, 191, 0.5);
        }

        .show > .btn-linkedin.dropdown-toggle {
            color: #fff;
            background-color: #395d90;
            border-color: #365786;
        }

        .show > .btn-linkedin.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(99, 138, 191, 0.5);
        }

        .btn-flickr {
            color: #fff;
            background-color: #ff0084;
            border-color: #ff0084;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-flickr:hover {
                color: #fff;
                background-color: #d90070;
                border-color: #cc006a;
            }
        }

        .btn-flickr:focus, .btn-flickr.focus {
            color: #fff;
            background-color: #d90070;
            border-color: #cc006a;
            box-shadow: 0 0 0 0.2rem rgba(255, 38, 150, 0.5);
        }

        .btn-flickr.disabled, .btn-flickr:disabled {
            color: #fff;
            background-color: #ff0084;
            border-color: #ff0084;
        }

        .btn-flickr:not(:disabled):not(.disabled):active,
        .show > .btn-flickr.dropdown-toggle {
            color: #fff;
            background-color: #cc006a;
            border-color: #bf0063;
        }

        .btn-flickr:not(:disabled):not(.disabled):active:focus,
        .show > .btn-flickr.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(255, 38, 150, 0.5);
        }

        .show > .btn-flickr.dropdown-toggle {
            color: #fff;
            background-color: #cc006a;
            border-color: #bf0063;
        }

        .show > .btn-flickr.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(255, 38, 150, 0.5);
        }

        .btn-tumblr {
            color: #fff;
            background-color: #32506d;
            border-color: #32506d;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-tumblr:hover {
                color: #fff;
                background-color: #263d53;
                border-color: #22364a;
            }
        }

        .btn-tumblr:focus, .btn-tumblr.focus {
            color: #fff;
            background-color: #263d53;
            border-color: #22364a;
            box-shadow: 0 0 0 0.2rem rgba(81, 106, 131, 0.5);
        }

        .btn-tumblr.disabled, .btn-tumblr:disabled {
            color: #fff;
            background-color: #32506d;
            border-color: #32506d;
        }

        .btn-tumblr:not(:disabled):not(.disabled):active,
        .show > .btn-tumblr.dropdown-toggle {
            color: #fff;
            background-color: #22364a;
            border-color: #1e3041;
        }

        .btn-tumblr:not(:disabled):not(.disabled):active:focus,
        .show > .btn-tumblr.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(81, 106, 131, 0.5);
        }

        .show > .btn-tumblr.dropdown-toggle {
            color: #fff;
            background-color: #22364a;
            border-color: #1e3041;
        }

        .show > .btn-tumblr.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(81, 106, 131, 0.5);
        }

        .btn-xing {
            color: #fff;
            background-color: #026466;
            border-color: #026466;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-xing:hover {
                color: #fff;
                background-color: #013f40;
                border-color: #013334;
            }
        }

        .btn-xing:focus, .btn-xing.focus {
            color: #fff;
            background-color: #013f40;
            border-color: #013334;
            box-shadow: 0 0 0 0.2rem rgba(40, 123, 125, 0.5);
        }

        .btn-xing.disabled, .btn-xing:disabled {
            color: #fff;
            background-color: #026466;
            border-color: #026466;
        }

        .btn-xing:not(:disabled):not(.disabled):active,
        .show > .btn-xing.dropdown-toggle {
            color: #fff;
            background-color: #013334;
            border-color: #012727;
        }

        .btn-xing:not(:disabled):not(.disabled):active:focus,
        .show > .btn-xing.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(40, 123, 125, 0.5);
        }

        .show > .btn-xing.dropdown-toggle {
            color: #fff;
            background-color: #013334;
            border-color: #012727;
        }

        .show > .btn-xing.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(40, 123, 125, 0.5);
        }

        .btn-github {
            color: #fff;
            background-color: #4183c4;
            border-color: #4183c4;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-github:hover {
                color: #fff;
                background-color: #3570aa;
                border-color: #3269a0;
            }
        }

        .btn-github:focus, .btn-github.focus {
            color: #fff;
            background-color: #3570aa;
            border-color: #3269a0;
            box-shadow: 0 0 0 0.2rem rgba(94, 150, 205, 0.5);
        }

        .btn-github.disabled, .btn-github:disabled {
            color: #fff;
            background-color: #4183c4;
            border-color: #4183c4;
        }

        .btn-github:not(:disabled):not(.disabled):active,
        .show > .btn-github.dropdown-toggle {
            color: #fff;
            background-color: #3269a0;
            border-color: #2f6397;
        }

        .btn-github:not(:disabled):not(.disabled):active:focus,
        .show > .btn-github.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(94, 150, 205, 0.5);
        }

        .show > .btn-github.dropdown-toggle {
            color: #fff;
            background-color: #3269a0;
            border-color: #2f6397;
        }

        .show > .btn-github.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(94, 150, 205, 0.5);
        }

        .btn-stack-overflow {
            color: #fff;
            background-color: #fe7a15;
            border-color: #fe7a15;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-stack-overflow:hover {
                color: #fff;
                background-color: #ec6701;
                border-color: #df6101;
            }
        }

        .btn-stack-overflow:focus, .btn-stack-overflow.focus {
            color: #fff;
            background-color: #ec6701;
            border-color: #df6101;
            box-shadow: 0 0 0 0.2rem rgba(254, 142, 56, 0.5);
        }

        .btn-stack-overflow.disabled, .btn-stack-overflow:disabled {
            color: #fff;
            background-color: #fe7a15;
            border-color: #fe7a15;
        }

        .btn-stack-overflow:not(:disabled):not(.disabled):active,
        .show > .btn-stack-overflow.dropdown-toggle {
            color: #fff;
            background-color: #df6101;
            border-color: #d25c01;
        }

        .btn-stack-overflow:not(:disabled):not(.disabled):active:focus,
        .show > .btn-stack-overflow.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(254, 142, 56, 0.5);
        }

        .show > .btn-stack-overflow.dropdown-toggle {
            color: #fff;
            background-color: #df6101;
            border-color: #d25c01;
        }

        .show > .btn-stack-overflow.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(254, 142, 56, 0.5);
        }

        .btn-youtube {
            color: #fff;
            background-color: #b00;
            border-color: #b00;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-youtube:hover {
                color: #fff;
                background-color: #950000;
                border-color: #880000;
            }
        }

        .btn-youtube:focus, .btn-youtube.focus {
            color: #fff;
            background-color: #950000;
            border-color: #880000;
            box-shadow: 0 0 0 0.2rem rgba(197, 38, 38, 0.5);
        }

        .btn-youtube.disabled, .btn-youtube:disabled {
            color: #fff;
            background-color: #b00;
            border-color: #b00;
        }

        .btn-youtube:not(:disabled):not(.disabled):active,
        .show > .btn-youtube.dropdown-toggle {
            color: #fff;
            background-color: #880000;
            border-color: #7b0000;
        }

        .btn-youtube:not(:disabled):not(.disabled):active:focus,
        .show > .btn-youtube.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(197, 38, 38, 0.5);
        }

        .show > .btn-youtube.dropdown-toggle {
            color: #fff;
            background-color: #880000;
            border-color: #7b0000;
        }

        .show > .btn-youtube.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(197, 38, 38, 0.5);
        }

        .btn-dribbble {
            color: #fff;
            background-color: #ea4c89;
            border-color: #ea4c89;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-dribbble:hover {
                color: #fff;
                background-color: #e62a72;
                border-color: #e51e6b;
            }
        }

        .btn-dribbble:focus, .btn-dribbble.focus {
            color: #fff;
            background-color: #e62a72;
            border-color: #e51e6b;
            box-shadow: 0 0 0 0.2rem rgba(237, 103, 155, 0.5);
        }

        .btn-dribbble.disabled, .btn-dribbble:disabled {
            color: #fff;
            background-color: #ea4c89;
            border-color: #ea4c89;
        }

        .btn-dribbble:not(:disabled):not(.disabled):active,
        .show > .btn-dribbble.dropdown-toggle {
            color: #fff;
            background-color: #e51e6b;
            border-color: #dc1a65;
        }

        .btn-dribbble:not(:disabled):not(.disabled):active:focus,
        .show > .btn-dribbble.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(237, 103, 155, 0.5);
        }

        .show > .btn-dribbble.dropdown-toggle {
            color: #fff;
            background-color: #e51e6b;
            border-color: #dc1a65;
        }

        .show > .btn-dribbble.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(237, 103, 155, 0.5);
        }

        .btn-instagram {
            color: #fff;
            background-color: #517fa4;
            border-color: #517fa4;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-instagram:hover {
                color: #fff;
                background-color: #446b8a;
                border-color: #406582;
            }
        }

        .btn-instagram:focus, .btn-instagram.focus {
            color: #fff;
            background-color: #446b8a;
            border-color: #406582;
            box-shadow: 0 0 0 0.2rem rgba(107, 146, 178, 0.5);
        }

        .btn-instagram.disabled, .btn-instagram:disabled {
            color: #fff;
            background-color: #517fa4;
            border-color: #517fa4;
        }

        .btn-instagram:not(:disabled):not(.disabled):active,
        .show > .btn-instagram.dropdown-toggle {
            color: #fff;
            background-color: #406582;
            border-color: #3c5e79;
        }

        .btn-instagram:not(:disabled):not(.disabled):active:focus,
        .show > .btn-instagram.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(107, 146, 178, 0.5);
        }

        .show > .btn-instagram.dropdown-toggle {
            color: #fff;
            background-color: #406582;
            border-color: #3c5e79;
        }

        .show > .btn-instagram.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(107, 146, 178, 0.5);
        }

        .btn-pinterest {
            color: #fff;
            background-color: #cb2027;
            border-color: #cb2027;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-pinterest:hover {
                color: #fff;
                background-color: #aa1b21;
                border-color: #9f191f;
            }
        }

        .btn-pinterest:focus, .btn-pinterest.focus {
            color: #fff;
            background-color: #aa1b21;
            border-color: #9f191f;
            box-shadow: 0 0 0 0.2rem rgba(211, 65, 71, 0.5);
        }

        .btn-pinterest.disabled, .btn-pinterest:disabled {
            color: #fff;
            background-color: #cb2027;
            border-color: #cb2027;
        }

        .btn-pinterest:not(:disabled):not(.disabled):active,
        .show > .btn-pinterest.dropdown-toggle {
            color: #fff;
            background-color: #9f191f;
            border-color: #94171c;
        }

        .btn-pinterest:not(:disabled):not(.disabled):active:focus,
        .show > .btn-pinterest.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(211, 65, 71, 0.5);
        }

        .show > .btn-pinterest.dropdown-toggle {
            color: #fff;
            background-color: #9f191f;
            border-color: #94171c;
        }

        .show > .btn-pinterest.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(211, 65, 71, 0.5);
        }

        .btn-vk {
            color: #fff;
            background-color: #45668e;
            border-color: #45668e;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-vk:hover {
                color: #fff;
                background-color: #385474;
                border-color: #344d6c;
            }
        }

        .btn-vk:focus, .btn-vk.focus {
            color: #fff;
            background-color: #385474;
            border-color: #344d6c;
            box-shadow: 0 0 0 0.2rem rgba(97, 125, 159, 0.5);
        }

        .btn-vk.disabled, .btn-vk:disabled {
            color: #fff;
            background-color: #45668e;
            border-color: #45668e;
        }

        .btn-vk:not(:disabled):not(.disabled):active,
        .show > .btn-vk.dropdown-toggle {
            color: #fff;
            background-color: #344d6c;
            border-color: #304763;
        }

        .btn-vk:not(:disabled):not(.disabled):active:focus,
        .show > .btn-vk.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(97, 125, 159, 0.5);
        }

        .show > .btn-vk.dropdown-toggle {
            color: #fff;
            background-color: #344d6c;
            border-color: #304763;
        }

        .show > .btn-vk.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(97, 125, 159, 0.5);
        }

        .btn-yahoo {
            color: #fff;
            background-color: #400191;
            border-color: #400191;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-yahoo:hover {
                color: #fff;
                background-color: #2f016b;
                border-color: #2a015e;
            }
        }

        .btn-yahoo:focus, .btn-yahoo.focus {
            color: #fff;
            background-color: #2f016b;
            border-color: #2a015e;
            box-shadow: 0 0 0 0.2rem rgba(93, 39, 162, 0.5);
        }

        .btn-yahoo.disabled, .btn-yahoo:disabled {
            color: #fff;
            background-color: #400191;
            border-color: #400191;
        }

        .btn-yahoo:not(:disabled):not(.disabled):active,
        .show > .btn-yahoo.dropdown-toggle {
            color: #fff;
            background-color: #2a015e;
            border-color: #240152;
        }

        .btn-yahoo:not(:disabled):not(.disabled):active:focus,
        .show > .btn-yahoo.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(93, 39, 162, 0.5);
        }

        .show > .btn-yahoo.dropdown-toggle {
            color: #fff;
            background-color: #2a015e;
            border-color: #240152;
        }

        .show > .btn-yahoo.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(93, 39, 162, 0.5);
        }

        .btn-behance {
            color: #fff;
            background-color: #1769ff;
            border-color: #1769ff;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-behance:hover {
                color: #fff;
                background-color: #0055f0;
                border-color: #0050e3;
            }
        }

        .btn-behance:focus, .btn-behance.focus {
            color: #fff;
            background-color: #0055f0;
            border-color: #0050e3;
            box-shadow: 0 0 0 0.2rem rgba(58, 128, 255, 0.5);
        }

        .btn-behance.disabled, .btn-behance:disabled {
            color: #fff;
            background-color: #1769ff;
            border-color: #1769ff;
        }

        .btn-behance:not(:disabled):not(.disabled):active,
        .show > .btn-behance.dropdown-toggle {
            color: #fff;
            background-color: #0050e3;
            border-color: #004cd6;
        }

        .btn-behance:not(:disabled):not(.disabled):active:focus,
        .show > .btn-behance.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(58, 128, 255, 0.5);
        }

        .show > .btn-behance.dropdown-toggle {
            color: #fff;
            background-color: #0050e3;
            border-color: #004cd6;
        }

        .show > .btn-behance.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(58, 128, 255, 0.5);
        }

        .btn-reddit {
            color: #fff;
            background-color: #ff4500;
            border-color: #ff4500;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-reddit:hover {
                color: #fff;
                background-color: #d93b00;
                border-color: #cc3700;
            }
        }

        .btn-reddit:focus, .btn-reddit.focus {
            color: #fff;
            background-color: #d93b00;
            border-color: #cc3700;
            box-shadow: 0 0 0 0.2rem rgba(255, 97, 38, 0.5);
        }

        .btn-reddit.disabled, .btn-reddit:disabled {
            color: #fff;
            background-color: #ff4500;
            border-color: #ff4500;
        }

        .btn-reddit:not(:disabled):not(.disabled):active,
        .show > .btn-reddit.dropdown-toggle {
            color: #fff;
            background-color: #cc3700;
            border-color: #bf3400;
        }

        .btn-reddit:not(:disabled):not(.disabled):active:focus,
        .show > .btn-reddit.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(255, 97, 38, 0.5);
        }

        .show > .btn-reddit.dropdown-toggle {
            color: #fff;
            background-color: #cc3700;
            border-color: #bf3400;
        }

        .show > .btn-reddit.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(255, 97, 38, 0.5);
        }

        .btn-vimeo {
            color: #4f5d73;
            background-color: #aad450;
            border-color: #aad450;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .btn-vimeo:hover {
                color: #4f5d73;
                background-color: #9bcc32;
                border-color: #93c130;
            }
        }

        .btn-vimeo:focus, .btn-vimeo.focus {
            color: #4f5d73;
            background-color: #9bcc32;
            border-color: #93c130;
            box-shadow: 0 0 0 0.2rem rgba(156, 194, 85, 0.5);
        }

        .btn-vimeo.disabled, .btn-vimeo:disabled {
            color: #4f5d73;
            background-color: #aad450;
            border-color: #aad450;
        }

        .btn-vimeo:not(:disabled):not(.disabled):active,
        .show > .btn-vimeo.dropdown-toggle {
            color: #4f5d73;
            background-color: #93c130;
            border-color: #8bb72d;
        }

        .btn-vimeo:not(:disabled):not(.disabled):active:focus,
        .show > .btn-vimeo.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(156, 194, 85, 0.5);
        }

        .show > .btn-vimeo.dropdown-toggle {
            color: #4f5d73;
            background-color: #93c130;
            border-color: #8bb72d;
        }

        .show > .btn-vimeo.dropdown-toggle:focus {
            box-shadow: 0 0 0 0.2rem rgba(156, 194, 85, 0.5);
        }

        .c-callout {
            position: relative;
            padding: 0 1rem;
            margin: 1rem 0;
            border-radius: 0.25rem;
        }

        html:not([dir="rtl"]) .c-callout {
            border-left: 4px solid #d8dbe0;
        }

        *[dir="rtl"] .c-callout {
            border-right: 4px solid #d8dbe0;
        }

        .c-callout-bordered {
            border: 1px solid #d8dbe0;
            border-left-width: 4px;
        }

        .c-callout code {
            border-radius: 0.25rem;
        }

        .c-callout h4 {
            margin-top: 0;
            margin-bottom: .25rem;
        }

        .c-callout p:last-child {
            margin-bottom: 0;
        }

        .c-callout + .c-callout {
            margin-top: -0.25rem;
        }

        html:not([dir="rtl"]) .c-callout-primary {
            border-left-color: #321fdb;
        }

        *[dir="rtl"] .c-callout-primary {
            border-right-color: #321fdb;
        }

        .c-callout-primary h4 {
            color: #321fdb;
        }

        html:not([dir="rtl"]) .c-callout-secondary {
            border-left-color: #ced2d8;
        }

        *[dir="rtl"] .c-callout-secondary {
            border-right-color: #ced2d8;
        }

        .c-callout-secondary h4 {
            color: #ced2d8;
        }

        html:not([dir="rtl"]) .c-callout-success {
            border-left-color: #2eb85c;
        }

        *[dir="rtl"] .c-callout-success {
            border-right-color: #2eb85c;
        }

        .c-callout-success h4 {
            color: #2eb85c;
        }

        html:not([dir="rtl"]) .c-callout-info {
            border-left-color: #39f;
        }

        *[dir="rtl"] .c-callout-info {
            border-right-color: #39f;
        }

        .c-callout-info h4 {
            color: #39f;
        }

        html:not([dir="rtl"]) .c-callout-warning {
            border-left-color: #f9b115;
        }

        *[dir="rtl"] .c-callout-warning {
            border-right-color: #f9b115;
        }

        .c-callout-warning h4 {
            color: #f9b115;
        }

        html:not([dir="rtl"]) .c-callout-danger {
            border-left-color: #e55353;
        }

        *[dir="rtl"] .c-callout-danger {
            border-right-color: #e55353;
        }

        .c-callout-danger h4 {
            color: #e55353;
        }

        html:not([dir="rtl"]) .c-callout-light {
            border-left-color: #ebedef;
        }

        *[dir="rtl"] .c-callout-light {
            border-right-color: #ebedef;
        }

        .c-callout-light h4 {
            color: #ebedef;
        }

        html:not([dir="rtl"]) .c-callout-dark {
            border-left-color: #636f83;
        }

        *[dir="rtl"] .c-callout-dark {
            border-right-color: #636f83;
        }

        .c-callout-dark h4 {
            color: #636f83;
        }

        .card {
            position: relative;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: column;
            flex-direction: column;
            min-width: 0;
            margin-bottom: 1.5rem;
            word-wrap: break-word;
            background-clip: border-box;
            border: 1px solid;
            border-radius: 0.25rem;
            background-color: #fff;
            border-color: #d8dbe0;
        }

        .card > hr {
            margin-right: 0;
            margin-left: 0;
        }

        .card > .list-group {
            border-top: inherit;
            border-bottom: inherit;
        }

        .card > .list-group:first-child {
            border-top-width: 0;
            border-top-left-radius: calc(0.25rem - 1px);
            border-top-right-radius: calc(0.25rem - 1px);
        }

        .card > .list-group:last-child {
            border-bottom-width: 0;
            border-bottom-right-radius: calc(0.25rem - 1px);
            border-bottom-left-radius: calc(0.25rem - 1px);
        }

        .card.drag,
        .card .drag {
            cursor: move;
        }

        .card[class^="bg-"],
        .card[class*=" bg-"] {
            border-color: rgba(0, 0, 0, 0.125);
        }

        .card[class^="bg-"] .card-header,
        .card[class*=" bg-"] .card-header {
            background-color: rgba(0, 0, 0, 0.05);
            border-color: rgba(0, 0, 0, 0.125);
        }

        .card-body {
            -ms-flex: 1 1 auto;
            flex: 1 1 auto;
            min-height: 1px;
            padding: 1.25rem;
        }

        .card-title {
            margin-bottom: 0.75rem;
        }

        .card-subtitle {
            margin-top: -0.375rem;
        }

        .card-subtitle,.card-text:last-child {
            margin-bottom: 0;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .card-link:hover {
                text-decoration: none;
            }
        }

        html:not([dir="rtl"]) .card-link + .card-link {
            margin-left: 1.25rem;
        }

        *[dir="rtl"] .card-link + .card-link {
            margin-right: 1.25rem;
        }

        .card-header {
            padding: 0.75rem 1.25rem;
            margin-bottom: 0;
            border-bottom: 1px solid;
            background-color: #fff;
            border-color: #d8dbe0;
        }

        .card-header:first-child {
            border-radius: calc(0.25rem - 1px) calc(0.25rem - 1px) 0 0;
        }

        .card-header + .list-group .list-group-item:first-child {
            border-top: 0;
        }

        .card-header .c-chart-wrapper {
            position: absolute;
            top: 0;
            right: 0;
            width: 100%;
            height: 100%;
        }

        .card-footer {
            padding: 0.75rem 1.25rem;
            border-top: 1px solid;
            background-color: #fff;
            border-color: #d8dbe0;
        }

        .card-footer:last-child {
            border-radius: 0 0 calc(0.25rem - 1px) calc(0.25rem - 1px);
        }

        .card-header-tabs {
            margin-bottom: -0.75rem;
            border-bottom: 0;
        }

        .card-header-tabs,.card-header-pills {
            margin-right: -0.625rem;
            margin-left: -0.625rem;
        }

        .card-img-overlay {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            padding: 1.25rem;
        }

        .card-img,
        .card-img-top,
        .card-img-bottom {
            -ms-flex-negative: 0;
            flex-shrink: 0;
            width: 100%;
        }

        .card-img,
        .card-img-top {
            border-top-left-radius: calc(0.25rem - 1px);
            border-top-right-radius: calc(0.25rem - 1px);
        }

        .card-img,
        .card-img-bottom {
            border-bottom-right-radius: calc(0.25rem - 1px);
            border-bottom-left-radius: calc(0.25rem - 1px);
        }

        .card-deck .card {
            margin-bottom: 15px;
        }

        @media (min-width: 576px) {
            .card-deck {
                display: -ms-flexbox;
                display: flex;
                -ms-flex-flow: row wrap;
                flex-flow: row wrap;
                margin-right: -15px;
                margin-left: -15px;
            }
            .card-deck .card {
                -ms-flex: 1 0 0%;
                flex: 1 0 0%;
                margin-right: 15px;
                margin-bottom: 0;
                margin-left: 15px;
            }
        }

        .card-group > .card {
            margin-bottom: 15px;
        }

        @media (min-width: 576px) {
            .card-group {
                display: -ms-flexbox;
                display: flex;
                -ms-flex-flow: row wrap;
                flex-flow: row wrap;
            }
            .card-group > .card {
                -ms-flex: 1 0 0%;
                flex: 1 0 0%;
                margin-bottom: 0;
            }
            html:not([dir="rtl"]) .card-group > .card + .card {
                margin-left: 0;
                border-left: 0;
            }
            *[dir="rtl"] .card-group > .card + .card {
                margin-right: 0;
                border-right: 0;
            }
            .card-group > .card:not(:last-child) {
                border-top-right-radius: 0;
                border-bottom-right-radius: 0;
            }
            .card-group > .card:not(:last-child) .card-img-top,
            .card-group > .card:not(:last-child) .card-header {
                border-top-right-radius: 0;
            }
            .card-group > .card:not(:last-child) .card-img-bottom,
            .card-group > .card:not(:last-child) .card-footer {
                border-bottom-right-radius: 0;
            }
            .card-group > .card:not(:first-child) {
                border-top-left-radius: 0;
                border-bottom-left-radius: 0;
            }
            .card-group > .card:not(:first-child) .card-img-top,
            .card-group > .card:not(:first-child) .card-header {
                border-top-left-radius: 0;
            }
            .card-group > .card:not(:first-child) .card-img-bottom,
            .card-group > .card:not(:first-child) .card-footer {
                border-bottom-left-radius: 0;
            }
        }

        .card-columns .card {
            margin-bottom: 0.75rem;
        }

        @media (min-width: 576px) {
            .card-columns {
                -webkit-column-count: 3;
                -moz-column-count: 3;
                column-count: 3;
                -webkit-column-gap: 1.25rem;
                -moz-column-gap: 1.25rem;
                column-gap: 1.25rem;
                orphans: 1;
                widows: 1;
            }
            .card-columns .card {
                display: inline-block;
                width: 100%;
            }
        }

        .accordion > .card {
            overflow: hidden;
        }

        .accordion > .card:not(:last-of-type) {
            border-bottom: 0;
            border-bottom-right-radius: 0;
            border-bottom-left-radius: 0;
        }

        .accordion > .card:not(:first-of-type) {
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }

        .accordion > .card > .card-header {
            border-radius: 0;
            margin-bottom: -1px;
        }

        .card-placeholder {
            background: rgba(0, 0, 21, 0.025);
            border: 1px dashed #c4c9d0;
        }

        .card-header-icon-bg {
            width: 2.8125rem;
            padding: 0.75rem 0;
            margin: -0.75rem 1.25rem -0.75rem -1.25rem;
            line-height: inherit;
            color: #4f5d73;
            text-align: center;
            background: transparent;
            border-right: 1px solid;
            border-right: #d8dbe0;
        }

        .card-header-icon-bg,.card-header-actions {
            display: inline-block;
        }

        html:not([dir="rtl"]) .card-header-actions {
            float: right;
            margin-right: -0.25rem;
        }

        *[dir="rtl"] .card-header-actions {
            float: left;
            margin-left: -0.25rem;
        }

        .card-header-action {
            padding: 0 0.25rem;
            color: #8a93a2;
        }

        .card-header-action:hover {
            color: #4f5d73;
            text-decoration: none;
        }

        .card-accent-primary {
            border-top: 2px solid #321fdb !important;
        }

        .card-accent-secondary {
            border-top: 2px solid #ced2d8 !important;
        }

        .card-accent-success {
            border-top: 2px solid #2eb85c !important;
        }

        .card-accent-info {
            border-top: 2px solid #39f !important;
        }

        .card-accent-warning {
            border-top: 2px solid #f9b115 !important;
        }

        .card-accent-danger {
            border-top: 2px solid #e55353 !important;
        }

        .card-accent-light {
            border-top: 2px solid #ebedef !important;
        }

        .card-accent-dark {
            border-top: 2px solid #636f83 !important;
        }

        .card-full {
            margin-top: -1rem;
            margin-right: -15px;
            margin-left: -15px;
            border: 0;
            border-bottom: 1px solid #d8dbe0;
        }

        @media (min-width: 576px) {
            .card-columns.cols-2 {
                -webkit-column-count: 2;
                -moz-column-count: 2;
                column-count: 2;
            }
        }

        .carousel {
            position: relative;
        }

        .carousel.pointer-event {
            -ms-touch-action: pan-y;
            touch-action: pan-y;
        }

        .carousel-inner {
            position: relative;
            width: 100%;
            overflow: hidden;
        }

        .carousel-inner::after {
            display: block;
            clear: both;
            content: "";
        }

        .carousel-item {
            position: relative;
            display: none;
            float: left;
            width: 100%;
            margin-right: -100%;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            transition: -webkit-transform 0.6s ease-in-out;
            transition: transform 0.6s ease-in-out;
            transition: transform 0.6s ease-in-out, -webkit-transform 0.6s ease-in-out;
        }

        @media (prefers-reduced-motion: reduce) {
            .carousel-item {
                transition: none;
            }
        }

        .carousel-item.active,
        .carousel-item-next,
        .carousel-item-prev {
            display: block;
        }

        .carousel-item-next:not(.carousel-item-left),
        .active.carousel-item-right {
            -webkit-transform: translateX(100%);
            transform: translateX(100%);
        }

        .carousel-item-prev:not(.carousel-item-right),
        .active.carousel-item-left {
            -webkit-transform: translateX(-100%);
            transform: translateX(-100%);
        }

        .carousel-fade .carousel-item {
            opacity: 0;
            transition-property: opacity;
            -webkit-transform: none;
            transform: none;
        }

        .carousel-fade .carousel-item.active,
        .carousel-fade .carousel-item-next.carousel-item-left,
        .carousel-fade .carousel-item-prev.carousel-item-right {
            z-index: 1;
            opacity: 1;
        }

        .carousel-fade .active.carousel-item-left,
        .carousel-fade .active.carousel-item-right {
            z-index: 0;
            opacity: 0;
            transition: opacity 0s 0.6s;
        }

        @media (prefers-reduced-motion: reduce) {
            .carousel-fade .active.carousel-item-left,
            .carousel-fade .active.carousel-item-right {
                transition: none;
            }
        }

        .carousel-control-prev,
        .carousel-control-next {
            position: absolute;
            top: 0;
            bottom: 0;
            z-index: 1;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            -ms-flex-pack: center;
            justify-content: center;
            width: 15%;
            color: #fff;
            text-align: center;
            opacity: 0.5;
            transition: opacity 0.15s ease;
        }

        @media (prefers-reduced-motion: reduce) {
            .carousel-control-prev,
            .carousel-control-next {
                transition: none;
            }
        }

        .carousel-control-prev:hover, .carousel-control-prev:focus,
        .carousel-control-next:hover,
        .carousel-control-next:focus {
            color: #fff;
            text-decoration: none;
            outline: 0;
            opacity: 0.9;
        }

        .carousel-control-prev {
            left: 0;
        }

        .carousel-control-next {
            right: 0;
        }

        .carousel-control-prev-icon,
        .carousel-control-next-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            background: no-repeat 50% / 100% 100%;
        }

        .carousel-control-prev-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath d='M5.25 0l-4 4 4 4 1.5-1.5L4.25 4l2.5-2.5L5.25 0z'/%3e%3c/svg%3e");
        }

        .carousel-control-next-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='%23fff' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath d='M2.75 0l-1.5 1.5L3.75 4l-2.5 2.5L2.75 8l4-4-4-4z'/%3e%3c/svg%3e");
        }

        .carousel-indicators {
            position: absolute;
            right: 0;
            bottom: 0;
            left: 0;
            z-index: 15;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-pack: center;
            justify-content: center;
            margin-right: 15%;
            margin-left: 15%;
            list-style: none;
        }

        html:not([dir="rtl"]) .carousel-indicators {
            padding-left: 0;
        }

        *[dir="rtl"] .carousel-indicators {
            padding-right: 0;
        }

        .carousel-indicators li {
            box-sizing: content-box;
            -ms-flex: 0 1 auto;
            flex: 0 1 auto;
            width: 30px;
            height: 3px;
            margin-right: 3px;
            margin-left: 3px;
            text-indent: -999px;
            cursor: pointer;
            background-color: #fff;
            background-clip: padding-box;
            border-top: 10px solid transparent;
            border-bottom: 10px solid transparent;
            opacity: .5;
            transition: opacity 0.6s ease;
        }

        @media (prefers-reduced-motion: reduce) {
            .carousel-indicators li {
                transition: none;
            }
        }

        .carousel-indicators .active {
            opacity: 1;
        }

        .carousel-caption {
            position: absolute;
            right: 15%;
            bottom: 20px;
            left: 15%;
            z-index: 10;
            padding-top: 20px;
            padding-bottom: 20px;
            color: #fff;
            text-align: center;
        }

        .c-chart-wrapper canvas {
            width: 100%;
        }

        base-chart.chart {
            display: block;
        }

        canvas {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }

        .close {
            float: right;
            font-size: 1.3125rem;
            font-weight: 700;
            line-height: 1;
            opacity: .5;
            color: #000015;
            text-shadow: 0 1px 0 #fff;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .close:hover {
                text-decoration: none;
                color: #000015;
            }
        }

        .close:not(:disabled):not(.disabled):hover, .close:not(:disabled):not(.disabled):focus {
            opacity: .75;
        }

        button.close {
            padding: 0;
            background-color: transparent;
            border: 0;
        }

        a.close.disabled {
            pointer-events: none;
        }

        code {
            font-size: 87.5%;
            color: #e83e8c;
            word-wrap: break-word;
        }

        a > code {
            color: inherit;
        }

        kbd {
            padding: 0.2rem 0.4rem;
            font-size: 87.5%;
            color: #fff;
            background-color: #4f5d73;
            border-radius: 0.2rem;
        }

        kbd kbd {
            padding: 0;
            font-size: 100%;
            font-weight: 700;
        }

        pre code {
            font-size: inherit;
            color: inherit;
            word-break: normal;
        }

        .pre-scrollable {
            max-height: 340px;
            overflow-y: scroll;
        }

        .custom-control {
            position: relative;
            display: block;
            min-height: 1.3125rem;
        }

        html:not([dir="rtl"]) .custom-control {
            padding-left: 1.5rem;
        }

        *[dir="rtl"] .custom-control {
            padding-right: 1.5rem;
        }

        .custom-control-inline {
            display: -ms-inline-flexbox;
            display: inline-flex;
            margin-right: 1rem;
        }

        .custom-control-input {
            position: absolute;
            z-index: -1;
            width: 1rem;
            height: 1.15625rem;
            opacity: 0;
        }

        html:not([dir="rtl"]) .custom-control-input {
            left: 0;
        }

        *[dir="rtl"] .custom-control-input {
            right: 0;
        }

        .custom-control-input:checked ~ .custom-control-label::before {
            color: #fff;
            border-color: #321fdb;
            background-color: #321fdb;
        }

        .custom-control-input:focus ~ .custom-control-label::before {
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        .custom-control-input:focus:not(:checked) ~ .custom-control-label::before {
            border-color: #958bef;
        }

        .custom-control-input:not(:disabled):active ~ .custom-control-label::before {
            color: #fff;
            background-color: #beb8f5;
            border-color: #beb8f5;
        }

        .custom-control-input[disabled] ~ .custom-control-label, .custom-control-input:disabled ~ .custom-control-label {
            color: #8a93a2;
        }

        .custom-control-input[disabled] ~ .custom-control-label::before, .custom-control-input:disabled ~ .custom-control-label::before {
            background-color: #d8dbe0;
        }

        .custom-control-label {
            position: relative;
            margin-bottom: 0;
            vertical-align: top;
        }

        .custom-control-label::before {
            position: absolute;
            top: 0.15625rem;
            display: block;
            width: 1rem;
            height: 1rem;
            pointer-events: none;
            content: "";
            border: solid 1px;
            background-color: #fff;
            border-color: #9da5b1;
        }

        html:not([dir="rtl"]) .custom-control-label::before {
            left: -1.5rem;
        }

        *[dir="rtl"] .custom-control-label::before {
            right: -1.5rem;
        }

        .custom-control-label::after {
            position: absolute;
            top: 0.15625rem;
            display: block;
            width: 1rem;
            height: 1rem;
            content: "";
            background: no-repeat 50% / 50% 50%;
        }

        html:not([dir="rtl"]) .custom-control-label::after {
            left: -1.5rem;
        }

        *[dir="rtl"] .custom-control-label::after {
            right: -1.5rem;
        }

        .custom-checkbox .custom-control-label::before {
            border-radius: 0.25rem;
        }

        .custom-checkbox .custom-control-input:checked ~ .custom-control-label::after {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%23fff' d='M6.564.75l-3.59 3.612-1.538-1.55L0 4.26l2.974 2.99L8 2.193z'/%3e%3c/svg%3e");
        }

        .custom-checkbox .custom-control-input:indeterminate ~ .custom-control-label::before {
            border-color: #321fdb;
            background-color: #321fdb;
        }

        .custom-checkbox .custom-control-input:indeterminate ~ .custom-control-label::after {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='4' viewBox='0 0 4 4'%3e%3cpath stroke='%23fff' d='M0 2h4'/%3e%3c/svg%3e");
        }

        .custom-checkbox .custom-control-input:disabled:checked ~ .custom-control-label::before {
            background-color: rgba(50, 31, 219, 0.5);
        }

        .custom-checkbox .custom-control-input:disabled:indeterminate ~ .custom-control-label::before {
            background-color: rgba(50, 31, 219, 0.5);
        }

        .custom-radio .custom-control-label::before {
            border-radius: 50%;
        }

        .custom-radio .custom-control-input:checked ~ .custom-control-label::after {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='-4 -4 8 8'%3e%3ccircle r='3' fill='%23fff'/%3e%3c/svg%3e");
        }

        .custom-radio .custom-control-input:disabled:checked ~ .custom-control-label::before {
            background-color: rgba(50, 31, 219, 0.5);
        }

        html:not([dir="rtl"]) .custom-switch {
            padding-left: 2.25rem;
        }

        *[dir="rtl"] .custom-switch {
            padding-right: 2.25rem;
        }

        .custom-switch .custom-control-label::before {
            width: 1.75rem;
            pointer-events: all;
            border-radius: 0.5rem;
        }

        html:not([dir="rtl"]) .custom-switch .custom-control-label::before {
            left: -2.25rem;
        }

        *[dir="rtl"] .custom-switch .custom-control-label::before {
            right: -2.25rem;
        }

        .custom-switch .custom-control-label::after {
            top: calc(0.15625rem + 2px);
            width: calc(1rem - 4px);
            height: calc(1rem - 4px);
            background-color: #9da5b1;
            border-radius: 0.5rem;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out, -webkit-transform 0.15s ease-in-out;
            transition: transform 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            transition: transform 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out, -webkit-transform 0.15s ease-in-out;
            background-color: #9da5b1;
        }

        html:not([dir="rtl"]) .custom-switch .custom-control-label::after {
            left: calc(-2.25rem + 2px);
        }

        *[dir="rtl"] .custom-switch .custom-control-label::after {
            right: calc(-2.25rem + 2px);
        }

        @media (prefers-reduced-motion: reduce) {
            .custom-switch .custom-control-label::after {
                transition: none;
            }
        }

        .custom-switch .custom-control-input:checked ~ .custom-control-label::after {
            background-color: #fff;
            -webkit-transform: translateX(0.75rem);
            transform: translateX(0.75rem);
        }

        .custom-switch .custom-control-input:disabled:checked ~ .custom-control-label::before {
            background-color: rgba(50, 31, 219, 0.5);
        }

        .custom-select {
            display: inline-block;
            width: 100%;
            height: calc(1.5em + 0.75rem + 2px);
            padding: 0.375rem 1.75rem 0.375rem 0.75rem;
            font-size: 0.875rem;
            font-weight: 400;
            line-height: 1.5;
            vertical-align: middle;
            border: 1px solid;
            border-radius: 0.25rem;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            color: #768192;
            background: #fff url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23636f83' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right 0.75rem center/8px 10px;
            border-color: #d8dbe0;
        }

        .custom-select:focus {
            border-color: #958bef;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        .custom-select:focus::-ms-value {
            color: #768192;
            background-color: #fff;
        }

        .custom-select[multiple], .custom-select[size]:not([size="1"]) {
            height: auto;
            background-image: none;
        }

        html:not([dir="rtl"]) .custom-select[multiple], html:not([dir="rtl"]) .custom-select[size]:not([size="1"]) {
            padding-right: 0.75rem;
        }

        *[dir="rtl"] .custom-select[multiple], *[dir="rtl"] .custom-select[size]:not([size="1"]) {
            padding-left: 0.75rem;
        }

        .custom-select:disabled {
            color: #8a93a2;
            background-color: #d8dbe0;
        }

        .custom-select::-ms-expand {
            display: none;
        }

        .custom-select:-moz-focusring {
            color: transparent;
            text-shadow: 0 0 0 #768192;
        }

        .custom-select-sm {
            height: calc(1.5em + 0.5rem + 2px);
            padding-top: 0.25rem;
            padding-bottom: 0.25rem;
            font-size: 0.765625rem;
        }

        html:not([dir="rtl"]) .custom-select-sm {
            padding-left: 0.5rem;
        }

        *[dir="rtl"] .custom-select-sm {
            padding-right: 0.5rem;
        }

        .custom-select-lg {
            height: calc(1.5em + 1rem + 2px);
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
            font-size: 1.09375rem;
        }

        html:not([dir="rtl"]) .custom-select-lg {
            padding-left: 1rem;
        }

        *[dir="rtl"] .custom-select-lg {
            padding-right: 1rem;
        }

        .custom-file {
            display: inline-block;
            margin-bottom: 0;
        }

        .custom-file,.custom-file-input {
            position: relative;
            width: 100%;
            height: calc(1.5em + 0.75rem + 2px);
        }

        .custom-file-input {
            z-index: 2;
            margin: 0;
            opacity: 0;
        }

        .custom-file-input:focus ~ .custom-file-label {
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
            border-color: #958bef;
        }

        .custom-file-input[disabled] ~ .custom-file-label,
        .custom-file-input:disabled ~ .custom-file-label {
            background-color: #d8dbe0;
        }

        .custom-file-input:lang(en) ~ .custom-file-label::after {
            content: "Browse";
        }

        .custom-file-input ~ .custom-file-label[data-browse]::after {
            content: attr(data-browse);
        }

        .custom-file-label {
            right: 0;
            left: 0;
            z-index: 1;
            height: calc(1.5em + 0.75rem + 2px);
            font-weight: 400;
            border: 1px solid;
            border-radius: 0.25rem;
            background-color: #fff;
            border-color: #d8dbe0;
        }

        .custom-file-label,.custom-file-label::after {
            position: absolute;
            top: 0;
            padding: 0.375rem 0.75rem;
            line-height: 1.5;
            color: #768192;
        }

        .custom-file-label::after {
            bottom: 0;
            z-index: 3;
            display: block;
            height: calc(1.5em + 0.75rem);
            content: "Browse";
            border-left: inherit;
            border-radius: 0 0.25rem 0.25rem 0;
            background-color: #ebedef;
        }

        html:not([dir="rtl"]) .custom-file-label::after {
            right: 0;
        }

        *[dir="rtl"] .custom-file-label::after {
            left: 0;
        }

        .custom-range {
            width: 100%;
            height: 1.4rem;
            padding: 0;
            background-color: transparent;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        .custom-range:focus {
            outline: none;
        }

        .custom-range:focus::-webkit-slider-thumb {
            box-shadow: 0 0 0 1px #ebedef, 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        .custom-range:focus::-moz-range-thumb {
            box-shadow: 0 0 0 1px #ebedef, 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        .custom-range:focus::-ms-thumb {
            box-shadow: 0 0 0 1px #ebedef, 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        .custom-range::-moz-focus-outer {
            border: 0;
        }

        .custom-range::-webkit-slider-thumb {
            width: 1rem;
            height: 1rem;
            margin-top: -0.25rem;
            background-color: #321fdb;
            border: 0;
            border-radius: 1rem;
            -webkit-transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            -webkit-appearance: none;
            appearance: none;
        }

        @media (prefers-reduced-motion: reduce) {
            .custom-range::-webkit-slider-thumb {
                -webkit-transition: none;
                transition: none;
            }
        }

        .custom-range::-webkit-slider-thumb:active {
            background-color: #beb8f5;
        }

        .custom-range::-webkit-slider-runnable-track {
            width: 100%;
            height: 0.5rem;
            color: transparent;
            cursor: pointer;
            border-color: transparent;
            border-radius: 1rem;
            background-color: #c4c9d0;
        }

        .custom-range::-moz-range-thumb {
            width: 1rem;
            height: 1rem;
            background-color: #321fdb;
            border: 0;
            border-radius: 1rem;
            -moz-transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            -moz-appearance: none;
            appearance: none;
        }

        @media (prefers-reduced-motion: reduce) {
            .custom-range::-moz-range-thumb {
                -moz-transition: none;
                transition: none;
            }
        }

        .custom-range::-moz-range-thumb:active {
            background-color: #beb8f5;
        }

        .custom-range::-moz-range-track {
            width: 100%;
            height: 0.5rem;
            color: transparent;
            cursor: pointer;
            background-color: #c4c9d0;
            border-color: transparent;
            border-radius: 1rem;
        }

        .custom-range::-ms-thumb {
            width: 1rem;
            height: 1rem;
            margin-top: 0;
            margin-right: 0.2rem;
            margin-left: 0.2rem;
            background-color: #321fdb;
            border: 0;
            border-radius: 1rem;
            -ms-transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
            appearance: none;
        }

        @media (prefers-reduced-motion: reduce) {
            .custom-range::-ms-thumb {
                -ms-transition: none;
                transition: none;
            }
        }

        .custom-range::-ms-thumb:active {
            background-color: #beb8f5;
        }

        .custom-range::-ms-track {
            width: 100%;
            height: 0.5rem;
            color: transparent;
            cursor: pointer;
            background-color: transparent;
            border-color: transparent;
            border-width: 0.5rem;
        }

        .custom-range::-ms-fill-lower,.custom-range::-ms-fill-upper {
            background-color: #c4c9d0;
            border-radius: 1rem;
        }

        .custom-range::-ms-fill-upper {
            margin-right: 15px;
        }

        .custom-range:disabled::-webkit-slider-thumb {
            background-color: #9da5b1;
        }

        .custom-range:disabled::-webkit-slider-runnable-track {
            cursor: default;
        }

        .custom-range:disabled::-moz-range-thumb {
            background-color: #9da5b1;
        }

        .custom-range:disabled::-moz-range-track {
            cursor: default;
        }

        .custom-range:disabled::-ms-thumb {
            background-color: #9da5b1;
        }

        .custom-control-label::before,
        .custom-file-label,
        .custom-select {
            transition: background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        @media (prefers-reduced-motion: reduce) {
            .custom-control-label::before,
            .custom-file-label,
            .custom-select {
                transition: none;
            }
        }

        .dropup,
        .dropright,
        .dropdown,
        .dropleft {
            position: relative;
        }

        .dropdown-toggle {
            white-space: nowrap;
        }

        .dropdown-toggle::after {
            display: inline-block;
            vertical-align: 0.255em;
            content: "";
            border-top: 0.3em solid;
            border-right: 0.3em solid transparent;
            border-bottom: 0;
            border-left: 0.3em solid transparent;
        }

        html:not([dir="rtl"]) .dropdown-toggle::after {
            margin-left: 0.255em;
        }

        *[dir="rtl"] .dropdown-toggle::after {
            margin-right: 0.255em;
        }

        html:not([dir="rtl"]) .dropdown-toggle:empty::after {
            margin-left: 0;
        }

        *[dir="rtl"] .dropdown-toggle:empty::after {
            margin-right: 0;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            z-index: 1000;
            display: none;
            float: left;
            min-width: 10rem;
            padding: 0.5rem 0;
            margin: 0.125rem 0 0;
            font-size: 0.875rem;
            text-align: left;
            list-style: none;
            background-clip: padding-box;
            border: 1px solid;
            border-radius: 0.25rem;
            color: #4f5d73;
            background-color: #fff;
            border-color: #d8dbe0;
        }

        html:not([dir="rtl"]) .dropdown-menu {
            left: 0;
        }

        *[dir="rtl"] .dropdown-menu {
            right: 0;
        }

        html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-left, html:not([dir="rtl"])
        .navbar .dropdown-menu.dropdown-menu-left, html:not([dir="rtl"])
        .dropdown-menu[data-display^="static"].dropdown-menu-left {
            right: auto;
            left: 0;
        }

        *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-left, *[dir="rtl"]
        .navbar .dropdown-menu.dropdown-menu-left, *[dir="rtl"]
        .dropdown-menu[data-display^="static"].dropdown-menu-left,html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-right, html:not([dir="rtl"])
        .navbar .dropdown-menu.dropdown-menu-right, html:not([dir="rtl"])
        .dropdown-menu[data-display^="static"].dropdown-menu-right {
            right: 0;
            left: auto;
        }

        *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-right, *[dir="rtl"]
        .navbar .dropdown-menu.dropdown-menu-right, *[dir="rtl"]
        .dropdown-menu[data-display^="static"].dropdown-menu-right {
            right: auto;
            left: 0;
        }

        @media (min-width: 576px) {
            html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-sm-left, html:not([dir="rtl"])
            .navbar .dropdown-menu.dropdown-menu-sm-left, html:not([dir="rtl"])
            .dropdown-menu[data-display^="static"].dropdown-menu-sm-left {
                right: auto;
                left: 0;
            }
            *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-sm-left, *[dir="rtl"]
            .navbar .dropdown-menu.dropdown-menu-sm-left, *[dir="rtl"]
            .dropdown-menu[data-display^="static"].dropdown-menu-sm-left,html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-sm-right, html:not([dir="rtl"])
            .navbar .dropdown-menu.dropdown-menu-sm-right, html:not([dir="rtl"])
            .dropdown-menu[data-display^="static"].dropdown-menu-sm-right {
                right: 0;
                left: auto;
            }
            *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-sm-right, *[dir="rtl"]
            .navbar .dropdown-menu.dropdown-menu-sm-right, *[dir="rtl"]
            .dropdown-menu[data-display^="static"].dropdown-menu-sm-right {
                right: auto;
                left: 0;
            }
        }

        @media (min-width: 768px) {
            html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-md-left, html:not([dir="rtl"])
            .navbar .dropdown-menu.dropdown-menu-md-left, html:not([dir="rtl"])
            .dropdown-menu[data-display^="static"].dropdown-menu-md-left {
                right: auto;
                left: 0;
            }
            *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-md-left, *[dir="rtl"]
            .navbar .dropdown-menu.dropdown-menu-md-left, *[dir="rtl"]
            .dropdown-menu[data-display^="static"].dropdown-menu-md-left,html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-md-right, html:not([dir="rtl"])
            .navbar .dropdown-menu.dropdown-menu-md-right, html:not([dir="rtl"])
            .dropdown-menu[data-display^="static"].dropdown-menu-md-right {
                right: 0;
                left: auto;
            }
            *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-md-right, *[dir="rtl"]
            .navbar .dropdown-menu.dropdown-menu-md-right, *[dir="rtl"]
            .dropdown-menu[data-display^="static"].dropdown-menu-md-right {
                right: auto;
                left: 0;
            }
        }

        @media (min-width: 992px) {
            html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-lg-left, html:not([dir="rtl"])
            .navbar .dropdown-menu.dropdown-menu-lg-left, html:not([dir="rtl"])
            .dropdown-menu[data-display^="static"].dropdown-menu-lg-left {
                right: auto;
                left: 0;
            }
            *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-lg-left, *[dir="rtl"]
            .navbar .dropdown-menu.dropdown-menu-lg-left, *[dir="rtl"]
            .dropdown-menu[data-display^="static"].dropdown-menu-lg-left,html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-lg-right, html:not([dir="rtl"])
            .navbar .dropdown-menu.dropdown-menu-lg-right, html:not([dir="rtl"])
            .dropdown-menu[data-display^="static"].dropdown-menu-lg-right {
                right: 0;
                left: auto;
            }
            *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-lg-right, *[dir="rtl"]
            .navbar .dropdown-menu.dropdown-menu-lg-right, *[dir="rtl"]
            .dropdown-menu[data-display^="static"].dropdown-menu-lg-right {
                right: auto;
                left: 0;
            }
        }

        @media (min-width: 1200px) {
            html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-xl-left, html:not([dir="rtl"])
            .navbar .dropdown-menu.dropdown-menu-xl-left, html:not([dir="rtl"])
            .dropdown-menu[data-display^="static"].dropdown-menu-xl-left {
                right: auto;
                left: 0;
            }
            *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-xl-left, *[dir="rtl"]
            .navbar .dropdown-menu.dropdown-menu-xl-left, *[dir="rtl"]
            .dropdown-menu[data-display^="static"].dropdown-menu-xl-left,html:not([dir="rtl"]) .c-header .dropdown-menu.dropdown-menu-xl-right, html:not([dir="rtl"])
            .navbar .dropdown-menu.dropdown-menu-xl-right, html:not([dir="rtl"])
            .dropdown-menu[data-display^="static"].dropdown-menu-xl-right {
                right: 0;
                left: auto;
            }
            *[dir="rtl"] .c-header .dropdown-menu.dropdown-menu-xl-right, *[dir="rtl"]
            .navbar .dropdown-menu.dropdown-menu-xl-right, *[dir="rtl"]
            .dropdown-menu[data-display^="static"].dropdown-menu-xl-right {
                right: auto;
                left: 0;
            }
        }

        .dropup .dropdown-menu {
            top: auto;
            bottom: 100%;
            margin-top: 0;
            margin-bottom: 0.125rem;
        }

        .dropup .dropdown-toggle::after {
            display: inline-block;
            vertical-align: 0.255em;
            content: "";
            border-top: 0;
            border-right: 0.3em solid transparent;
            border-bottom: 0.3em solid;
            border-left: 0.3em solid transparent;
        }

        html:not([dir="rtl"]) .dropup .dropdown-toggle::after {
            margin-left: 0.255em;
        }

        *[dir="rtl"] .dropup .dropdown-toggle::after {
            margin-right: 0.255em;
        }

        html:not([dir="rtl"]) .dropup .dropdown-toggle:empty::after {
            margin-left: 0;
        }

        *[dir="rtl"] .dropup .dropdown-toggle:empty::after {
            margin-right: 0;
        }

        .dropright .dropdown-menu {
            top: 0;
            margin-top: 0;
        }

        html:not([dir="rtl"]) .dropright .dropdown-menu {
            right: auto;
            left: 100%;
            margin-left: 0.125rem;
        }

        *[dir="rtl"] .dropright .dropdown-menu {
            right: 100%;
            left: auto;
            margin-right: 0.125rem;
        }

        .dropright .dropdown-toggle::after {
            display: inline-block;
            vertical-align: 0.255em;
            content: "";
            border-top: 0.3em solid transparent;
            border-right: 0;
            border-bottom: 0.3em solid transparent;
            border-left: 0.3em solid;
            vertical-align: 0;
        }

        html:not([dir="rtl"]) .dropright .dropdown-toggle::after {
            margin-left: 0.255em;
        }

        *[dir="rtl"] .dropright .dropdown-toggle::after {
            margin-right: 0.255em;
        }

        html:not([dir="rtl"]) .dropright .dropdown-toggle:empty::after {
            margin-left: 0;
        }

        *[dir="rtl"] .dropright .dropdown-toggle:empty::after {
            margin-right: 0;
        }

        .dropleft .dropdown-menu {
            top: 0;
            margin-top: 0;
        }

        html:not([dir="rtl"]) .dropleft .dropdown-menu {
            right: 100%;
            left: auto;
            margin-right: 0.125rem;
        }

        *[dir="rtl"] .dropleft .dropdown-menu {
            right: auto;
            left: 100%;
            margin-left: 0.125rem;
        }

        .dropleft .dropdown-toggle::after {
            display: inline-block;
            vertical-align: 0.255em;
            content: "";
            display: none;
        }

        html:not([dir="rtl"]) .dropleft .dropdown-toggle::after {
            margin-left: 0.255em;
        }

        *[dir="rtl"] .dropleft .dropdown-toggle::after {
            margin-right: 0.255em;
        }

        .dropleft .dropdown-toggle::before {
            display: inline-block;
            margin-right: 0.255em;
            vertical-align: 0.255em;
            content: "";
            border-top: 0.3em solid transparent;
            border-right: 0.3em solid;
            border-bottom: 0.3em solid transparent;
            vertical-align: 0;
        }

        html:not([dir="rtl"]) .dropleft .dropdown-toggle:empty::after {
            margin-left: 0;
        }

        *[dir="rtl"] .dropleft .dropdown-toggle:empty::after {
            margin-right: 0;
        }

        .dropdown-divider {
            height: 0;
            margin: 0.5rem 0;
            overflow: hidden;
            border-top: 1px solid #d8dbe0;
        }

        .dropdown-item {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            width: 100%;
            padding: 0.5rem 1.25rem;
            clear: both;
            font-weight: 400;
            text-align: inherit;
            white-space: nowrap;
            background-color: transparent;
            border: 0;
            color: #4f5d73;
        }

        .dropdown-item:hover, .dropdown-item:focus {
            text-decoration: none;
            color: #455164;
            background-color: #ebedef;
        }

        .dropdown-item.active, .dropdown-item:active {
            text-decoration: none;
            color: #fff;
            background-color: #321fdb;
        }

        .dropdown-item.disabled, .dropdown-item:disabled {
            pointer-events: none;
            background-color: transparent;
            color: #8a93a2;
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-header {
            margin-bottom: 0;
            font-size: 0.765625rem;
            white-space: nowrap;
            color: #8a93a2;
        }

        .dropdown-header,.dropdown-item-text {
            display: block;
            padding: 0.5rem 1.25rem;
        }

        .dropdown-item-text,.c-footer {
            color: #4f5d73;
        }

        .c-footer {
            display: -ms-flexbox;
            display: flex;
            -ms-flex: 0 0 50px;
            flex: 0 0 50px;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            -ms-flex-align: center;
            align-items: center;
            height: 50px;
            padding: 0 1rem;
            background: #ebedef;
            border-top: 1px solid #d8dbe0;
        }

        .c-footer[class*="bg-"] {
            border-color: rgba(0, 0, 21, 0.1);
        }

        .c-footer.c-footer-fixed {
            position: fixed;
            right: 0;
            bottom: 0;
            left: 0;
            z-index: 1030;
        }

        .c-footer.c-footer-dark {
            color: #fff;
            background: #636f83;
        }

        .form-control {
            display: block;
            width: 100%;
            height: calc(1.5em + 0.75rem + 2px);
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            font-weight: 400;
            line-height: 1.5;
            background-clip: padding-box;
            border: 1px solid;
            color: #768192;
            background-color: #fff;
            border-color: #d8dbe0;
            border-radius: 0.25rem;
            transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
        }

        @media (prefers-reduced-motion: reduce) {
            .form-control {
                transition: none;
            }
        }

        .form-control::-ms-expand {
            background-color: transparent;
            border: 0;
        }

        .form-control:-moz-focusring {
            color: transparent;
            text-shadow: 0 0 0 #768192;
        }

        .form-control:focus {
            color: #768192;
            background-color: #fff;
            border-color: #958bef;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        .form-control::-webkit-input-placeholder {
            color: #8a93a2;
            opacity: 1;
        }

        .form-control::-moz-placeholder {
            color: #8a93a2;
            opacity: 1;
        }

        .form-control:-ms-input-placeholder {
            color: #8a93a2;
            opacity: 1;
        }

        .form-control::-ms-input-placeholder {
            color: #8a93a2;
            opacity: 1;
        }

        .form-control::placeholder {
            color: #8a93a2;
            opacity: 1;
        }

        .form-control:disabled, .form-control[readonly] {
            background-color: #d8dbe0;
            opacity: 1;
        }

        input[type="date"].form-control,
        input[type="time"].form-control,
        input[type="datetime-local"].form-control,
        input[type="month"].form-control {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }

        select.form-control:focus::-ms-value {
            color: #768192;
            background-color: #fff;
        }

        .form-control-file,
        .form-control-range {
            display: block;
            width: 100%;
        }

        .col-form-label {
            padding-top: calc(0.375rem + 1px);
            padding-bottom: calc(0.375rem + 1px);
            margin-bottom: 0;
            font-size: inherit;
            line-height: 1.5;
        }

        .col-form-label-lg {
            padding-top: calc(0.5rem + 1px);
            padding-bottom: calc(0.5rem + 1px);
            font-size: 1.09375rem;
            line-height: 1.5;
        }

        .col-form-label-sm {
            padding-top: calc(0.25rem + 1px);
            padding-bottom: calc(0.25rem + 1px);
            font-size: 0.765625rem;
            line-height: 1.5;
        }

        .form-control-plaintext {
            display: block;
            width: 100%;
            padding: 0.375rem 0;
            margin-bottom: 0;
            font-size: 0.875rem;
            line-height: 1.5;
            background-color: transparent;
            border: solid transparent;
            border-width: 1px 0;
            color: #4f5d73;
        }

        .form-control-plaintext.form-control-sm, .form-control-plaintext.form-control-lg {
            padding-right: 0;
            padding-left: 0;
        }

        .form-control-sm {
            height: calc(1.5em + 0.5rem + 2px);
            padding: 0.25rem 0.5rem;
            font-size: 0.765625rem;
            line-height: 1.5;
            border-radius: 0.2rem;
        }

        .form-control-lg {
            height: calc(1.5em + 1rem + 2px);
            padding: 0.5rem 1rem;
            font-size: 1.09375rem;
            line-height: 1.5;
            border-radius: 0.3rem;
        }

        select.form-control[size], select.form-control[multiple],textarea.form-control {
            height: auto;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-text {
            display: block;
            margin-top: 0.25rem;
        }

        .form-row {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            margin-right: -5px;
            margin-left: -5px;
        }

        .form-row > .col,
        .form-row > [class*="col-"] {
            padding-right: 5px;
            padding-left: 5px;
        }

        .form-check {
            position: relative;
            display: block;
        }

        html:not([dir="rtl"]) .form-check {
            padding-left: 1.25rem;
        }

        *[dir="rtl"] .form-check {
            padding-right: 1.25rem;
        }

        .form-check-input {
            position: absolute;
            margin-top: 0.3rem;
        }

        html:not([dir="rtl"]) .form-check-input {
            margin-left: -1.25rem;
        }

        *[dir="rtl"] .form-check-input {
            margin-right: -1.25rem;
        }

        .form-check-input[disabled] ~ .form-check-label,
        .form-check-input:disabled ~ .form-check-label {
            color: #768192;
        }

        .form-check-label {
            margin-bottom: 0;
        }

        .form-check-inline {
            display: -ms-inline-flexbox;
            display: inline-flex;
            -ms-flex-align: center;
            align-items: center;
        }

        html:not([dir="rtl"]) .form-check-inline {
            padding-left: 0;
            margin-right: 0.75rem;
        }

        *[dir="rtl"] .form-check-inline {
            padding-right: 0;
            margin-left: 0.75rem;
        }

        .form-check-inline .form-check-input {
            position: static;
            margin-top: 0;
        }

        html:not([dir="rtl"]) .form-check-inline .form-check-input {
            margin-right: 0.3125rem;
            margin-left: 0;
        }

        *[dir="rtl"] .form-check-inline .form-check-input {
            margin-right: 0;
            margin-left: 0.3125rem;
        }

        .valid-feedback {
            display: none;
            width: 100%;
            margin-top: 0.25rem;
            font-size: 80%;
            color: #2eb85c;
        }

        .valid-tooltip {
            position: absolute;
            top: 100%;
            z-index: 5;
            display: none;
            max-width: 100%;
            padding: 0.25rem 0.5rem;
            margin-top: .1rem;
            font-size: 0.765625rem;
            line-height: 1.5;
            color: #fff;
            background-color: rgba(46, 184, 92, 0.9);
            border-radius: 0.25rem;
        }

        .was-validated :valid ~ .valid-feedback,
        .was-validated :valid ~ .valid-tooltip,
        .is-valid ~ .valid-feedback,
        .is-valid ~ .valid-tooltip {
            display: block;
        }

        .was-validated .form-control:valid, .form-control.is-valid {
            border-color: #2eb85c;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%232eb85c' d='M2.3 6.73L.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1z'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-size: calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
        }

        html:not([dir="rtl"]) .was-validated .form-control:valid, html:not([dir="rtl"]) .form-control.is-valid {
            padding-right: calc(1.5em + 0.75rem);
            background-position: right calc(0.375em + 0.1875rem) center;
        }

        *[dir="rtl"] .was-validated .form-control:valid, *[dir="rtl"] .form-control.is-valid {
            padding-left: calc(1.5em + 0.75rem);
            background-position: left calc(0.375em + 0.1875rem) center;
        }

        .was-validated .form-control:valid:focus, .form-control.is-valid:focus {
            border-color: #2eb85c;
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.25);
        }

        html:not([dir="rtl"]) .was-validated textarea.form-control:valid, html:not([dir="rtl"]) textarea.form-control.is-valid {
            padding-right: calc(1.5em + 0.75rem);
            background-position: top calc(0.375em + 0.1875rem) right calc(0.375em + 0.1875rem);
        }

        *[dir="rtl"] .was-validated textarea.form-control:valid, *[dir="rtl"] textarea.form-control.is-valid {
            padding-left: calc(1.5em + 0.75rem);
            background-position: top calc(0.375em + 0.1875rem) left calc(0.375em + 0.1875rem);
        }

        .was-validated .custom-select:valid, .custom-select.is-valid {
            border-color: #2eb85c;
            background: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23636f83' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right 0.75rem center/8px 10px, url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8' viewBox='0 0 8 8'%3e%3cpath fill='%232eb85c' d='M2.3 6.73L.6 4.53c-.4-1.04.46-1.4 1.1-.8l1.1 1.4 3.4-3.8c.6-.63 1.6-.27 1.2.7l-4 4.6c-.43.5-.8.4-1.1.1z'/%3e%3c/svg%3e") #fff no-repeat center right 1.75rem/calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
        }

        html:not([dir="rtl"]) .was-validated .custom-select:valid, html:not([dir="rtl"]) .custom-select.is-valid {
            padding-right: calc(0.75em + 2.3125rem);
        }

        *[dir="rtl"] .was-validated .custom-select:valid, *[dir="rtl"] .custom-select.is-valid {
            padding-left: calc(0.75em + 2.3125rem);
        }

        .was-validated .custom-select:valid:focus, .custom-select.is-valid:focus {
            border-color: #2eb85c;
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.25);
        }

        .was-validated .form-check-input:valid ~ .form-check-label, .form-check-input.is-valid ~ .form-check-label {
            color: #2eb85c;
        }

        .was-validated .form-check-input:valid ~ .valid-feedback,
        .was-validated .form-check-input:valid ~ .valid-tooltip, .form-check-input.is-valid ~ .valid-feedback,
        .form-check-input.is-valid ~ .valid-tooltip {
            display: block;
        }

        .was-validated .custom-control-input:valid ~ .custom-control-label, .custom-control-input.is-valid ~ .custom-control-label {
            color: #2eb85c;
        }

        .was-validated .custom-control-input:valid ~ .custom-control-label::before, .custom-control-input.is-valid ~ .custom-control-label::before {
            border-color: #2eb85c;
        }

        .was-validated .custom-control-input:valid:checked ~ .custom-control-label::before, .custom-control-input.is-valid:checked ~ .custom-control-label::before {
            border-color: #48d176;
            background-color: #48d176;
        }

        .was-validated .custom-control-input:valid:focus ~ .custom-control-label::before, .custom-control-input.is-valid:focus ~ .custom-control-label::before {
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.25);
        }

        .was-validated .custom-control-input:valid:focus:not(:checked) ~ .custom-control-label::before, .custom-control-input.is-valid:focus:not(:checked) ~ .custom-control-label::before,.was-validated .custom-file-input:valid ~ .custom-file-label, .custom-file-input.is-valid ~ .custom-file-label {
            border-color: #2eb85c;
        }

        .was-validated .custom-file-input:valid:focus ~ .custom-file-label, .custom-file-input.is-valid:focus ~ .custom-file-label {
            border-color: #2eb85c;
            box-shadow: 0 0 0 0.2rem rgba(46, 184, 92, 0.25);
        }

        .invalid-feedback {
            display: none;
            width: 100%;
            margin-top: 0.25rem;
            font-size: 80%;
            color: #e55353;
        }

        .invalid-tooltip {
            position: absolute;
            top: 100%;
            z-index: 5;
            display: none;
            max-width: 100%;
            padding: 0.25rem 0.5rem;
            margin-top: .1rem;
            font-size: 0.765625rem;
            line-height: 1.5;
            color: #fff;
            background-color: rgba(229, 83, 83, 0.9);
            border-radius: 0.25rem;
        }

        .was-validated :invalid ~ .invalid-feedback,
        .was-validated :invalid ~ .invalid-tooltip,
        .is-invalid ~ .invalid-feedback,
        .is-invalid ~ .invalid-tooltip {
            display: block;
        }

        .was-validated .form-control:invalid, .form-control.is-invalid {
            border-color: #e55353;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23e55353' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23e55353' stroke='none'/%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-size: calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
        }

        html:not([dir="rtl"]) .was-validated .form-control:invalid, html:not([dir="rtl"]) .form-control.is-invalid {
            padding-right: calc(1.5em + 0.75rem);
            background-position: right calc(0.375em + 0.1875rem) center;
        }

        *[dir="rtl"] .was-validated .form-control:invalid, *[dir="rtl"] .form-control.is-invalid {
            padding-left: calc(1.5em + 0.75rem);
            background-position: left calc(0.375em + 0.1875rem) center;
        }

        .was-validated .form-control:invalid:focus, .form-control.is-invalid:focus {
            border-color: #e55353;
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.25);
        }

        html:not([dir="rtl"]) .was-validated textarea.form-control:invalid, html:not([dir="rtl"]) textarea.form-control.is-invalid {
            padding-right: calc(1.5em + 0.75rem);
            background-position: top calc(0.375em + 0.1875rem) right calc(0.375em + 0.1875rem);
        }

        *[dir="rtl"] .was-validated textarea.form-control:invalid, *[dir="rtl"] textarea.form-control.is-invalid {
            padding-left: calc(1.5em + 0.75rem);
            background-position: top calc(0.375em + 0.1875rem) left calc(0.375em + 0.1875rem);
        }

        .was-validated .custom-select:invalid, .custom-select.is-invalid {
            border-color: #e55353;
            background: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='4' height='5' viewBox='0 0 4 5'%3e%3cpath fill='%23636f83' d='M2 0L0 2h4zm0 5L0 3h4z'/%3e%3c/svg%3e") no-repeat right 0.75rem center/8px 10px, url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='none' stroke='%23e55353' viewBox='0 0 12 12'%3e%3ccircle cx='6' cy='6' r='4.5'/%3e%3cpath stroke-linejoin='round' d='M5.8 3.6h.4L6 6.5z'/%3e%3ccircle cx='6' cy='8.2' r='.6' fill='%23e55353' stroke='none'/%3e%3c/svg%3e") #fff no-repeat center right 1.75rem/calc(0.75em + 0.375rem) calc(0.75em + 0.375rem);
        }

        html:not([dir="rtl"]) .was-validated .custom-select:invalid, html:not([dir="rtl"]) .custom-select.is-invalid {
            padding-right: calc(0.75em + 2.3125rem);
        }

        *[dir="rtl"] .was-validated .custom-select:invalid, *[dir="rtl"] .custom-select.is-invalid {
            padding-left: calc(0.75em + 2.3125rem);
        }

        .was-validated .custom-select:invalid:focus, .custom-select.is-invalid:focus {
            border-color: #e55353;
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.25);
        }

        .was-validated .form-check-input:invalid ~ .form-check-label, .form-check-input.is-invalid ~ .form-check-label {
            color: #e55353;
        }

        .was-validated .form-check-input:invalid ~ .invalid-feedback,
        .was-validated .form-check-input:invalid ~ .invalid-tooltip, .form-check-input.is-invalid ~ .invalid-feedback,
        .form-check-input.is-invalid ~ .invalid-tooltip {
            display: block;
        }

        .was-validated .custom-control-input:invalid ~ .custom-control-label, .custom-control-input.is-invalid ~ .custom-control-label {
            color: #e55353;
        }

        .was-validated .custom-control-input:invalid ~ .custom-control-label::before, .custom-control-input.is-invalid ~ .custom-control-label::before {
            border-color: #e55353;
        }

        .was-validated .custom-control-input:invalid:checked ~ .custom-control-label::before, .custom-control-input.is-invalid:checked ~ .custom-control-label::before {
            border-color: #ec7f7f;
            background-color: #ec7f7f;
        }

        .was-validated .custom-control-input:invalid:focus ~ .custom-control-label::before, .custom-control-input.is-invalid:focus ~ .custom-control-label::before {
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.25);
        }

        .was-validated .custom-control-input:invalid:focus:not(:checked) ~ .custom-control-label::before, .custom-control-input.is-invalid:focus:not(:checked) ~ .custom-control-label::before,.was-validated .custom-file-input:invalid ~ .custom-file-label, .custom-file-input.is-invalid ~ .custom-file-label {
            border-color: #e55353;
        }

        .was-validated .custom-file-input:invalid:focus ~ .custom-file-label, .custom-file-input.is-invalid:focus ~ .custom-file-label {
            border-color: #e55353;
            box-shadow: 0 0 0 0.2rem rgba(229, 83, 83, 0.25);
        }

        .form-inline {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-flow: row wrap;
            flex-flow: row wrap;
            -ms-flex-align: center;
            align-items: center;
        }

        .form-inline .form-check {
            width: 100%;
        }

        @media (min-width: 576px) {
            .form-inline label {
                -ms-flex-align: center;
                -ms-flex-pack: center;
                justify-content: center;
            }
            .form-inline label,.form-inline .form-group {
                display: -ms-flexbox;
                display: flex;
                align-items: center;
                margin-bottom: 0;
            }
            .form-inline .form-group {
                -ms-flex: 0 0 auto;
                flex: 0 0 auto;
                -ms-flex-flow: row wrap;
                flex-flow: row wrap;
                -ms-flex-align: center;
            }
            .form-inline .form-control {
                display: inline-block;
                width: auto;
                vertical-align: middle;
            }
            .form-inline .form-control-plaintext {
                display: inline-block;
            }
            .form-inline .input-group,
            .form-inline .custom-select {
                width: auto;
            }
            .form-inline .form-check {
                display: -ms-flexbox;
                display: flex;
                -ms-flex-align: center;
                align-items: center;
                -ms-flex-pack: center;
                justify-content: center;
                width: auto;
            }
            html:not([dir="rtl"]) .form-inline .form-check {
                padding-left: 0;
            }
            *[dir="rtl"] .form-inline .form-check {
                padding-right: 0;
            }
            .form-inline .form-check-input {
                position: relative;
                -ms-flex-negative: 0;
                flex-shrink: 0;
                margin-top: 0;
            }
            html:not([dir="rtl"]) .form-inline .form-check-input {
                margin-right: 0.25rem;
                margin-left: 0;
            }
            *[dir="rtl"] .form-inline .form-check-input {
                margin-right: 0;
                margin-left: 0.25rem;
            }
            .form-inline .custom-control {
                -ms-flex-align: center;
                align-items: center;
                -ms-flex-pack: center;
                justify-content: center;
            }
            .form-inline .custom-control-label {
                margin-bottom: 0;
            }
        }

        .container {
            width: 100%;
            padding-right: 15px;
            padding-left: 15px;
            margin-right: auto;
            margin-left: auto;
        }

        @media (min-width: 576px) {
            .container {
                max-width: 540px;
            }
        }

        @media (min-width: 768px) {
            .container {
                max-width: 720px;
            }
        }

        @media (min-width: 992px) {
            .container {
                max-width: 960px;
            }
        }

        @media (min-width: 1200px) {
            .container {
                max-width: 1140px;
            }
        }

        .container-fluid, .container-sm, .container-md, .container-lg, .container-xl {
            width: 100%;
            padding-right: 15px;
            padding-left: 15px;
            margin-right: auto;
            margin-left: auto;
        }

        @media (min-width: 576px) {
            .container, .container-sm {
                max-width: 540px;
            }
        }

        @media (min-width: 768px) {
            .container, .container-sm, .container-md {
                max-width: 720px;
            }
        }

        @media (min-width: 992px) {
            .container, .container-sm, .container-md, .container-lg {
                max-width: 960px;
            }
        }

        @media (min-width: 1200px) {
            .container, .container-sm, .container-md, .container-lg, .container-xl {
                max-width: 1140px;
            }
        }

        .row {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            margin-right: -15px;
            margin-left: -15px;
        }

        .no-gutters {
            margin-right: 0;
            margin-left: 0;
        }

        .no-gutters > .col,
        .no-gutters > [class*="col-"] {
            padding-right: 0;
            padding-left: 0;
        }

        .col-1, .col-2, .col-3, .col-4, .col-5, .col-6, .col-7, .col-8, .col-9, .col-10, .col-11, .col-12, .col,
        .col-auto, .col-sm-1, .col-sm-2, .col-sm-3, .col-sm-4, .col-sm-5, .col-sm-6, .col-sm-7, .col-sm-8, .col-sm-9, .col-sm-10, .col-sm-11, .col-sm-12, .col-sm,
        .col-sm-auto, .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12, .col-md,
        .col-md-auto, .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12, .col-lg,
        .col-lg-auto, .col-xl-1, .col-xl-2, .col-xl-3, .col-xl-4, .col-xl-5, .col-xl-6, .col-xl-7, .col-xl-8, .col-xl-9, .col-xl-10, .col-xl-11, .col-xl-12, .col-xl,
        .col-xl-auto {
            position: relative;
            width: 100%;
            padding-right: 15px;
            padding-left: 15px;
        }

        .col {
            -ms-flex-preferred-size: 0;
            flex-basis: 0;
            -ms-flex-positive: 1;
            flex-grow: 1;
            min-width: 0;
            max-width: 100%;
        }

        .row-cols-1 > * {
            -ms-flex: 0 0 100%;
            flex: 0 0 100%;
            max-width: 100%;
        }

        .row-cols-2 > * {
            -ms-flex: 0 0 50%;
            flex: 0 0 50%;
            max-width: 50%;
        }

        .row-cols-3 > * {
            -ms-flex: 0 0 33.33333333%;
            flex: 0 0 33.33333333%;
            max-width: 33.33333333%;
        }

        .row-cols-4 > * {
            -ms-flex: 0 0 25%;
            flex: 0 0 25%;
            max-width: 25%;
        }

        .row-cols-5 > * {
            -ms-flex: 0 0 20%;
            flex: 0 0 20%;
            max-width: 20%;
        }

        .row-cols-6 > * {
            -ms-flex: 0 0 16.66666667%;
            flex: 0 0 16.66666667%;
            max-width: 16.66666667%;
        }

        .col-auto {
            -ms-flex: 0 0 auto;
            flex: 0 0 auto;
            width: auto;
            max-width: 100%;
        }

        .col-1 {
            -ms-flex: 0 0 8.33333333%;
            flex: 0 0 8.33333333%;
            max-width: 8.33333333%;
        }

        .col-2 {
            -ms-flex: 0 0 16.66666667%;
            flex: 0 0 16.66666667%;
            max-width: 16.66666667%;
        }

        .col-3 {
            -ms-flex: 0 0 25%;
            flex: 0 0 25%;
            max-width: 25%;
        }

        .col-4 {
            -ms-flex: 0 0 33.33333333%;
            flex: 0 0 33.33333333%;
            max-width: 33.33333333%;
        }

        .col-5 {
            -ms-flex: 0 0 41.66666667%;
            flex: 0 0 41.66666667%;
            max-width: 41.66666667%;
        }

        .col-6 {
            -ms-flex: 0 0 50%;
            flex: 0 0 50%;
            max-width: 50%;
        }

        .col-7 {
            -ms-flex: 0 0 58.33333333%;
            flex: 0 0 58.33333333%;
            max-width: 58.33333333%;
        }

        .col-8 {
            -ms-flex: 0 0 66.66666667%;
            flex: 0 0 66.66666667%;
            max-width: 66.66666667%;
        }

        .col-9 {
            -ms-flex: 0 0 75%;
            flex: 0 0 75%;
            max-width: 75%;
        }

        .col-10 {
            -ms-flex: 0 0 83.33333333%;
            flex: 0 0 83.33333333%;
            max-width: 83.33333333%;
        }

        .col-11 {
            -ms-flex: 0 0 91.66666667%;
            flex: 0 0 91.66666667%;
            max-width: 91.66666667%;
        }

        .col-12 {
            -ms-flex: 0 0 100%;
            flex: 0 0 100%;
            max-width: 100%;
        }

        .order-first {
            -ms-flex-order: -1;
            order: -1;
        }

        .order-last {
            -ms-flex-order: 13;
            order: 13;
        }

        .order-0 {
            -ms-flex-order: 0;
            order: 0;
        }

        .order-1 {
            -ms-flex-order: 1;
            order: 1;
        }

        .order-2 {
            -ms-flex-order: 2;
            order: 2;
        }

        .order-3 {
            -ms-flex-order: 3;
            order: 3;
        }

        .order-4 {
            -ms-flex-order: 4;
            order: 4;
        }

        .order-5 {
            -ms-flex-order: 5;
            order: 5;
        }

        .order-6 {
            -ms-flex-order: 6;
            order: 6;
        }

        .order-7 {
            -ms-flex-order: 7;
            order: 7;
        }

        .order-8 {
            -ms-flex-order: 8;
            order: 8;
        }

        .order-9 {
            -ms-flex-order: 9;
            order: 9;
        }

        .order-10 {
            -ms-flex-order: 10;
            order: 10;
        }

        .order-11 {
            -ms-flex-order: 11;
            order: 11;
        }

        .order-12 {
            -ms-flex-order: 12;
            order: 12;
        }

        .offset-1 {
            margin-left: 8.33333333%;
        }

        .offset-2 {
            margin-left: 16.66666667%;
        }

        .offset-3 {
            margin-left: 25%;
        }

        .offset-4 {
            margin-left: 33.33333333%;
        }

        .offset-5 {
            margin-left: 41.66666667%;
        }

        .offset-6 {
            margin-left: 50%;
        }

        .offset-7 {
            margin-left: 58.33333333%;
        }

        .offset-8 {
            margin-left: 66.66666667%;
        }

        .offset-9 {
            margin-left: 75%;
        }

        .offset-10 {
            margin-left: 83.33333333%;
        }

        .offset-11 {
            margin-left: 91.66666667%;
        }

        @media (min-width: 576px) {
            .col-sm {
                -ms-flex-preferred-size: 0;
                flex-basis: 0;
                -ms-flex-positive: 1;
                flex-grow: 1;
                min-width: 0;
                max-width: 100%;
            }
            .row-cols-sm-1 > * {
                -ms-flex: 0 0 100%;
                flex: 0 0 100%;
                max-width: 100%;
            }
            .row-cols-sm-2 > * {
                -ms-flex: 0 0 50%;
                flex: 0 0 50%;
                max-width: 50%;
            }
            .row-cols-sm-3 > * {
                -ms-flex: 0 0 33.33333333%;
                flex: 0 0 33.33333333%;
                max-width: 33.33333333%;
            }
            .row-cols-sm-4 > * {
                -ms-flex: 0 0 25%;
                flex: 0 0 25%;
                max-width: 25%;
            }
            .row-cols-sm-5 > * {
                -ms-flex: 0 0 20%;
                flex: 0 0 20%;
                max-width: 20%;
            }
            .row-cols-sm-6 > * {
                -ms-flex: 0 0 16.66666667%;
                flex: 0 0 16.66666667%;
                max-width: 16.66666667%;
            }
            .col-sm-auto {
                -ms-flex: 0 0 auto;
                flex: 0 0 auto;
                width: auto;
                max-width: 100%;
            }
            .col-sm-1 {
                -ms-flex: 0 0 8.33333333%;
                flex: 0 0 8.33333333%;
                max-width: 8.33333333%;
            }
            .col-sm-2 {
                -ms-flex: 0 0 16.66666667%;
                flex: 0 0 16.66666667%;
                max-width: 16.66666667%;
            }
            .col-sm-3 {
                -ms-flex: 0 0 25%;
                flex: 0 0 25%;
                max-width: 25%;
            }
            .col-sm-4 {
                -ms-flex: 0 0 33.33333333%;
                flex: 0 0 33.33333333%;
                max-width: 33.33333333%;
            }
            .col-sm-5 {
                -ms-flex: 0 0 41.66666667%;
                flex: 0 0 41.66666667%;
                max-width: 41.66666667%;
            }
            .col-sm-6 {
                -ms-flex: 0 0 50%;
                flex: 0 0 50%;
                max-width: 50%;
            }
            .col-sm-7 {
                -ms-flex: 0 0 58.33333333%;
                flex: 0 0 58.33333333%;
                max-width: 58.33333333%;
            }
            .col-sm-8 {
                -ms-flex: 0 0 66.66666667%;
                flex: 0 0 66.66666667%;
                max-width: 66.66666667%;
            }
            .col-sm-9 {
                -ms-flex: 0 0 75%;
                flex: 0 0 75%;
                max-width: 75%;
            }
            .col-sm-10 {
                -ms-flex: 0 0 83.33333333%;
                flex: 0 0 83.33333333%;
                max-width: 83.33333333%;
            }
            .col-sm-11 {
                -ms-flex: 0 0 91.66666667%;
                flex: 0 0 91.66666667%;
                max-width: 91.66666667%;
            }
            .col-sm-12 {
                -ms-flex: 0 0 100%;
                flex: 0 0 100%;
                max-width: 100%;
            }
            .order-sm-first {
                -ms-flex-order: -1;
                order: -1;
            }
            .order-sm-last {
                -ms-flex-order: 13;
                order: 13;
            }
            .order-sm-0 {
                -ms-flex-order: 0;
                order: 0;
            }
            .order-sm-1 {
                -ms-flex-order: 1;
                order: 1;
            }
            .order-sm-2 {
                -ms-flex-order: 2;
                order: 2;
            }
            .order-sm-3 {
                -ms-flex-order: 3;
                order: 3;
            }
            .order-sm-4 {
                -ms-flex-order: 4;
                order: 4;
            }
            .order-sm-5 {
                -ms-flex-order: 5;
                order: 5;
            }
            .order-sm-6 {
                -ms-flex-order: 6;
                order: 6;
            }
            .order-sm-7 {
                -ms-flex-order: 7;
                order: 7;
            }
            .order-sm-8 {
                -ms-flex-order: 8;
                order: 8;
            }
            .order-sm-9 {
                -ms-flex-order: 9;
                order: 9;
            }
            .order-sm-10 {
                -ms-flex-order: 10;
                order: 10;
            }
            .order-sm-11 {
                -ms-flex-order: 11;
                order: 11;
            }
            .order-sm-12 {
                -ms-flex-order: 12;
                order: 12;
            }
            .offset-sm-0 {
                margin-left: 0;
            }
            .offset-sm-1 {
                margin-left: 8.33333333%;
            }
            .offset-sm-2 {
                margin-left: 16.66666667%;
            }
            .offset-sm-3 {
                margin-left: 25%;
            }
            .offset-sm-4 {
                margin-left: 33.33333333%;
            }
            .offset-sm-5 {
                margin-left: 41.66666667%;
            }
            .offset-sm-6 {
                margin-left: 50%;
            }
            .offset-sm-7 {
                margin-left: 58.33333333%;
            }
            .offset-sm-8 {
                margin-left: 66.66666667%;
            }
            .offset-sm-9 {
                margin-left: 75%;
            }
            .offset-sm-10 {
                margin-left: 83.33333333%;
            }
            .offset-sm-11 {
                margin-left: 91.66666667%;
            }
        }

        @media (min-width: 768px) {
            .col-md {
                -ms-flex-preferred-size: 0;
                flex-basis: 0;
                -ms-flex-positive: 1;
                flex-grow: 1;
                min-width: 0;
                max-width: 100%;
            }
            .row-cols-md-1 > * {
                -ms-flex: 0 0 100%;
                flex: 0 0 100%;
                max-width: 100%;
            }
            .row-cols-md-2 > * {
                -ms-flex: 0 0 50%;
                flex: 0 0 50%;
                max-width: 50%;
            }
            .row-cols-md-3 > * {
                -ms-flex: 0 0 33.33333333%;
                flex: 0 0 33.33333333%;
                max-width: 33.33333333%;
            }
            .row-cols-md-4 > * {
                -ms-flex: 0 0 25%;
                flex: 0 0 25%;
                max-width: 25%;
            }
            .row-cols-md-5 > * {
                -ms-flex: 0 0 20%;
                flex: 0 0 20%;
                max-width: 20%;
            }
            .row-cols-md-6 > * {
                -ms-flex: 0 0 16.66666667%;
                flex: 0 0 16.66666667%;
                max-width: 16.66666667%;
            }
            .col-md-auto {
                -ms-flex: 0 0 auto;
                flex: 0 0 auto;
                width: auto;
                max-width: 100%;
            }
            .col-md-1 {
                -ms-flex: 0 0 8.33333333%;
                flex: 0 0 8.33333333%;
                max-width: 8.33333333%;
            }
            .col-md-2 {
                -ms-flex: 0 0 16.66666667%;
                flex: 0 0 16.66666667%;
                max-width: 16.66666667%;
            }
            .col-md-3 {
                -ms-flex: 0 0 25%;
                flex: 0 0 25%;
                max-width: 25%;
            }
            .col-md-4 {
                -ms-flex: 0 0 33.33333333%;
                flex: 0 0 33.33333333%;
                max-width: 33.33333333%;
            }
            .col-md-5 {
                -ms-flex: 0 0 41.66666667%;
                flex: 0 0 41.66666667%;
                max-width: 41.66666667%;
            }
            .col-md-6 {
                -ms-flex: 0 0 50%;
                flex: 0 0 50%;
                max-width: 50%;
            }
            .col-md-7 {
                -ms-flex: 0 0 58.33333333%;
                flex: 0 0 58.33333333%;
                max-width: 58.33333333%;
            }
            .col-md-8 {
                -ms-flex: 0 0 66.66666667%;
                flex: 0 0 66.66666667%;
                max-width: 66.66666667%;
            }
            .col-md-9 {
                -ms-flex: 0 0 75%;
                flex: 0 0 75%;
                max-width: 75%;
            }
            .col-md-10 {
                -ms-flex: 0 0 83.33333333%;
                flex: 0 0 83.33333333%;
                max-width: 83.33333333%;
            }
            .col-md-11 {
                -ms-flex: 0 0 91.66666667%;
                flex: 0 0 91.66666667%;
                max-width: 91.66666667%;
            }
            .col-md-12 {
                -ms-flex: 0 0 100%;
                flex: 0 0 100%;
                max-width: 100%;
            }
            .order-md-first {
                -ms-flex-order: -1;
                order: -1;
            }
            .order-md-last {
                -ms-flex-order: 13;
                order: 13;
            }
            .order-md-0 {
                -ms-flex-order: 0;
                order: 0;
            }
            .order-md-1 {
                -ms-flex-order: 1;
                order: 1;
            }
            .order-md-2 {
                -ms-flex-order: 2;
                order: 2;
            }
            .order-md-3 {
                -ms-flex-order: 3;
                order: 3;
            }
            .order-md-4 {
                -ms-flex-order: 4;
                order: 4;
            }
            .order-md-5 {
                -ms-flex-order: 5;
                order: 5;
            }
            .order-md-6 {
                -ms-flex-order: 6;
                order: 6;
            }
            .order-md-7 {
                -ms-flex-order: 7;
                order: 7;
            }
            .order-md-8 {
                -ms-flex-order: 8;
                order: 8;
            }
            .order-md-9 {
                -ms-flex-order: 9;
                order: 9;
            }
            .order-md-10 {
                -ms-flex-order: 10;
                order: 10;
            }
            .order-md-11 {
                -ms-flex-order: 11;
                order: 11;
            }
            .order-md-12 {
                -ms-flex-order: 12;
                order: 12;
            }
            .offset-md-0 {
                margin-left: 0;
            }
            .offset-md-1 {
                margin-left: 8.33333333%;
            }
            .offset-md-2 {
                margin-left: 16.66666667%;
            }
            .offset-md-3 {
                margin-left: 25%;
            }
            .offset-md-4 {
                margin-left: 33.33333333%;
            }
            .offset-md-5 {
                margin-left: 41.66666667%;
            }
            .offset-md-6 {
                margin-left: 50%;
            }
            .offset-md-7 {
                margin-left: 58.33333333%;
            }
            .offset-md-8 {
                margin-left: 66.66666667%;
            }
            .offset-md-9 {
                margin-left: 75%;
            }
            .offset-md-10 {
                margin-left: 83.33333333%;
            }
            .offset-md-11 {
                margin-left: 91.66666667%;
            }
        }

        @media (min-width: 992px) {
            .col-lg {
                -ms-flex-preferred-size: 0;
                flex-basis: 0;
                -ms-flex-positive: 1;
                flex-grow: 1;
                min-width: 0;
                max-width: 100%;
            }
            .row-cols-lg-1 > * {
                -ms-flex: 0 0 100%;
                flex: 0 0 100%;
                max-width: 100%;
            }
            .row-cols-lg-2 > * {
                -ms-flex: 0 0 50%;
                flex: 0 0 50%;
                max-width: 50%;
            }
            .row-cols-lg-3 > * {
                -ms-flex: 0 0 33.33333333%;
                flex: 0 0 33.33333333%;
                max-width: 33.33333333%;
            }
            .row-cols-lg-4 > * {
                -ms-flex: 0 0 25%;
                flex: 0 0 25%;
                max-width: 25%;
            }
            .row-cols-lg-5 > * {
                -ms-flex: 0 0 20%;
                flex: 0 0 20%;
                max-width: 20%;
            }
            .row-cols-lg-6 > * {
                -ms-flex: 0 0 16.66666667%;
                flex: 0 0 16.66666667%;
                max-width: 16.66666667%;
            }
            .col-lg-auto {
                -ms-flex: 0 0 auto;
                flex: 0 0 auto;
                width: auto;
                max-width: 100%;
            }
            .col-lg-1 {
                -ms-flex: 0 0 8.33333333%;
                flex: 0 0 8.33333333%;
                max-width: 8.33333333%;
            }
            .col-lg-2 {
                -ms-flex: 0 0 16.66666667%;
                flex: 0 0 16.66666667%;
                max-width: 16.66666667%;
            }
            .col-lg-3 {
                -ms-flex: 0 0 25%;
                flex: 0 0 25%;
                max-width: 25%;
            }
            .col-lg-4 {
                -ms-flex: 0 0 33.33333333%;
                flex: 0 0 33.33333333%;
                max-width: 33.33333333%;
            }
            .col-lg-5 {
                -ms-flex: 0 0 41.66666667%;
                flex: 0 0 41.66666667%;
                max-width: 41.66666667%;
            }
            .col-lg-6 {
                -ms-flex: 0 0 50%;
                flex: 0 0 50%;
                max-width: 50%;
            }
            .col-lg-7 {
                -ms-flex: 0 0 58.33333333%;
                flex: 0 0 58.33333333%;
                max-width: 58.33333333%;
            }
            .col-lg-8 {
                -ms-flex: 0 0 66.66666667%;
                flex: 0 0 66.66666667%;
                max-width: 66.66666667%;
            }
            .col-lg-9 {
                -ms-flex: 0 0 75%;
                flex: 0 0 75%;
                max-width: 75%;
            }
            .col-lg-10 {
                -ms-flex: 0 0 83.33333333%;
                flex: 0 0 83.33333333%;
                max-width: 83.33333333%;
            }
            .col-lg-11 {
                -ms-flex: 0 0 91.66666667%;
                flex: 0 0 91.66666667%;
                max-width: 91.66666667%;
            }
            .col-lg-12 {
                -ms-flex: 0 0 100%;
                flex: 0 0 100%;
                max-width: 100%;
            }
            .order-lg-first {
                -ms-flex-order: -1;
                order: -1;
            }
            .order-lg-last {
                -ms-flex-order: 13;
                order: 13;
            }
            .order-lg-0 {
                -ms-flex-order: 0;
                order: 0;
            }
            .order-lg-1 {
                -ms-flex-order: 1;
                order: 1;
            }
            .order-lg-2 {
                -ms-flex-order: 2;
                order: 2;
            }
            .order-lg-3 {
                -ms-flex-order: 3;
                order: 3;
            }
            .order-lg-4 {
                -ms-flex-order: 4;
                order: 4;
            }
            .order-lg-5 {
                -ms-flex-order: 5;
                order: 5;
            }
            .order-lg-6 {
                -ms-flex-order: 6;
                order: 6;
            }
            .order-lg-7 {
                -ms-flex-order: 7;
                order: 7;
            }
            .order-lg-8 {
                -ms-flex-order: 8;
                order: 8;
            }
            .order-lg-9 {
                -ms-flex-order: 9;
                order: 9;
            }
            .order-lg-10 {
                -ms-flex-order: 10;
                order: 10;
            }
            .order-lg-11 {
                -ms-flex-order: 11;
                order: 11;
            }
            .order-lg-12 {
                -ms-flex-order: 12;
                order: 12;
            }
            .offset-lg-0 {
                margin-left: 0;
            }
            .offset-lg-1 {
                margin-left: 8.33333333%;
            }
            .offset-lg-2 {
                margin-left: 16.66666667%;
            }
            .offset-lg-3 {
                margin-left: 25%;
            }
            .offset-lg-4 {
                margin-left: 33.33333333%;
            }
            .offset-lg-5 {
                margin-left: 41.66666667%;
            }
            .offset-lg-6 {
                margin-left: 50%;
            }
            .offset-lg-7 {
                margin-left: 58.33333333%;
            }
            .offset-lg-8 {
                margin-left: 66.66666667%;
            }
            .offset-lg-9 {
                margin-left: 75%;
            }
            .offset-lg-10 {
                margin-left: 83.33333333%;
            }
            .offset-lg-11 {
                margin-left: 91.66666667%;
            }
        }

        @media (min-width: 1200px) {
            .col-xl {
                -ms-flex-preferred-size: 0;
                flex-basis: 0;
                -ms-flex-positive: 1;
                flex-grow: 1;
                min-width: 0;
                max-width: 100%;
            }
            .row-cols-xl-1 > * {
                -ms-flex: 0 0 100%;
                flex: 0 0 100%;
                max-width: 100%;
            }
            .row-cols-xl-2 > * {
                -ms-flex: 0 0 50%;
                flex: 0 0 50%;
                max-width: 50%;
            }
            .row-cols-xl-3 > * {
                -ms-flex: 0 0 33.33333333%;
                flex: 0 0 33.33333333%;
                max-width: 33.33333333%;
            }
            .row-cols-xl-4 > * {
                -ms-flex: 0 0 25%;
                flex: 0 0 25%;
                max-width: 25%;
            }
            .row-cols-xl-5 > * {
                -ms-flex: 0 0 20%;
                flex: 0 0 20%;
                max-width: 20%;
            }
            .row-cols-xl-6 > * {
                -ms-flex: 0 0 16.66666667%;
                flex: 0 0 16.66666667%;
                max-width: 16.66666667%;
            }
            .col-xl-auto {
                -ms-flex: 0 0 auto;
                flex: 0 0 auto;
                width: auto;
                max-width: 100%;
            }
            .col-xl-1 {
                -ms-flex: 0 0 8.33333333%;
                flex: 0 0 8.33333333%;
                max-width: 8.33333333%;
            }
            .col-xl-2 {
                -ms-flex: 0 0 16.66666667%;
                flex: 0 0 16.66666667%;
                max-width: 16.66666667%;
            }
            .col-xl-3 {
                -ms-flex: 0 0 25%;
                flex: 0 0 25%;
                max-width: 25%;
            }
            .col-xl-4 {
                -ms-flex: 0 0 33.33333333%;
                flex: 0 0 33.33333333%;
                max-width: 33.33333333%;
            }
            .col-xl-5 {
                -ms-flex: 0 0 41.66666667%;
                flex: 0 0 41.66666667%;
                max-width: 41.66666667%;
            }
            .col-xl-6 {
                -ms-flex: 0 0 50%;
                flex: 0 0 50%;
                max-width: 50%;
            }
            .col-xl-7 {
                -ms-flex: 0 0 58.33333333%;
                flex: 0 0 58.33333333%;
                max-width: 58.33333333%;
            }
            .col-xl-8 {
                -ms-flex: 0 0 66.66666667%;
                flex: 0 0 66.66666667%;
                max-width: 66.66666667%;
            }
            .col-xl-9 {
                -ms-flex: 0 0 75%;
                flex: 0 0 75%;
                max-width: 75%;
            }
            .col-xl-10 {
                -ms-flex: 0 0 83.33333333%;
                flex: 0 0 83.33333333%;
                max-width: 83.33333333%;
            }
            .col-xl-11 {
                -ms-flex: 0 0 91.66666667%;
                flex: 0 0 91.66666667%;
                max-width: 91.66666667%;
            }
            .col-xl-12 {
                -ms-flex: 0 0 100%;
                flex: 0 0 100%;
                max-width: 100%;
            }
            .order-xl-first {
                -ms-flex-order: -1;
                order: -1;
            }
            .order-xl-last {
                -ms-flex-order: 13;
                order: 13;
            }
            .order-xl-0 {
                -ms-flex-order: 0;
                order: 0;
            }
            .order-xl-1 {
                -ms-flex-order: 1;
                order: 1;
            }
            .order-xl-2 {
                -ms-flex-order: 2;
                order: 2;
            }
            .order-xl-3 {
                -ms-flex-order: 3;
                order: 3;
            }
            .order-xl-4 {
                -ms-flex-order: 4;
                order: 4;
            }
            .order-xl-5 {
                -ms-flex-order: 5;
                order: 5;
            }
            .order-xl-6 {
                -ms-flex-order: 6;
                order: 6;
            }
            .order-xl-7 {
                -ms-flex-order: 7;
                order: 7;
            }
            .order-xl-8 {
                -ms-flex-order: 8;
                order: 8;
            }
            .order-xl-9 {
                -ms-flex-order: 9;
                order: 9;
            }
            .order-xl-10 {
                -ms-flex-order: 10;
                order: 10;
            }
            .order-xl-11 {
                -ms-flex-order: 11;
                order: 11;
            }
            .order-xl-12 {
                -ms-flex-order: 12;
                order: 12;
            }
            .offset-xl-0 {
                margin-left: 0;
            }
            .offset-xl-1 {
                margin-left: 8.33333333%;
            }
            .offset-xl-2 {
                margin-left: 16.66666667%;
            }
            .offset-xl-3 {
                margin-left: 25%;
            }
            .offset-xl-4 {
                margin-left: 33.33333333%;
            }
            .offset-xl-5 {
                margin-left: 41.66666667%;
            }
            .offset-xl-6 {
                margin-left: 50%;
            }
            .offset-xl-7 {
                margin-left: 58.33333333%;
            }
            .offset-xl-8 {
                margin-left: 66.66666667%;
            }
            .offset-xl-9 {
                margin-left: 75%;
            }
            .offset-xl-10 {
                margin-left: 83.33333333%;
            }
            .offset-xl-11 {
                margin-left: 91.66666667%;
            }
        }

        .row.row-equal {
            margin-right: -15px;
            margin-left: -15px;
        }

        .row.row-equal,.row.row-equal [class*="col-"] {
            padding-right: 7.5px;
            padding-left: 7.5px;
        }

        .main .container-fluid, .main .container-sm, .main .container-md, .main .container-lg, .main .container-xl {
            padding: 0 30px;
        }

        .c-header {
            position: relative;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: row;
            flex-direction: row;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            -ms-flex-negative: 0;
            flex-shrink: 0;
            min-height: 56px;
            background: #fff;
            border-bottom: 1px solid #d8dbe0;
        }

        .c-header[class*="bg-"] {
            border-color: rgba(0, 0, 21, 0.1);
        }

        .c-header.c-header-fixed {
            position: fixed;
            right: 0;
            left: 0;
            z-index: 1029;
        }

        .c-header .c-subheader {
            border-bottom: 0;
            margin-top: -1px;
            border-top: 1px solid #d8dbe0;
        }

        .c-header-brand {
            display: -ms-inline-flexbox;
            display: inline-flex;
            -ms-flex-align: center;
            align-items: center;
            -ms-flex-pack: center;
            justify-content: center;
            width: auto;
            min-height: 56px;
            transition: width 0.3s;
        }

        .c-header-brand.c-header-brand-center {
            position: absolute;
            top: 56px;
            -webkit-transform: translate(-50%, -100%);
            transform: translate(-50%, -100%);
        }

        html:not([dir="rtl"]) .c-header-brand.c-header-brand-center {
            left: 50%;
        }

        *[dir="rtl"] .c-header-brand.c-header-brand-center {
            right: 50%;
        }

        @media (max-width: 575.98px) {
            .c-header-brand.c-header-brand-xs-down-center {
                position: absolute;
                top: 56px;
                -webkit-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            html:not([dir="rtl"]) .c-header-brand.c-header-brand-xs-down-center {
                left: 50%;
            }
            *[dir="rtl"] .c-header-brand.c-header-brand-xs-down-center {
                right: 50%;
            }
        }

        .c-header-brand.c-header-brand-xs-up-center {
            position: absolute;
            top: 56px;
            -webkit-transform: translate(-50%, -100%);
            transform: translate(-50%, -100%);
        }

        html:not([dir="rtl"]) .c-header-brand.c-header-brand-xs-up-center {
            left: 50%;
        }

        *[dir="rtl"] .c-header-brand.c-header-brand-xs-up-center {
            right: 50%;
        }

        @media (max-width: 767.98px) {
            .c-header-brand.c-header-brand-sm-down-center {
                position: absolute;
                top: 56px;
                -webkit-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            html:not([dir="rtl"]) .c-header-brand.c-header-brand-sm-down-center {
                left: 50%;
            }
            *[dir="rtl"] .c-header-brand.c-header-brand-sm-down-center {
                right: 50%;
            }
        }

        @media (min-width: 576px) {
            .c-header-brand.c-header-brand-sm-up-center {
                position: absolute;
                top: 56px;
                -webkit-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            html:not([dir="rtl"]) .c-header-brand.c-header-brand-sm-up-center {
                left: 50%;
            }
            *[dir="rtl"] .c-header-brand.c-header-brand-sm-up-center {
                right: 50%;
            }
        }

        @media (max-width: 991.98px) {
            .c-header-brand.c-header-brand-md-down-center {
                position: absolute;
                top: 56px;
                -webkit-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            html:not([dir="rtl"]) .c-header-brand.c-header-brand-md-down-center {
                left: 50%;
            }
            *[dir="rtl"] .c-header-brand.c-header-brand-md-down-center {
                right: 50%;
            }
        }

        @media (min-width: 768px) {
            .c-header-brand.c-header-brand-md-up-center {
                position: absolute;
                top: 56px;
                -webkit-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            html:not([dir="rtl"]) .c-header-brand.c-header-brand-md-up-center {
                left: 50%;
            }
            *[dir="rtl"] .c-header-brand.c-header-brand-md-up-center {
                right: 50%;
            }
        }

        @media (max-width: 1199.98px) {
            .c-header-brand.c-header-brand-lg-down-center {
                position: absolute;
                top: 56px;
                -webkit-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            html:not([dir="rtl"]) .c-header-brand.c-header-brand-lg-down-center {
                left: 50%;
            }
            *[dir="rtl"] .c-header-brand.c-header-brand-lg-down-center {
                right: 50%;
            }
        }

        @media (min-width: 992px) {
            .c-header-brand.c-header-brand-lg-up-center {
                position: absolute;
                top: 56px;
                -webkit-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            html:not([dir="rtl"]) .c-header-brand.c-header-brand-lg-up-center {
                left: 50%;
            }
            *[dir="rtl"] .c-header-brand.c-header-brand-lg-up-center {
                right: 50%;
            }
        }

        .c-header-brand.c-header-brand-xl-down-center {
            position: absolute;
            top: 56px;
            -webkit-transform: translate(-50%, -100%);
            transform: translate(-50%, -100%);
        }

        html:not([dir="rtl"]) .c-header-brand.c-header-brand-xl-down-center {
            left: 50%;
        }

        *[dir="rtl"] .c-header-brand.c-header-brand-xl-down-center {
            right: 50%;
        }

        @media (min-width: 1200px) {
            .c-header-brand.c-header-brand-xl-up-center {
                position: absolute;
                top: 56px;
                -webkit-transform: translate(-50%, -100%);
                transform: translate(-50%, -100%);
            }
            html:not([dir="rtl"]) .c-header-brand.c-header-brand-xl-up-center {
                left: 50%;
            }
            *[dir="rtl"] .c-header-brand.c-header-brand-xl-up-center {
                right: 50%;
            }
        }

        .c-header-toggler {
            min-width: 50px;
            font-size: 1.09375rem;
            background-color: transparent;
            border: 0;
            border-radius: 0.25rem;
        }

        .c-header-toggler:hover, .c-header-toggler:focus {
            text-decoration: none;
        }

        .c-header-toggler:not(:disabled):not(.c-disabled) {
            cursor: pointer;
        }

        .c-header-toggler-icon {
            display: block;
            height: 1.3671875rem;
            background-repeat: no-repeat;
            background-position: center center;
            background-size: 100% 100%;
        }

        .c-header-nav {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: row;
            flex-direction: row;
            -ms-flex-align: center;
            align-items: center;
            min-height: 56px;
            padding: 0;
            margin-bottom: 0;
            list-style: none;
        }

        .c-header-nav .c-header-nav-item {
            position: relative;
        }

        .c-header-nav .c-header-nav-btn {
            background-color: transparent;
            border: 1px solid transparent;
        }

        .c-header-nav .c-header-nav-link,
        .c-header-nav .c-header-nav-btn {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            padding-right: 0.5rem;
            padding-left: 0.5rem;
        }

        .c-header-nav .c-header-nav-link .badge,
        .c-header-nav .c-header-nav-btn .badge {
            position: absolute;
            top: 50%;
            margin-top: -16px;
        }

        html:not([dir="rtl"]) .c-header-nav .c-header-nav-link .badge, html:not([dir="rtl"])
        .c-header-nav .c-header-nav-btn .badge {
            left: 50%;
            margin-left: 0;
        }

        *[dir="rtl"] .c-header-nav .c-header-nav-link .badge, *[dir="rtl"]
        .c-header-nav .c-header-nav-btn .badge {
            right: 50%;
            margin-right: 0;
        }

        .c-header-nav .c-header-nav-link:hover,
        .c-header-nav .c-header-nav-btn:hover {
            text-decoration: none;
        }

        .c-header-nav .dropdown-item {
            min-width: 180px;
        }

        .c-header.c-header-dark {
            background: #3c4b64;
            border-bottom: 1px solid #636f83;
        }

        .c-header.c-header-dark .c-subheader {
            margin-top: -1px;
            border-top: 1px solid #636f83;
        }

        .c-header.c-header-dark .c-header-brand {
            color: #fff;
            background-color: transparent;
        }

        .c-header.c-header-dark .c-header-brand:hover, .c-header.c-header-dark .c-header-brand:focus {
            color: #fff;
        }

        .c-header.c-header-dark .c-header-nav .c-header-nav-link,
        .c-header.c-header-dark .c-header-nav .c-header-nav-btn {
            color: rgba(255, 255, 255, 0.75);
        }

        .c-header.c-header-dark .c-header-nav .c-header-nav-link:hover, .c-header.c-header-dark .c-header-nav .c-header-nav-link:focus,
        .c-header.c-header-dark .c-header-nav .c-header-nav-btn:hover,
        .c-header.c-header-dark .c-header-nav .c-header-nav-btn:focus {
            color: rgba(255, 255, 255, 0.9);
        }

        .c-header.c-header-dark .c-header-nav .c-header-nav-link.c-disabled,
        .c-header.c-header-dark .c-header-nav .c-header-nav-btn.c-disabled {
            color: rgba(255, 255, 255, 0.25);
        }

        .c-header.c-header-dark .c-header-nav .c-show > .c-header-nav-link,
        .c-header.c-header-dark .c-header-nav .c-active > .c-header-nav-link,
        .c-header.c-header-dark .c-header-nav .c-header-nav-link.c-show,
        .c-header.c-header-dark .c-header-nav .c-header-nav-link.c-active {
            color: #fff;
        }

        .c-header.c-header-dark .c-header-toggler {
            color: rgba(255, 255, 255, 0.75);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .c-header.c-header-dark .c-header-toggler-icon {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(255, 255, 255, 0.75)' stroke-width='2.25' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E");
        }

        .c-header.c-header-dark .c-header-toggler-icon:hover {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(255, 255, 255, 0.9)' stroke-width='2.25' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E");
        }

        .c-header.c-header-dark .c-header-text {
            color: rgba(255, 255, 255, 0.75);
        }

        .c-header.c-header-dark .c-header-text a,.c-header.c-header-dark .c-header-text a:hover, .c-header.c-header-dark .c-header-text a:focus {
            color: #fff;
        }

        .c-header .c-header-brand {
            color: #4f5d73;
            background-color: transparent;
        }

        .c-header .c-header-brand:hover, .c-header .c-header-brand:focus {
            color: #3a4555;
        }

        .c-header .c-header-nav .c-header-nav-link,
        .c-header .c-header-nav .c-header-nav-btn {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-header .c-header-nav .c-header-nav-link:hover, .c-header .c-header-nav .c-header-nav-link:focus,
        .c-header .c-header-nav .c-header-nav-btn:hover,
        .c-header .c-header-nav .c-header-nav-btn:focus {
            color: rgba(0, 0, 21, 0.7);
        }

        .c-header .c-header-nav .c-header-nav-link.c-disabled,
        .c-header .c-header-nav .c-header-nav-btn.c-disabled {
            color: rgba(0, 0, 21, 0.3);
        }

        .c-header .c-header-nav .c-show > .c-header-nav-link,
        .c-header .c-header-nav .c-active > .c-header-nav-link,
        .c-header .c-header-nav .c-header-nav-link.c-show,
        .c-header .c-header-nav .c-header-nav-link.c-active {
            color: rgba(0, 0, 21, 0.9);
        }

        .c-header .c-header-toggler {
            color: rgba(0, 0, 21, 0.5);
            border-color: rgba(0, 0, 21, 0.1);
        }

        .c-header .c-header-toggler-icon {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(0, 0, 21, 0.5)' stroke-width='2.25' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E");
        }

        .c-header .c-header-toggler-icon:hover {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg viewBox='0 0 30 30' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath stroke='rgba(0, 0, 21, 0.7)' stroke-width='2.25' stroke-linecap='round' stroke-miterlimit='10' d='M4 7h22M4 15h22M4 23h22'/%3E%3C/svg%3E");
        }

        .c-header .c-header-text {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-header .c-header-text a,.c-header .c-header-text a:hover, .c-header .c-header-text a:focus {
            color: rgba(0, 0, 21, 0.9);
        }

        .c-icon {
            display: inline-block;
            color: inherit;
            text-align: center;
            fill: currentColor;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size) {
            width: 1rem;
            height: 1rem;
            font-size: 1rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-2xl {
            width: 2rem;
            height: 2rem;
            font-size: 2rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-3xl {
            width: 3rem;
            height: 3rem;
            font-size: 3rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-4xl {
            width: 4rem;
            height: 4rem;
            font-size: 4rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-5xl {
            width: 5rem;
            height: 5rem;
            font-size: 5rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-6xl {
            width: 6rem;
            height: 6rem;
            font-size: 6rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-7xl {
            width: 7rem;
            height: 7rem;
            font-size: 7rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-8xl {
            width: 8rem;
            height: 8rem;
            font-size: 8rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-9xl {
            width: 9rem;
            height: 9rem;
            font-size: 9rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-xl {
            width: 1.5rem;
            height: 1.5rem;
            font-size: 1.5rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-lg {
            width: 1.25rem;
            height: 1.25rem;
            font-size: 1.25rem;
        }

        .c-icon:not(.c-icon-c-s):not(.c-icon-custom-size).c-icon-sm {
            width: 0.875rem;
            height: 0.875rem;
            font-size: 0.875rem;
        }

        .input-group {
            position: relative;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            -ms-flex-align: stretch;
            align-items: stretch;
            width: 100%;
        }

        .input-group > .form-control,
        .input-group > .form-control-plaintext,
        .input-group > .custom-select,
        .input-group > .custom-file {
            position: relative;
            -ms-flex: 1 1 auto;
            flex: 1 1 auto;
            width: 1%;
            min-width: 0;
            margin-bottom: 0;
        }

        html:not([dir="rtl"]) .input-group > .form-control + .form-control, html:not([dir="rtl"])
        .input-group > .form-control + .custom-select, html:not([dir="rtl"])
        .input-group > .form-control + .custom-file, html:not([dir="rtl"])
        .input-group > .form-control-plaintext + .form-control, html:not([dir="rtl"])
        .input-group > .form-control-plaintext + .custom-select, html:not([dir="rtl"])
        .input-group > .form-control-plaintext + .custom-file, html:not([dir="rtl"])
        .input-group > .custom-select + .form-control, html:not([dir="rtl"])
        .input-group > .custom-select + .custom-select, html:not([dir="rtl"])
        .input-group > .custom-select + .custom-file, html:not([dir="rtl"])
        .input-group > .custom-file + .form-control, html:not([dir="rtl"])
        .input-group > .custom-file + .custom-select, html:not([dir="rtl"])
        .input-group > .custom-file + .custom-file {
            margin-left: -1px;
        }

        *[dir="rtl"] .input-group > .form-control + .form-control, *[dir="rtl"]
        .input-group > .form-control + .custom-select, *[dir="rtl"]
        .input-group > .form-control + .custom-file, *[dir="rtl"]
        .input-group > .form-control-plaintext + .form-control, *[dir="rtl"]
        .input-group > .form-control-plaintext + .custom-select, *[dir="rtl"]
        .input-group > .form-control-plaintext + .custom-file, *[dir="rtl"]
        .input-group > .custom-select + .form-control, *[dir="rtl"]
        .input-group > .custom-select + .custom-select, *[dir="rtl"]
        .input-group > .custom-select + .custom-file, *[dir="rtl"]
        .input-group > .custom-file + .form-control, *[dir="rtl"]
        .input-group > .custom-file + .custom-select, *[dir="rtl"]
        .input-group > .custom-file + .custom-file {
            margin-right: -1px;
        }

        .input-group > .form-control:focus,
        .input-group > .custom-select:focus,
        .input-group > .custom-file .custom-file-input:focus ~ .custom-file-label {
            z-index: 3;
        }

        .input-group > .custom-file .custom-file-input:focus {
            z-index: 4;
        }

        html:not([dir="rtl"]) .input-group > .form-control:not(:last-child), html:not([dir="rtl"])
        .input-group > .custom-select:not(:last-child) {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        *[dir="rtl"] .input-group > .form-control:not(:last-child), *[dir="rtl"]
        .input-group > .custom-select:not(:last-child),html:not([dir="rtl"]) .input-group > .form-control:not(:first-child), html:not([dir="rtl"])
        .input-group > .custom-select:not(:first-child) {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        *[dir="rtl"] .input-group > .form-control:not(:first-child), *[dir="rtl"]
        .input-group > .custom-select:not(:first-child) {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .input-group > .custom-file {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
        }

        html:not([dir="rtl"]) .input-group > .custom-file:not(:last-child) .custom-file-label, html:not([dir="rtl"])
        .input-group > .custom-file:not(:last-child) .custom-file-label::after {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        *[dir="rtl"] .input-group > .custom-file:not(:last-child) .custom-file-label, *[dir="rtl"]
        .input-group > .custom-file:not(:last-child) .custom-file-label::after,html:not([dir="rtl"]) .input-group > .custom-file:not(:first-child) .custom-file-label {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        *[dir="rtl"] .input-group > .custom-file:not(:first-child) .custom-file-label {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .input-group-prepend,
        .input-group-append {
            display: -ms-flexbox;
            display: flex;
        }

        .input-group-prepend .btn,
        .input-group-append .btn {
            position: relative;
            z-index: 2;
        }

        .input-group-prepend .btn:focus,
        .input-group-append .btn:focus {
            z-index: 3;
        }

        html:not([dir="rtl"]) .input-group-prepend .btn + .btn, html:not([dir="rtl"])
        .input-group-prepend .btn + .input-group-text, html:not([dir="rtl"])
        .input-group-prepend .input-group-text + .input-group-text, html:not([dir="rtl"])
        .input-group-prepend .input-group-text + .btn, html:not([dir="rtl"])
        .input-group-append .btn + .btn, html:not([dir="rtl"])
        .input-group-append .btn + .input-group-text, html:not([dir="rtl"])
        .input-group-append .input-group-text + .input-group-text, html:not([dir="rtl"])
        .input-group-append .input-group-text + .btn {
            margin-left: -1px;
        }

        *[dir="rtl"] .input-group-prepend .btn + .btn, *[dir="rtl"]
        .input-group-prepend .btn + .input-group-text, *[dir="rtl"]
        .input-group-prepend .input-group-text + .input-group-text, *[dir="rtl"]
        .input-group-prepend .input-group-text + .btn, *[dir="rtl"]
        .input-group-append .btn + .btn, *[dir="rtl"]
        .input-group-append .btn + .input-group-text, *[dir="rtl"]
        .input-group-append .input-group-text + .input-group-text, *[dir="rtl"]
        .input-group-append .input-group-text + .btn {
            margin-right: -1px;
        }

        .input-group-prepend {
            white-space: nowrap;
            vertical-align: middle;
        }

        html:not([dir="rtl"]) .input-group-prepend {
            margin-right: -1px;
        }

        *[dir="rtl"] .input-group-prepend {
            margin-left: -1px;
        }

        .input-group-append {
            white-space: nowrap;
            vertical-align: middle;
        }

        html:not([dir="rtl"]) .input-group-append {
            margin-left: -1px;
        }

        *[dir="rtl"] .input-group-append {
            margin-right: -1px;
        }

        .input-group-text {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            padding: 0.375rem 0.75rem;
            margin-bottom: 0;
            font-size: 0.875rem;
            font-weight: 400;
            line-height: 1.5;
            text-align: center;
            white-space: nowrap;
            border: 1px solid;
            border-radius: 0.25rem;
            color: #768192;
            background-color: #ebedef;
            border-color: #d8dbe0;
        }

        .input-group-text input[type="radio"],
        .input-group-text input[type="checkbox"] {
            margin-top: 0;
        }

        .input-group-lg > .form-control:not(textarea),
        .input-group-lg > .custom-select {
            height: calc(1.5em + 1rem + 2px);
        }

        .input-group-lg > .form-control,
        .input-group-lg > .custom-select,
        .input-group-lg > .input-group-prepend > .input-group-text,
        .input-group-lg > .input-group-append > .input-group-text,
        .input-group-lg > .input-group-prepend > .btn,
        .input-group-lg > .input-group-append > .btn {
            padding: 0.5rem 1rem;
            font-size: 1.09375rem;
            line-height: 1.5;
            border-radius: 0.3rem;
        }

        .input-group-sm > .form-control:not(textarea),
        .input-group-sm > .custom-select {
            height: calc(1.5em + 0.5rem + 2px);
        }

        .input-group-sm > .form-control,
        .input-group-sm > .custom-select,
        .input-group-sm > .input-group-prepend > .input-group-text,
        .input-group-sm > .input-group-append > .input-group-text,
        .input-group-sm > .input-group-prepend > .btn,
        .input-group-sm > .input-group-append > .btn {
            padding: 0.25rem 0.5rem;
            font-size: 0.765625rem;
            line-height: 1.5;
            border-radius: 0.2rem;
        }

        html:not([dir="rtl"]) .input-group-lg > .custom-select, html:not([dir="rtl"])
        .input-group-sm > .custom-select {
            padding-right: 1.75rem;
        }

        *[dir="rtl"] .input-group-lg > .custom-select, *[dir="rtl"]
        .input-group-sm > .custom-select {
            padding-left: 1.75rem;
        }

        html:not([dir="rtl"]) .input-group > .input-group-prepend > .btn, html:not([dir="rtl"])
        .input-group > .input-group-prepend > .input-group-text, html:not([dir="rtl"])
        .input-group > .input-group-append:not(:last-child) > .btn, html:not([dir="rtl"])
        .input-group > .input-group-append:not(:last-child) > .input-group-text, html:not([dir="rtl"])
        .input-group > .input-group-append:last-child > .btn:not(:last-child):not(.dropdown-toggle), html:not([dir="rtl"])
        .input-group > .input-group-append:last-child > .input-group-text:not(:last-child) {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        *[dir="rtl"] .input-group > .input-group-prepend > .btn, *[dir="rtl"]
        .input-group > .input-group-prepend > .input-group-text, *[dir="rtl"]
        .input-group > .input-group-append:not(:last-child) > .btn, *[dir="rtl"]
        .input-group > .input-group-append:not(:last-child) > .input-group-text, *[dir="rtl"]
        .input-group > .input-group-append:last-child > .btn:not(:last-child):not(.dropdown-toggle), *[dir="rtl"]
        .input-group > .input-group-append:last-child > .input-group-text:not(:last-child),html:not([dir="rtl"]) .input-group > .input-group-append > .btn, html:not([dir="rtl"])
        .input-group > .input-group-append > .input-group-text, html:not([dir="rtl"])
        .input-group > .input-group-prepend:not(:first-child) > .btn, html:not([dir="rtl"])
        .input-group > .input-group-prepend:not(:first-child) > .input-group-text, html:not([dir="rtl"])
        .input-group > .input-group-prepend:first-child > .btn:not(:first-child), html:not([dir="rtl"])
        .input-group > .input-group-prepend:first-child > .input-group-text:not(:first-child) {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0;
        }

        *[dir="rtl"] .input-group > .input-group-append > .btn, *[dir="rtl"]
        .input-group > .input-group-append > .input-group-text, *[dir="rtl"]
        .input-group > .input-group-prepend:not(:first-child) > .btn, *[dir="rtl"]
        .input-group > .input-group-prepend:not(:first-child) > .input-group-text, *[dir="rtl"]
        .input-group > .input-group-prepend:first-child > .btn:not(:first-child), *[dir="rtl"]
        .input-group > .input-group-prepend:first-child > .input-group-text:not(:first-child) {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }

        .img-fluid,.img-thumbnail {
            max-width: 100%;
            height: auto;
        }

        .img-thumbnail {
            padding: 0.25rem;
            background-color: #ebedef;
            border: 1px solid #c4c9d0;
            border-radius: 0.25rem;
        }

        .figure {
            display: inline-block;
        }

        .figure-img {
            margin-bottom: 0.5rem;
            line-height: 1;
        }

        .figure-caption {
            font-size: 90%;
            color: #8a93a2;
        }

        .jumbotron {
            padding: 2rem 1rem;
            margin-bottom: 2rem;
            border-radius: 0.3rem;
            background-color: #d8dbe0;
        }

        @media (min-width: 576px) {
            .jumbotron {
                padding: 4rem 2rem;
            }
        }

        .jumbotron-fluid {
            padding-right: 0;
            padding-left: 0;
            border-radius: 0;
        }

        .list-group {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: column;
            flex-direction: column;
            margin-bottom: 0;
            border-radius: 0.25rem;
        }

        html:not([dir="rtl"]) .list-group {
            padding-left: 0;
        }

        *[dir="rtl"] .list-group {
            padding-right: 0;
        }

        .list-group-item-action {
            width: 100%;
            text-align: inherit;
            color: #768192;
        }

        .list-group-item-action:hover, .list-group-item-action:focus {
            z-index: 1;
            text-decoration: none;
            color: #768192;
            background-color: #ebedef;
        }

        .list-group-item-action:active {
            color: #4f5d73;
            background-color: #d8dbe0;
        }

        .list-group-item {
            position: relative;
            display: block;
            padding: 0.75rem 1.25rem;
            border: 1px solid;
            background-color: inherit;
            border-color: rgba(0, 0, 21, 0.125);
        }

        .list-group-item:first-child {
            border-top-left-radius: inherit;
            border-top-right-radius: inherit;
        }

        .list-group-item:last-child {
            border-bottom-right-radius: inherit;
            border-bottom-left-radius: inherit;
        }

        .list-group-item.disabled, .list-group-item:disabled {
            pointer-events: none;
            color: #8a93a2;
            background-color: inherit;
        }

        .list-group-item.active {
            z-index: 2;
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .list-group-item + .list-group-item {
            border-top-width: 0;
        }

        .list-group-item + .list-group-item.active {
            margin-top: -1px;
            border-top-width: 1px;
        }

        .list-group-horizontal {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .list-group-horizontal .list-group-item:first-child {
            border-bottom-left-radius: 0.25rem;
            border-top-right-radius: 0;
        }

        .list-group-horizontal .list-group-item:last-child {
            border-top-right-radius: 0.25rem;
            border-bottom-left-radius: 0;
        }

        .list-group-horizontal .list-group-item.active {
            margin-top: 0;
        }

        .list-group-horizontal .list-group-item + .list-group-item {
            border-top-width: 1px;
            border-left-width: 0;
        }

        .list-group-horizontal .list-group-item + .list-group-item.active {
            margin-left: -1px;
            border-left-width: 1px;
        }

        @media (min-width: 576px) {
            .list-group-horizontal-sm {
                -ms-flex-direction: row;
                flex-direction: row;
            }
            .list-group-horizontal-sm .list-group-item:first-child {
                border-bottom-left-radius: 0.25rem;
                border-top-right-radius: 0;
            }
            .list-group-horizontal-sm .list-group-item:last-child {
                border-top-right-radius: 0.25rem;
                border-bottom-left-radius: 0;
            }
            .list-group-horizontal-sm .list-group-item.active {
                margin-top: 0;
            }
            .list-group-horizontal-sm .list-group-item + .list-group-item {
                border-top-width: 1px;
                border-left-width: 0;
            }
            .list-group-horizontal-sm .list-group-item + .list-group-item.active {
                margin-left: -1px;
                border-left-width: 1px;
            }
        }

        @media (min-width: 768px) {
            .list-group-horizontal-md {
                -ms-flex-direction: row;
                flex-direction: row;
            }
            .list-group-horizontal-md .list-group-item:first-child {
                border-bottom-left-radius: 0.25rem;
                border-top-right-radius: 0;
            }
            .list-group-horizontal-md .list-group-item:last-child {
                border-top-right-radius: 0.25rem;
                border-bottom-left-radius: 0;
            }
            .list-group-horizontal-md .list-group-item.active {
                margin-top: 0;
            }
            .list-group-horizontal-md .list-group-item + .list-group-item {
                border-top-width: 1px;
                border-left-width: 0;
            }
            .list-group-horizontal-md .list-group-item + .list-group-item.active {
                margin-left: -1px;
                border-left-width: 1px;
            }
        }

        @media (min-width: 992px) {
            .list-group-horizontal-lg {
                -ms-flex-direction: row;
                flex-direction: row;
            }
            .list-group-horizontal-lg .list-group-item:first-child {
                border-bottom-left-radius: 0.25rem;
                border-top-right-radius: 0;
            }
            .list-group-horizontal-lg .list-group-item:last-child {
                border-top-right-radius: 0.25rem;
                border-bottom-left-radius: 0;
            }
            .list-group-horizontal-lg .list-group-item.active {
                margin-top: 0;
            }
            .list-group-horizontal-lg .list-group-item + .list-group-item {
                border-top-width: 1px;
                border-left-width: 0;
            }
            .list-group-horizontal-lg .list-group-item + .list-group-item.active {
                margin-left: -1px;
                border-left-width: 1px;
            }
        }

        @media (min-width: 1200px) {
            .list-group-horizontal-xl {
                -ms-flex-direction: row;
                flex-direction: row;
            }
            .list-group-horizontal-xl .list-group-item:first-child {
                border-bottom-left-radius: 0.25rem;
                border-top-right-radius: 0;
            }
            .list-group-horizontal-xl .list-group-item:last-child {
                border-top-right-radius: 0.25rem;
                border-bottom-left-radius: 0;
            }
            .list-group-horizontal-xl .list-group-item.active {
                margin-top: 0;
            }
            .list-group-horizontal-xl .list-group-item + .list-group-item {
                border-top-width: 1px;
                border-left-width: 0;
            }
            .list-group-horizontal-xl .list-group-item + .list-group-item.active {
                margin-left: -1px;
                border-left-width: 1px;
            }
        }

        .list-group-flush {
            border-radius: 0;
        }

        .list-group-flush > .list-group-item {
            border-width: 0 0 1px;
        }

        .list-group-flush > .list-group-item:last-child {
            border-bottom-width: 0;
        }

        .list-group-item-primary {
            color: #1a107c;
            background-color: #c6c0f5;
        }

        .list-group-item-primary.list-group-item-action:hover, .list-group-item-primary.list-group-item-action:focus {
            color: #1a107c;
            background-color: #b2aaf2;
        }

        .list-group-item-primary.list-group-item-action.active {
            color: #fff;
            background-color: #1a107c;
            border-color: #1a107c;
        }

        .list-group-item-secondary {
            color: #6b6d7a;
            background-color: #f1f2f4;
        }

        .list-group-item-secondary.list-group-item-action:hover, .list-group-item-secondary.list-group-item-action:focus {
            color: #6b6d7a;
            background-color: #e3e5e9;
        }

        .list-group-item-secondary.list-group-item-action.active {
            color: #fff;
            background-color: #6b6d7a;
            border-color: #6b6d7a;
        }

        .list-group-item-success {
            color: #18603a;
            background-color: #c4ebd1;
        }

        .list-group-item-success.list-group-item-action:hover, .list-group-item-success.list-group-item-action:focus {
            color: #18603a;
            background-color: #b1e5c2;
        }

        .list-group-item-success.list-group-item-action.active {
            color: #fff;
            background-color: #18603a;
            border-color: #18603a;
        }

        .list-group-item-info {
            color: #1b508f;
            background-color: #c6e2ff;
        }

        .list-group-item-info.list-group-item-action:hover, .list-group-item-info.list-group-item-action:focus {
            color: #1b508f;
            background-color: #add5ff;
        }

        .list-group-item-info.list-group-item-action.active {
            color: #fff;
            background-color: #1b508f;
            border-color: #1b508f;
        }

        .list-group-item-warning {
            color: #815c15;
            background-color: #fde9bd;
        }

        .list-group-item-warning.list-group-item-action:hover, .list-group-item-warning.list-group-item-action:focus {
            color: #815c15;
            background-color: #fce1a4;
        }

        .list-group-item-warning.list-group-item-action.active {
            color: #fff;
            background-color: #815c15;
            border-color: #815c15;
        }

        .list-group-item-danger {
            color: #772b35;
            background-color: #f8cfcf;
        }

        .list-group-item-danger.list-group-item-action:hover, .list-group-item-danger.list-group-item-action:focus {
            color: #772b35;
            background-color: #f5b9b9;
        }

        .list-group-item-danger.list-group-item-action.active {
            color: #fff;
            background-color: #772b35;
            border-color: #772b35;
        }

        .list-group-item-light {
            color: #7a7b86;
            background-color: #f9fafb;
        }

        .list-group-item-light.list-group-item-action:hover, .list-group-item-light.list-group-item-action:focus {
            color: #7a7b86;
            background-color: #eaedf1;
        }

        .list-group-item-light.list-group-item-action.active {
            color: #fff;
            background-color: #7a7b86;
            border-color: #7a7b86;
        }

        .list-group-item-dark {
            color: #333a4e;
            background-color: #d3d7dc;
        }

        .list-group-item-dark.list-group-item-action:hover, .list-group-item-dark.list-group-item-action:focus {
            color: #333a4e;
            background-color: #c5cad1;
        }

        .list-group-item-dark.list-group-item-action.active {
            color: #fff;
            background-color: #333a4e;
            border-color: #333a4e;
        }

        .list-group-accent .list-group-item {
            margin-bottom: 1px;
            border-top: 0;
            border-right: 0;
            border-bottom: 0;
            border-radius: 0;
        }

        .list-group-accent .list-group-item.list-group-item-divider {
            position: relative;
        }

        .list-group-accent .list-group-item.list-group-item-divider::before {
            position: absolute;
            bottom: -1px;
            width: 90%;
            height: 1px;
            content: "";
            background-color: rgba(0, 0, 21, 0.125);
        }

        html:not([dir="rtl"]) .list-group-accent .list-group-item.list-group-item-divider::before {
            left: 5%;
        }

        *[dir="rtl"] .list-group-accent .list-group-item.list-group-item-divider::before {
            right: 5%;
        }

        .list-group-accent .list-group-item-accent-primary {
            border-left: 4px solid #321fdb;
        }

        .list-group-accent .list-group-item-accent-secondary {
            border-left: 4px solid #ced2d8;
        }

        .list-group-accent .list-group-item-accent-success {
            border-left: 4px solid #2eb85c;
        }

        .list-group-accent .list-group-item-accent-info {
            border-left: 4px solid #39f;
        }

        .list-group-accent .list-group-item-accent-warning {
            border-left: 4px solid #f9b115;
        }

        .list-group-accent .list-group-item-accent-danger {
            border-left: 4px solid #e55353;
        }

        .list-group-accent .list-group-item-accent-light {
            border-left: 4px solid #ebedef;
        }

        .list-group-accent .list-group-item-accent-dark {
            border-left: 4px solid #636f83;
        }

        .media {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: start;
            align-items: flex-start;
        }

        .media-body {
            -ms-flex: 1;
            flex: 1;
        }

        .modal-open {
            overflow: hidden;
        }

        .modal-open .modal {
            overflow-x: hidden;
            overflow-y: auto;
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1050;
            display: none;
            width: 100%;
            height: 100%;
            overflow: hidden;
            outline: 0;
        }

        .modal-dialog {
            position: relative;
            width: auto;
            margin: 0.5rem;
            pointer-events: none;
        }

        .modal.fade .modal-dialog {
            transition: -webkit-transform 0.3s ease-out;
            transition: transform 0.3s ease-out;
            transition: transform 0.3s ease-out, -webkit-transform 0.3s ease-out;
            -webkit-transform: translate(0, -50px);
            transform: translate(0, -50px);
        }

        @media (prefers-reduced-motion: reduce) {
            .modal.fade .modal-dialog {
                transition: none;
            }
        }

        .modal.show .modal-dialog {
            -webkit-transform: none;
            transform: none;
        }

        .modal.modal-static .modal-dialog {
            -webkit-transform: scale(1.02);
            transform: scale(1.02);
        }

        .modal-dialog-scrollable {
            display: -ms-flexbox;
            display: flex;
            max-height: calc(100% - 1rem);
        }

        .modal-dialog-scrollable .modal-content {
            max-height: calc(100vh - 1rem);
            overflow: hidden;
        }

        .modal-dialog-scrollable .modal-header,
        .modal-dialog-scrollable .modal-footer {
            -ms-flex-negative: 0;
            flex-shrink: 0;
        }

        .modal-dialog-scrollable .modal-body {
            overflow-y: auto;
        }

        .modal-dialog-centered {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            min-height: calc(100% - 1rem);
        }

        .modal-dialog-centered::before {
            display: block;
            height: calc(100vh - 1rem);
            height: -webkit-min-content;
            height: -moz-min-content;
            height: min-content;
            content: "";
        }

        .modal-dialog-centered.modal-dialog-scrollable {
            -ms-flex-direction: column;
            flex-direction: column;
            -ms-flex-pack: center;
            justify-content: center;
            height: 100%;
        }

        .modal-dialog-centered.modal-dialog-scrollable .modal-content {
            max-height: none;
        }

        .modal-dialog-centered.modal-dialog-scrollable::before {
            content: none;
        }

        .modal-content {
            position: relative;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: column;
            flex-direction: column;
            width: 100%;
            pointer-events: auto;
            background-clip: padding-box;
            border: 1px solid;
            border-radius: 0.3rem;
            outline: 0;
            background-color: #fff;
            border-color: rgba(0, 0, 21, 0.2);
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1040;
            width: 100vw;
            height: 100vh;
            background-color: #000015;
        }

        .modal-backdrop.fade {
            opacity: 0;
        }

        .modal-backdrop.show {
            opacity: 0.5;
        }

        .modal-header {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: start;
            align-items: flex-start;
            -ms-flex-pack: justify;
            justify-content: space-between;
            border-bottom: 1px solid;
            border-top-left-radius: calc(0.3rem - 1px);
            border-top-right-radius: calc(0.3rem - 1px);
            border-color: #d8dbe0;
        }

        .modal-header,.modal-header .close {
            padding: 1rem 1rem;
        }

        html:not([dir="rtl"]) .modal-header .close {
            margin: -1rem -1rem -1rem auto;
        }

        *[dir="rtl"] .modal-header .close {
            margin: -1rem auto -1rem -1rem;
        }

        .modal-title {
            margin-bottom: 0;
            line-height: 1.5;
        }

        .modal-body {
            position: relative;
            -ms-flex: 1 1 auto;
            flex: 1 1 auto;
            padding: 1rem;
        }

        .modal-footer {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            -ms-flex-align: center;
            align-items: center;
            -ms-flex-pack: end;
            justify-content: flex-end;
            padding: 0.75rem;
            border-top: 1px solid;
            border-bottom-right-radius: calc(0.3rem - 1px);
            border-bottom-left-radius: calc(0.3rem - 1px);
            border-color: #d8dbe0;
        }

        .modal-footer > * {
            margin: 0.25rem;
        }

        .modal-scrollbar-measure {
            position: absolute;
            top: -9999px;
            width: 50px;
            height: 50px;
            overflow: scroll;
        }

        @media (min-width: 576px) {
            .modal-dialog {
                max-width: 500px;
                margin: 1.75rem auto;
            }
            .modal-dialog-scrollable {
                max-height: calc(100% - 3.5rem);
            }
            .modal-dialog-scrollable .modal-content {
                max-height: calc(100vh - 3.5rem);
            }
            .modal-dialog-centered {
                min-height: calc(100% - 3.5rem);
            }
            .modal-dialog-centered::before {
                height: calc(100vh - 3.5rem);
                height: -webkit-min-content;
                height: -moz-min-content;
                height: min-content;
            }
            .modal-sm {
                max-width: 300px;
            }
        }

        @media (min-width: 992px) {
            .modal-lg,
            .modal-xl {
                max-width: 800px;
            }
        }

        @media (min-width: 1200px) {
            .modal-xl {
                max-width: 1140px;
            }
        }

        .modal-primary .modal-content {
            border-color: #321fdb;
        }

        .modal-primary .modal-header {
            color: #fff;
            background-color: #321fdb;
        }

        .modal-secondary .modal-content {
            border-color: #ced2d8;
        }

        .modal-secondary .modal-header {
            color: #fff;
            background-color: #ced2d8;
        }

        .modal-success .modal-content {
            border-color: #2eb85c;
        }

        .modal-success .modal-header {
            color: #fff;
            background-color: #2eb85c;
        }

        .modal-info .modal-content {
            border-color: #39f;
        }

        .modal-info .modal-header {
            color: #fff;
            background-color: #39f;
        }

        .modal-warning .modal-content {
            border-color: #f9b115;
        }

        .modal-warning .modal-header {
            color: #fff;
            background-color: #f9b115;
        }

        .modal-danger .modal-content {
            border-color: #e55353;
        }

        .modal-danger .modal-header {
            color: #fff;
            background-color: #e55353;
        }

        .modal-light .modal-content {
            border-color: #ebedef;
        }

        .modal-light .modal-header {
            color: #fff;
            background-color: #ebedef;
        }

        .modal-dark .modal-content {
            border-color: #636f83;
        }

        .modal-dark .modal-header {
            color: #fff;
            background-color: #636f83;
        }

        .nav {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            margin-bottom: 0;
            list-style: none;
        }

        html:not([dir="rtl"]) .nav {
            padding-left: 0;
        }

        *[dir="rtl"] .nav {
            padding-right: 0;
        }

        .nav-link {
            display: block;
            padding: 0.5rem 1rem;
        }

        .nav-link:hover, .nav-link:focus {
            text-decoration: none;
        }

        .nav-link.disabled {
            color: #8a93a2;
            pointer-events: none;
            cursor: default;
            color: #8a93a2;
        }

        .nav-tabs {
            border-bottom: 1px solid;
            border-color: #c4c9d0;
        }

        .nav-tabs .nav-item {
            margin-bottom: -1px;
        }

        .nav-tabs .nav-link {
            border: 1px solid transparent;
            border-top-left-radius: 0.25rem;
            border-top-right-radius: 0.25rem;
        }

        .nav-tabs .nav-link:hover, .nav-tabs .nav-link:focus {
            border-color: #d8dbe0 #d8dbe0 #c4c9d0;
        }

        .nav-tabs .nav-link.disabled {
            background-color: transparent;
            border-color: transparent;
            color: #8a93a2;
        }

        .nav-tabs .nav-link.active,
        .nav-tabs .nav-item.show .nav-link {
            color: #768192;
            background-color: #ebedef;
            border-color: #c4c9d0 #c4c9d0 #ebedef;
        }

        .nav-tabs .dropdown-menu {
            margin-top: -1px;
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }

        .nav-tabs-boxed .nav-tabs {
            border: 0;
        }

        .nav-tabs-boxed .nav-tabs .nav-link.active {
            background-color: #fff;
            border-bottom-color: #fff;
        }

        .nav-tabs-boxed .tab-content {
            padding: 0.75rem 1.25rem;
            border: 1px solid;
            border-radius: 0 0.25rem 0.25rem 0.25rem;
            color: #768192;
            background-color: #fff;
            border-color: #d8dbe0;
        }

        .nav-tabs-boxed.nav-tabs-boxed-top-right .nav-tabs {
            -ms-flex-pack: end;
            justify-content: flex-end;
        }

        .nav-tabs-boxed.nav-tabs-boxed-top-right .tab-content {
            border-radius: 0.25rem 0 0.25rem 0.25rem;
        }

        .nav-tabs-boxed.nav-tabs-boxed-left, .nav-tabs-boxed.nav-tabs-boxed-right {
            display: -ms-flexbox;
            display: flex;
        }

        .nav-tabs-boxed.nav-tabs-boxed-left .nav-item, .nav-tabs-boxed.nav-tabs-boxed-right .nav-item {
            z-index: 1;
            -ms-flex-positive: 1;
            flex-grow: 1;
            margin-bottom: 0;
        }

        *[dir="rtl"] .nav-tabs-boxed.nav-tabs-boxed-left {
            -ms-flex-direction: row-reverse;
            flex-direction: row-reverse;
        }

        .nav-tabs-boxed.nav-tabs-boxed-left .nav-item {
            margin-right: -1px;
        }

        .nav-tabs-boxed.nav-tabs-boxed-left .nav-link {
            border-radius: 0.25rem 0 0 0.25rem;
        }

        .nav-tabs-boxed.nav-tabs-boxed-left .nav-link.active {
            border-color: #d8dbe0 #fff #d8dbe0 #d8dbe0;
        }

        html:not([dir="rtl"]) .nav-tabs-boxed.nav-tabs-boxed-right {
            -ms-flex-direction: row-reverse;
            flex-direction: row-reverse;
        }

        *[dir="rtl"] .nav-tabs-boxed.nav-tabs-boxed-right {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        html:not([dir="rtl"]) .nav-tabs-boxed.nav-tabs-boxed-right .nav-item {
            margin-left: -1px;
        }

        *[dir="rtl"] .nav-tabs-boxed.nav-tabs-boxed-right .nav-item {
            margin-right: -1px;
        }

        .nav-tabs-boxed.nav-tabs-boxed-right .nav-link {
            border-radius: 0 0.25rem 0.25rem 0;
        }

        .nav-tabs-boxed.nav-tabs-boxed-right .nav-link.active {
            border-color: #d8dbe0 #d8dbe0 #d8dbe0 #fff;
        }

        .nav-tabs-boxed.nav-tabs-boxed-right .tab-content {
            border-radius: 0.25rem 0 0.25rem 0.25rem;
        }

        .nav-pills .nav-link {
            border-radius: 0.25rem;
        }

        .nav-pills .nav-link.active,
        .nav-pills .show > .nav-link {
            color: #fff;
            background-color: #321fdb;
        }

        .nav-underline {
            border-bottom: 2px solid;
            border-color: #c4c9d0;
        }

        .nav-underline .nav-item {
            margin-bottom: -2px;
        }

        .nav-underline .nav-link {
            border: 0;
            border-bottom: 2px solid transparent;
        }

        .nav-underline .nav-link.active,
        .nav-underline .show > .nav-link {
            background: transparent;
        }

        .nav-underline-primary .nav-link.active,
        .nav-underline-primary .show > .nav-link {
            color: #321fdb;
            border-color: #321fdb;
        }

        .nav-underline-secondary .nav-link.active,
        .nav-underline-secondary .show > .nav-link {
            color: #ced2d8;
            border-color: #ced2d8;
        }

        .nav-underline-success .nav-link.active,
        .nav-underline-success .show > .nav-link {
            color: #2eb85c;
            border-color: #2eb85c;
        }

        .nav-underline-info .nav-link.active,
        .nav-underline-info .show > .nav-link {
            color: #39f;
            border-color: #39f;
        }

        .nav-underline-warning .nav-link.active,
        .nav-underline-warning .show > .nav-link {
            color: #f9b115;
            border-color: #f9b115;
        }

        .nav-underline-danger .nav-link.active,
        .nav-underline-danger .show > .nav-link {
            color: #e55353;
            border-color: #e55353;
        }

        .nav-underline-light .nav-link.active,
        .nav-underline-light .show > .nav-link {
            color: #ebedef;
            border-color: #ebedef;
        }

        .nav-underline-dark .nav-link.active,
        .nav-underline-dark .show > .nav-link {
            color: #636f83;
            border-color: #636f83;
        }

        .nav-fill .nav-item {
            -ms-flex: 1 1 auto;
            flex: 1 1 auto;
            text-align: center;
        }

        .nav-justified .nav-item {
            -ms-flex-preferred-size: 0;
            flex-basis: 0;
            -ms-flex-positive: 1;
            flex-grow: 1;
            text-align: center;
        }

        .tab-content > .tab-pane {
            display: none;
        }

        .tab-content > .active {
            display: block;
        }

        .c-sidebar .nav-tabs:first-child .nav-link,
        .c-sidebar .c-sidebar-close + .nav-tabs .nav-link {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            height: 56px;
            padding-top: 0;
            padding-bottom: 0;
        }

        .navbar {
            position: relative;
            padding: 0.5rem 1rem;
        }

        .navbar,.navbar .container,
        .navbar .container-fluid, .navbar .container-sm, .navbar .container-md, .navbar .container-lg, .navbar .container-xl {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            -ms-flex-align: center;
            align-items: center;
            -ms-flex-pack: justify;
            justify-content: space-between;
        }

        .navbar-brand {
            display: inline-block;
            padding-top: 0.3359375rem;
            padding-bottom: 0.3359375rem;
            margin-right: 1rem;
            font-size: 1.09375rem;
            line-height: inherit;
            white-space: nowrap;
        }

        .navbar-brand:hover, .navbar-brand:focus {
            text-decoration: none;
        }

        .navbar-nav {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: column;
            flex-direction: column;
            margin-bottom: 0;
            list-style: none;
        }

        html:not([dir="rtl"]) .navbar-nav {
            padding-left: 0;
        }

        *[dir="rtl"] .navbar-nav {
            padding-right: 0;
        }

        .navbar-nav .nav-link {
            padding-right: 0;
            padding-left: 0;
        }

        .navbar-nav .dropdown-menu {
            position: static;
            float: none;
        }

        .navbar-text {
            display: inline-block;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }

        .navbar-collapse {
            -ms-flex-preferred-size: 100%;
            flex-basis: 100%;
            -ms-flex-positive: 1;
            flex-grow: 1;
            -ms-flex-align: center;
            align-items: center;
        }

        .navbar-toggler {
            padding: 0.25rem 0.75rem;
            font-size: 1.09375rem;
            line-height: 1;
            background-color: transparent;
            border: 1px solid transparent;
            border-radius: 0.25rem;
        }

        .navbar-toggler:hover, .navbar-toggler:focus {
            text-decoration: none;
        }

        .navbar-toggler-icon {
            display: inline-block;
            width: 1.5em;
            height: 1.5em;
            vertical-align: middle;
            content: "";
            background: no-repeat center center;
            background-size: 100% 100%;
        }

        @media (max-width: 575.98px) {
            .navbar-expand-sm > .container,
            .navbar-expand-sm > .container-fluid, .navbar-expand-sm > .container-sm, .navbar-expand-sm > .container-md, .navbar-expand-sm > .container-lg, .navbar-expand-sm > .container-xl {
                padding-right: 0;
                padding-left: 0;
            }
        }

        @media (min-width: 576px) {
            .navbar-expand-sm {
                -ms-flex-flow: row nowrap;
                flex-flow: row nowrap;
                -ms-flex-pack: start;
                justify-content: flex-start;
            }
            .navbar-expand-sm .navbar-nav {
                -ms-flex-direction: row;
                flex-direction: row;
            }
            .navbar-expand-sm .navbar-nav .dropdown-menu {
                position: absolute;
            }
            .navbar-expand-sm .navbar-nav .nav-link {
                padding-right: 0.5rem;
                padding-left: 0.5rem;
            }
            .navbar-expand-sm > .container,
            .navbar-expand-sm > .container-fluid, .navbar-expand-sm > .container-sm, .navbar-expand-sm > .container-md, .navbar-expand-sm > .container-lg, .navbar-expand-sm > .container-xl {
                -ms-flex-wrap: nowrap;
                flex-wrap: nowrap;
            }
            .navbar-expand-sm .navbar-collapse {
                display: -ms-flexbox !important;
                display: flex !important;
                -ms-flex-preferred-size: auto;
                flex-basis: auto;
            }
            .navbar-expand-sm .navbar-toggler {
                display: none;
            }
        }

        @media (max-width: 767.98px) {
            .navbar-expand-md > .container,
            .navbar-expand-md > .container-fluid, .navbar-expand-md > .container-sm, .navbar-expand-md > .container-md, .navbar-expand-md > .container-lg, .navbar-expand-md > .container-xl {
                padding-right: 0;
                padding-left: 0;
            }
        }

        @media (min-width: 768px) {
            .navbar-expand-md {
                -ms-flex-flow: row nowrap;
                flex-flow: row nowrap;
                -ms-flex-pack: start;
                justify-content: flex-start;
            }
            .navbar-expand-md .navbar-nav {
                -ms-flex-direction: row;
                flex-direction: row;
            }
            .navbar-expand-md .navbar-nav .dropdown-menu {
                position: absolute;
            }
            .navbar-expand-md .navbar-nav .nav-link {
                padding-right: 0.5rem;
                padding-left: 0.5rem;
            }
            .navbar-expand-md > .container,
            .navbar-expand-md > .container-fluid, .navbar-expand-md > .container-sm, .navbar-expand-md > .container-md, .navbar-expand-md > .container-lg, .navbar-expand-md > .container-xl {
                -ms-flex-wrap: nowrap;
                flex-wrap: nowrap;
            }
            .navbar-expand-md .navbar-collapse {
                display: -ms-flexbox !important;
                display: flex !important;
                -ms-flex-preferred-size: auto;
                flex-basis: auto;
            }
            .navbar-expand-md .navbar-toggler {
                display: none;
            }
        }

        @media (max-width: 991.98px) {
            .navbar-expand-lg > .container,
            .navbar-expand-lg > .container-fluid, .navbar-expand-lg > .container-sm, .navbar-expand-lg > .container-md, .navbar-expand-lg > .container-lg, .navbar-expand-lg > .container-xl {
                padding-right: 0;
                padding-left: 0;
            }
        }

        @media (min-width: 992px) {
            .navbar-expand-lg {
                -ms-flex-flow: row nowrap;
                flex-flow: row nowrap;
                -ms-flex-pack: start;
                justify-content: flex-start;
            }
            .navbar-expand-lg .navbar-nav {
                -ms-flex-direction: row;
                flex-direction: row;
            }
            .navbar-expand-lg .navbar-nav .dropdown-menu {
                position: absolute;
            }
            .navbar-expand-lg .navbar-nav .nav-link {
                padding-right: 0.5rem;
                padding-left: 0.5rem;
            }
            .navbar-expand-lg > .container,
            .navbar-expand-lg > .container-fluid, .navbar-expand-lg > .container-sm, .navbar-expand-lg > .container-md, .navbar-expand-lg > .container-lg, .navbar-expand-lg > .container-xl {
                -ms-flex-wrap: nowrap;
                flex-wrap: nowrap;
            }
            .navbar-expand-lg .navbar-collapse {
                display: -ms-flexbox !important;
                display: flex !important;
                -ms-flex-preferred-size: auto;
                flex-basis: auto;
            }
            .navbar-expand-lg .navbar-toggler {
                display: none;
            }
        }

        @media (max-width: 1199.98px) {
            .navbar-expand-xl > .container,
            .navbar-expand-xl > .container-fluid, .navbar-expand-xl > .container-sm, .navbar-expand-xl > .container-md, .navbar-expand-xl > .container-lg, .navbar-expand-xl > .container-xl {
                padding-right: 0;
                padding-left: 0;
            }
        }

        @media (min-width: 1200px) {
            .navbar-expand-xl {
                -ms-flex-flow: row nowrap;
                flex-flow: row nowrap;
                -ms-flex-pack: start;
                justify-content: flex-start;
            }
            .navbar-expand-xl .navbar-nav {
                -ms-flex-direction: row;
                flex-direction: row;
            }
            .navbar-expand-xl .navbar-nav .dropdown-menu {
                position: absolute;
            }
            .navbar-expand-xl .navbar-nav .nav-link {
                padding-right: 0.5rem;
                padding-left: 0.5rem;
            }
            .navbar-expand-xl > .container,
            .navbar-expand-xl > .container-fluid, .navbar-expand-xl > .container-sm, .navbar-expand-xl > .container-md, .navbar-expand-xl > .container-lg, .navbar-expand-xl > .container-xl {
                -ms-flex-wrap: nowrap;
                flex-wrap: nowrap;
            }
            .navbar-expand-xl .navbar-collapse {
                display: -ms-flexbox !important;
                display: flex !important;
                -ms-flex-preferred-size: auto;
                flex-basis: auto;
            }
            .navbar-expand-xl .navbar-toggler {
                display: none;
            }
        }

        .navbar-expand {
            -ms-flex-flow: row nowrap;
            flex-flow: row nowrap;
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        .navbar-expand > .container,
        .navbar-expand > .container-fluid, .navbar-expand > .container-sm, .navbar-expand > .container-md, .navbar-expand > .container-lg, .navbar-expand > .container-xl {
            padding-right: 0;
            padding-left: 0;
            -ms-flex-wrap: nowrap;
            flex-wrap: nowrap;
        }

        .navbar-expand .navbar-nav {
            -ms-flex-direction: row;
            flex-direction: row;
        }

        .navbar-expand .navbar-nav .dropdown-menu {
            position: absolute;
        }

        .navbar-expand .navbar-nav .nav-link {
            padding-right: 0.5rem;
            padding-left: 0.5rem;
        }

        .navbar-expand .navbar-collapse {
            display: -ms-flexbox !important;
            display: flex !important;
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
        }

        .navbar-expand .navbar-toggler {
            display: none;
        }

        .navbar.navbar-dark .navbar-brand,.navbar.navbar-dark .navbar-brand:hover, .navbar.navbar-dark .navbar-brand:focus {
            color: #fff;
        }

        .navbar.navbar-dark .navbar-nav .nav-link {
            color: rgba(255, 255, 255, 0.5);
        }

        .navbar.navbar-dark .navbar-nav .nav-link:hover, .navbar.navbar-dark .navbar-nav .nav-link:focus {
            color: rgba(255, 255, 255, 0.75);
        }

        .navbar.navbar-dark .navbar-nav .nav-link.disabled {
            color: rgba(255, 255, 255, 0.25);
        }

        .navbar.navbar-dark .navbar-nav .show > .nav-link,
        .navbar.navbar-dark .navbar-nav .active > .nav-link,
        .navbar.navbar-dark .navbar-nav .nav-link.show,
        .navbar.navbar-dark .navbar-nav .nav-link.active {
            color: #fff;
        }

        .navbar.navbar-dark .navbar-toggler {
            color: rgba(255, 255, 255, 0.5);
            border-color: rgba(255, 255, 255, 0.1);
        }

        .navbar.navbar-dark .navbar-toggler-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%28255, 255, 255, 0.5%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
        }

        .navbar.navbar-dark .navbar-text {
            color: rgba(255, 255, 255, 0.5);
        }

        .navbar.navbar-dark .navbar-text a,.navbar.navbar-dark .navbar-text a:hover, .navbar.navbar-dark .navbar-text a:focus {
            color: #fff;
        }

        .navbar.navbar-light .navbar-brand,.navbar.navbar-light .navbar-brand:hover, .navbar.navbar-light .navbar-brand:focus {
            color: rgba(0, 0, 21, 0.9);
        }

        .navbar.navbar-light .navbar-nav .nav-link {
            color: rgba(0, 0, 21, 0.5);
        }

        .navbar.navbar-light .navbar-nav .nav-link:hover, .navbar.navbar-light .navbar-nav .nav-link:focus {
            color: rgba(0, 0, 21, 0.7);
        }

        .navbar.navbar-light .navbar-nav .nav-link.disabled {
            color: rgba(0, 0, 21, 0.3);
        }

        .navbar.navbar-light .navbar-nav .show > .nav-link,
        .navbar.navbar-light .navbar-nav .active > .nav-link,
        .navbar.navbar-light .navbar-nav .nav-link.show,
        .navbar.navbar-light .navbar-nav .nav-link.active {
            color: rgba(0, 0, 21, 0.9);
        }

        .navbar.navbar-light .navbar-toggler {
            color: rgba(0, 0, 21, 0.5);
            border-color: rgba(0, 0, 21, 0.1);
        }

        .navbar.navbar-light .navbar-toggler-icon {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%280, 0, 21, 0.5%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
        }

        .navbar.navbar-light .navbar-text {
            color: rgba(0, 0, 21, 0.5);
        }

        .navbar.navbar-light .navbar-text a,.navbar.navbar-light .navbar-text a:hover, .navbar.navbar-light .navbar-text a:focus {
            color: rgba(0, 0, 21, 0.9);
        }

        .pagination {
            display: -ms-flexbox;
            display: flex;
            list-style: none;
            border-radius: 0.25rem;
        }

        html:not([dir="rtl"]) .pagination {
            padding-left: 0;
        }

        *[dir="rtl"] .pagination {
            padding-right: 0;
        }

        .page-link {
            position: relative;
            display: block;
            padding: 0.5rem 0.75rem;
            line-height: 1.25;
            border: 1px solid;
            color: #321fdb;
            background-color: #fff;
            border-color: #d8dbe0;
        }

        html:not([dir="rtl"]) .page-link {
            margin-left: -1px;
        }

        *[dir="rtl"] .page-link {
            margin-right: -1px;
        }

        .page-link:hover {
            z-index: 2;
            text-decoration: none;
            color: #231698;
            background-color: #d8dbe0;
            border-color: #c4c9d0;
        }

        .page-link:focus {
            z-index: 3;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        html:not([dir="rtl"]) .page-item:first-child .page-link {
            margin-left: 0;
            border-top-left-radius: 0.25rem;
            border-bottom-left-radius: 0.25rem;
        }

        *[dir="rtl"] .page-item:first-child .page-link {
            margin-right: 0;
        }

        *[dir="rtl"] .page-item:first-child .page-link,html:not([dir="rtl"]) .page-item:last-child .page-link {
            border-top-right-radius: 0.25rem;
            border-bottom-right-radius: 0.25rem;
        }

        *[dir="rtl"] .page-item:last-child .page-link {
            border-top-left-radius: 0.25rem;
            border-bottom-left-radius: 0.25rem;
        }

        .page-item.active .page-link {
            z-index: 3;
            color: #fff;
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .page-item.disabled .page-link {
            pointer-events: none;
            cursor: auto;
            color: #8a93a2;
            background-color: #fff;
            border-color: #c4c9d0;
        }

        .pagination-lg .page-link {
            padding: 0.75rem 1.5rem;
            font-size: 1.09375rem;
            line-height: 1.5;
        }

        html:not([dir="rtl"]) .pagination-lg .page-item:first-child .page-link {
            border-top-left-radius: 0.3rem;
            border-bottom-left-radius: 0.3rem;
        }

        *[dir="rtl"] .pagination-lg .page-item:first-child .page-link,html:not([dir="rtl"]) .pagination-lg .page-item:last-child .page-link {
            border-top-right-radius: 0.3rem;
            border-bottom-right-radius: 0.3rem;
        }

        *[dir="rtl"] .pagination-lg .page-item:last-child .page-link {
            border-top-left-radius: 0.3rem;
            border-bottom-left-radius: 0.3rem;
        }

        .pagination-sm .page-link {
            padding: 0.25rem 0.5rem;
            font-size: 0.765625rem;
            line-height: 1.5;
        }

        html:not([dir="rtl"]) .pagination-sm .page-item:first-child .page-link {
            border-top-left-radius: 0.2rem;
            border-bottom-left-radius: 0.2rem;
        }

        *[dir="rtl"] .pagination-sm .page-item:first-child .page-link,html:not([dir="rtl"]) .pagination-sm .page-item:last-child .page-link {
            border-top-right-radius: 0.2rem;
            border-bottom-right-radius: 0.2rem;
        }

        *[dir="rtl"] .pagination-sm .page-item:last-child .page-link {
            border-top-left-radius: 0.2rem;
            border-bottom-left-radius: 0.2rem;
        }

        .popover {
            z-index: 1060;
            display: block;
            max-width: 276px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            font-style: normal;
            font-weight: 400;
            line-height: 1.5;
            text-align: left;
            text-align: start;
            text-decoration: none;
            text-shadow: none;
            text-transform: none;
            letter-spacing: normal;
            word-break: normal;
            word-spacing: normal;
            white-space: normal;
            line-break: auto;
            font-size: 0.765625rem;
            word-wrap: break-word;
            background-clip: padding-box;
            border: 1px solid;
            border-radius: 0.3rem;
            background-color: #fff;
            border-color: rgba(0, 0, 21, 0.2);
        }

        .popover .popover-arrow {
            position: absolute;
            display: block;
        }

        .popover .popover-arrow::before, .popover .popover-arrow::after {
            position: absolute;
            display: block;
            content: "";
            border-color: transparent;
            border-style: solid;
        }

        .popover[data-popper-placement^="top"] .popover-arrow,
        .popover[data-popper-placement^="bottom"] .popover-arrow {
            width: 1.6rem;
            height: 0.5rem;
            padding: 0 0.3rem;
        }

        .popover[data-popper-placement^="right"] .popover-arrow,
        .popover[data-popper-placement^="left"] .popover-arrow {
            width: 0.5rem;
            height: 1.6rem;
            padding: 0.3rem 0;
            margin: 0;
        }

        .popover[data-popper-placement^="top"] {
            margin-bottom: 0.5rem !important;
        }

        .popover[data-popper-placement^="top"] > .popover-arrow {
            bottom: calc(-0.5rem - 1px);
        }

        .popover[data-popper-placement^="top"] > .popover-arrow::before {
            bottom: 0;
            border-width: 0.5rem 0.5rem 0;
            border-top-color: rgba(0, 0, 21, 0.25);
        }

        .popover[data-popper-placement^="top"] > .popover-arrow::after {
            bottom: 1px;
            border-width: 0.5rem 0.5rem 0;
            border-top-color: #fff;
        }

        .popover[data-popper-placement^="right"] {
            margin-left: 0.5rem !important;
        }

        .popover[data-popper-placement^="right"] > .popover-arrow {
            left: calc(-0.5rem - 1px);
        }

        .popover[data-popper-placement^="right"] > .popover-arrow::before {
            left: 0;
            border-width: 0.5rem 0.5rem 0.5rem 0;
            border-right-color: rgba(0, 0, 21, 0.25);
        }

        .popover[data-popper-placement^="right"] > .popover-arrow::after {
            left: 1px;
            border-width: 0.5rem 0.5rem 0.5rem 0;
            border-right-color: #fff;
        }

        .popover[data-popper-placement^="bottom"] {
            margin-top: 0.5rem !important;
        }

        .popover[data-popper-placement^="bottom"] > .popover-arrow {
            top: calc(-0.5rem - 1px);
        }

        .popover[data-popper-placement^="bottom"] > .popover-arrow::before {
            top: 0;
            border-width: 0 0.5rem 0.5rem 0.5rem;
            border-bottom-color: rgba(0, 0, 21, 0.25);
        }

        .popover[data-popper-placement^="bottom"] > .popover-arrow::after {
            top: 1px;
            border-width: 0 0.5rem 0.5rem 0.5rem;
            border-bottom-color: #fff;
        }

        .popover[data-popper-placement^="bottom"] .popover-header::before {
            position: absolute;
            top: 0;
            left: 50%;
            display: block;
            width: 1rem;
            margin-left: -0.5rem;
            content: "";
            border-bottom: 1px solid;
            border-bottom-color: #f7f7f7;
        }

        .popover[data-popper-placement^="left"] {
            margin-left: 0.5rem !important;
        }

        .popover[data-popper-placement^="left"] > .popover-arrow {
            right: calc(-0.5rem - 1px);
        }

        .popover[data-popper-placement^="left"] > .popover-arrow::before {
            right: 0;
            border-width: 0.5rem 0 0.5rem 0.5rem;
            border-left-color: rgba(0, 0, 21, 0.25);
        }

        .popover[data-popper-placement^="left"] > .popover-arrow::after {
            right: 1px;
            border-width: 0.5rem 0 0.5rem 0.5rem;
            border-left-color: #fff;
        }

        .popover-header {
            padding: 0.5rem 0.75rem;
            margin-bottom: 0;
            font-size: 0.875rem;
            border-bottom: 1px solid;
            border-top-left-radius: calc(0.3rem - 1px);
            border-top-right-radius: calc(0.3rem - 1px);
            background-color: #f7f7f7;
            border-bottom-color: #ebebeb;
        }

        .popover-header:empty {
            display: none;
        }

        .popover-body {
            padding: 0.5rem 0.75rem;
            color: #4f5d73;
        }

        @-webkit-keyframes progress-bar-stripes {
            from {
                background-position: 1rem 0;
            }
            to {
                background-position: 0 0;
            }
        }

        @keyframes progress-bar-stripes {
            from {
                background-position: 1rem 0;
            }
            to {
                background-position: 0 0;
            }
        }

        .progress {
            height: 1rem;
            line-height: 0;
            font-size: 0.65625rem;
            border-radius: 0.25rem;
            background-color: #ebedef;
        }

        .progress,.progress-bar {
            display: -ms-flexbox;
            display: flex;
            overflow: hidden;
        }

        .progress-bar {
            -ms-flex-direction: column;
            flex-direction: column;
            -ms-flex-pack: center;
            justify-content: center;
            text-align: center;
            white-space: nowrap;
            transition: width 0.6s ease;
            color: #fff;
            background-color: #321fdb;
        }

        @media (prefers-reduced-motion: reduce) {
            .progress-bar {
                transition: none;
            }
        }

        .progress-bar-striped {
            background-image: linear-gradient(45deg, rgba(255, 255, 255, 0.15) 25%, transparent 25%, transparent 50%, rgba(255, 255, 255, 0.15) 50%, rgba(255, 255, 255, 0.15) 75%, transparent 75%, transparent);
            background-size: 1rem 1rem;
        }

        .progress-bar-animated {
            -webkit-animation: progress-bar-stripes 1s linear infinite;
            animation: progress-bar-stripes 1s linear infinite;
        }

        @media (prefers-reduced-motion: reduce) {
            .progress-bar-animated {
                -webkit-animation: none;
                animation: none;
            }
        }

        .progress-xs {
            height: 4px;
        }

        .progress-sm {
            height: 8px;
        }

        .progress.progress-white {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .progress.progress-white .progress-bar {
            background-color: #fff;
        }

        .progress-group {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-flow: row wrap;
            flex-flow: row wrap;
            margin-bottom: 1rem;
        }

        .progress-group-prepend {
            -ms-flex: 0 0 100px;
            flex: 0 0 100px;
            -ms-flex-item-align: center;
            align-self: center;
        }

        .progress-group-icon {
            font-size: 1.09375rem;
        }

        html:not([dir="rtl"]) .progress-group-icon {
            margin: 0 1rem 0 0.25rem;
        }

        *[dir="rtl"] .progress-group-icon {
            margin: 0 0.25rem 0 1rem;
        }

        .progress-group-text {
            font-size: 0.765625rem;
            color: #768192;
        }

        .progress-group-header {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-preferred-size: 100%;
            flex-basis: 100%;
            -ms-flex-align: end;
            align-items: flex-end;
            margin-bottom: 0.25rem;
        }

        .progress-group-bars {
            -ms-flex-positive: 1;
            flex-grow: 1;
            -ms-flex-item-align: center;
            align-self: center;
        }

        .progress-group-bars .progress:not(:last-child) {
            margin-bottom: 2px;
        }

        .progress-group-header + .progress-group-bars {
            -ms-flex-preferred-size: 100%;
            flex-basis: 100%;
        }

        .c-sidebar {
            display: -ms-flexbox;
            display: flex;
            -ms-flex: 0 0 256px;
            flex: 0 0 256px;
            -ms-flex-direction: column;
            flex-direction: column;
            -ms-flex-order: -1;
            order: -1;
            width: 256px;
            padding: 0;
            box-shadow: none;
            color: #fff;
            background: #3c4b64;
            transition: box-shadow 0.3s 0.15s, margin-left 0.3s, margin-right 0.3s, width 0.3s, z-index 0s ease 0.3s, -webkit-transform 0.3s;
            transition: box-shadow 0.3s 0.15s, transform 0.3s, margin-left 0.3s, margin-right 0.3s, width 0.3s, z-index 0s ease 0.3s;
            transition: box-shadow 0.3s 0.15s, transform 0.3s, margin-left 0.3s, margin-right 0.3s, width 0.3s, z-index 0s ease 0.3s, -webkit-transform 0.3s;
        }

        @media (max-width: 991.98px) {
            .c-sidebar {
                --is-mobile: true;
                position: fixed;
                top: 0;
                bottom: 0;
                z-index: 1031;
            }
        }

        html:not([dir="rtl"]) .c-sidebar:not(.c-sidebar-right) {
            margin-left: -256px;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-right {
            -ms-flex-order: 99;
            order: 99;
            margin-right: -256px;
        }

        *[dir="rtl"] .c-sidebar:not(.c-sidebar-right) {
            margin-right: -256px;
        }

        *[dir="rtl"] .c-sidebar.c-sidebar-right {
            margin-left: -256px;
            border: 0;
        }

        .c-sidebar[class*="bg-"] {
            border-color: rgba(0, 0, 21, 0.1);
        }

        .c-sidebar.c-sidebar-sm {
            -ms-flex: 0 0 192px;
            flex: 0 0 192px;
            width: 192px;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm:not(.c-sidebar-right) {
            margin-left: -192px;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm.c-sidebar-right,*[dir="rtl"] .c-sidebar.c-sidebar-sm:not(.c-sidebar-right) {
            margin-right: -192px;
        }

        *[dir="rtl"] .c-sidebar.c-sidebar-sm.c-sidebar-right {
            margin-left: -192px;
        }

        .c-sidebar.c-sidebar-lg {
            -ms-flex: 0 0 320px;
            flex: 0 0 320px;
            width: 320px;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg:not(.c-sidebar-right) {
            margin-left: -320px;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg.c-sidebar-right,*[dir="rtl"] .c-sidebar.c-sidebar-lg:not(.c-sidebar-right) {
            margin-right: -320px;
        }

        *[dir="rtl"] .c-sidebar.c-sidebar-lg.c-sidebar-right {
            margin-left: -320px;
        }

        .c-sidebar.c-sidebar-xl {
            -ms-flex: 0 0 384px;
            flex: 0 0 384px;
            width: 384px;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl:not(.c-sidebar-right) {
            margin-left: -384px;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl.c-sidebar-right,*[dir="rtl"] .c-sidebar.c-sidebar-xl:not(.c-sidebar-right) {
            margin-right: -384px;
        }

        *[dir="rtl"] .c-sidebar.c-sidebar-xl.c-sidebar-right {
            margin-left: -384px;
        }

        @media (min-width: 992px) {
            .c-sidebar.c-sidebar-fixed {
                position: fixed;
                top: 0;
                bottom: 0;
                z-index: 1030;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-fixed:not(.c-sidebar-right) {
                left: 0;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-fixed.c-sidebar-right,*[dir="rtl"] .c-sidebar.c-sidebar-fixed:not(.c-sidebar-right) {
                right: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-fixed.c-sidebar-right {
                left: 0;
            }
        }

        .c-sidebar.c-sidebar-overlaid {
            position: fixed;
            top: 0;
            bottom: 0;
            z-index: 1032;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-overlaid:not(.c-sidebar-right) {
            left: 0;
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-overlaid.c-sidebar-right,*[dir="rtl"] .c-sidebar.c-sidebar-overlaid:not(.c-sidebar-right) {
            right: 0;
        }

        *[dir="rtl"] .c-sidebar.c-sidebar-overlaid.c-sidebar-right {
            left: 0;
        }

        .c-sidebar-close {
            position: absolute;
            width: 56px;
            height: 56px;
            background: transparent;
            border: 0;
        }

        html:not([dir="rtl"]) .c-sidebar-close {
            right: 0;
        }

        *[dir="rtl"] .c-sidebar-close {
            left: 0;
        }

        .c-sidebar-brand {
            display: -ms-flexbox;
            display: flex;
            -ms-flex: 0 0 56px;
            flex: 0 0 56px;
            -ms-flex-align: center;
            align-items: center;
            -ms-flex-pack: center;
            justify-content: center;
        }

        .c-sidebar-brand .c-sidebar-brand-minimized {
            display: none;
        }

        .c-sidebar-header {
            -ms-flex: 0 0 auto;
            flex: 0 0 auto;
            padding: 0.75rem 1rem;
            text-align: center;
            transition: 0.3s;
        }

        .c-sidebar-nav {
            position: relative;
            display: -ms-flexbox;
            display: flex;
            -ms-flex: 1;
            flex: 1;
            -ms-flex-direction: column;
            flex-direction: column;
            padding: 0;
            margin-bottom: 0;
            overflow-x: hidden;
            overflow-y: auto;
            list-style: none;
        }

        .c-sidebar-nav.ps {
            overflow: -moz-scrollbars-none;
            -ms-overflow-style: none;
        }

        .c-sidebar-nav.ps::-webkit-scrollbar {
            width: 0 !important;
        }

        .c-sidebar-nav-title {
            padding: 0.75rem 1rem;
            margin-top: 1rem;
            font-size: 80%;
            font-weight: 700;
            text-transform: uppercase;
            transition: 0.3s;
        }

        .c-sidebar-nav-divider {
            height: 10px;
            transition: height 0.3s;
        }

        .c-sidebar-nav-item {
            width: inherit;
        }

        .c-sidebar-nav-link, .c-sidebar-nav-dropdown-toggle {
            display: -ms-flexbox;
            display: flex;
            -ms-flex: 1;
            flex: 1;
            -ms-flex-align: center;
            align-items: center;
            padding: 0.8445rem 1rem;
            text-decoration: none;
            white-space: nowrap;
            transition: background 0.3s, color 0.3s;
        }

        html:not([dir="rtl"]) .c-sidebar-nav-link .badge, html:not([dir="rtl"]) .c-sidebar-nav-dropdown-toggle .badge {
            margin-left: auto;
        }

        *[dir="rtl"] .c-sidebar-nav-link .badge, *[dir="rtl"] .c-sidebar-nav-dropdown-toggle .badge {
            margin-right: auto;
        }

        .c-sidebar-nav-link.c-disabled, .c-disabled.c-sidebar-nav-dropdown-toggle {
            cursor: default;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .c-sidebar-nav-link:hover, .c-sidebar-nav-dropdown-toggle:hover {
                text-decoration: none;
            }
        }

        .c-sidebar-nav-icon {
            -ms-flex: 0 0 56px;
            flex: 0 0 56px;
            height: 1.09375rem;
            font-size: 1.09375rem;
            text-align: center;
            transition: 0.3s;
            fill: currentColor;
        }

        html:not([dir="rtl"]) .c-sidebar-nav-icon:first-child {
            margin-left: -1rem;
        }

        *[dir="rtl"] .c-sidebar-nav-icon:first-child {
            margin-right: -1rem;
        }

        .c-sidebar-nav-dropdown {
            position: relative;
            transition: background 0.3s ease-in-out;
        }

        .c-sidebar-nav-dropdown.c-show > .c-sidebar-nav-dropdown-items {
            max-height: 1500px;
        }

        html:not([dir="rtl"]) .c-sidebar-nav-dropdown.c-show > .c-sidebar-nav-dropdown-toggle::after {
            -webkit-transform: rotate(-90deg);
            transform: rotate(-90deg);
        }

        *[dir="rtl"] .c-sidebar-nav-dropdown.c-show > .c-sidebar-nav-dropdown-toggle::after {
            -webkit-transform: rotate(270deg);
            transform: rotate(270deg);
        }

        .c-sidebar-nav-dropdown.c-show + .c-sidebar-nav-dropdown.c-show {
            margin-top: 1px;
        }

        .c-sidebar-nav-dropdown-toggle {
            cursor: pointer;
        }

        .c-sidebar-nav-dropdown-toggle::after {
            display: block;
            -ms-flex: 0 8px;
            flex: 0 8px;
            height: 8px;
            content: "";
            background-repeat: no-repeat;
            background-position: center;
            transition: -webkit-transform 0.3s;
            transition: transform 0.3s;
            transition: transform 0.3s, -webkit-transform 0.3s;
        }

        html:not([dir="rtl"]) .c-sidebar-nav-dropdown-toggle::after {
            margin-left: auto;
        }

        *[dir="rtl"] .c-sidebar-nav-dropdown-toggle::after {
            margin-right: auto;
            -webkit-transform: rotate(180deg);
            transform: rotate(180deg);
        }

        html:not([dir="rtl"]) .c-sidebar-nav-dropdown-toggle .badge {
            margin-right: 1rem;
        }

        *[dir="rtl"] .c-sidebar-nav-dropdown-toggle .badge {
            margin-left: 1rem;
        }

        .c-sidebar-nav-dropdown-items {
            max-height: 0;
            padding: 0;
            overflow-y: hidden;
            list-style: none;
            transition: max-height 0.3s ease-in-out;
        }

        html:not([dir="rtl"]) .c-sidebar-nav-dropdown-items .c-sidebar-nav-link, html:not([dir="rtl"]) .c-sidebar-nav-dropdown-items .c-sidebar-nav-dropdown-toggle {
            padding-left: 56px;
        }

        *[dir="rtl"] .c-sidebar-nav-dropdown-items .c-sidebar-nav-link, *[dir="rtl"] .c-sidebar-nav-dropdown-items .c-sidebar-nav-dropdown-toggle {
            padding-right: 56px;
        }

        html:not([dir="rtl"]) .c-sidebar-nav-dropdown-items .c-sidebar-nav-link .c-sidebar-nav-icon, html:not([dir="rtl"]) .c-sidebar-nav-dropdown-items .c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            margin-left: -56px;
        }

        *[dir="rtl"] .c-sidebar-nav-dropdown-items .c-sidebar-nav-link .c-sidebar-nav-icon, *[dir="rtl"] .c-sidebar-nav-dropdown-items .c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            margin-right: -56px;
        }

        .c-sidebar-nav-label {
            display: -ms-flexbox;
            display: flex;
            padding: 0.211125rem 1rem;
            transition: 0.3s;
        }

        .c-sidebar-nav-label:hover {
            text-decoration: none;
        }

        .c-sidebar-nav-label .c-sidebar-nav-icon {
            margin-top: 1px;
        }

        .c-sidebar-footer {
            -ms-flex: 0 0 auto;
            flex: 0 0 auto;
            padding: 0.75rem 1rem;
            transition: 0.3s;
        }

        .c-sidebar-minimizer {
            display: -ms-flexbox;
            display: flex;
            -ms-flex: 0 0 50px;
            flex: 0 0 50px;
            -ms-flex-pack: end;
            justify-content: flex-end;
            width: inherit;
            padding: 0;
            cursor: pointer;
            border: 0;
        }

        @media (max-width: 991.98px) {
            .c-sidebar-minimizer {
                display: none;
            }
        }

        .c-sidebar-minimizer::before {
            display: block;
            width: 50px;
            height: 50px;
            content: "";
            background-repeat: no-repeat;
            background-position: center;
            background-size: 12.5px;
            transition: 0.3s;
        }

        *[dir="rtl"] .c-sidebar-minimizer::before {
            -webkit-transform: rotate(180deg);
            transform: rotate(180deg);
        }

        .c-sidebar-minimizer:focus, .c-sidebar-minimizer.c-focus {
            outline: 0;
        }

        .c-sidebar-right .c-sidebar-minimizer {
            -ms-flex-pack: start;
            justify-content: flex-start;
        }

        html:not([dir="rtl"]) .c-sidebar-right .c-sidebar-minimizer::before {
            -webkit-transform: rotate(-180deg);
            transform: rotate(-180deg);
        }

        *[dir="rtl"] .c-sidebar-right .c-sidebar-minimizer::before {
            -webkit-transform: rotate(0deg);
            transform: rotate(0deg);
        }

        @media (max-width: 991.98px) {
            .c-sidebar-backdrop {
                position: fixed;
                top: 0;
                left: 0;
                z-index: 1030;
                width: 100vw;
                height: 100vh;
                background-color: #000015;
                transition: 0.3s;
            }
            .c-sidebar-backdrop.c-fade {
                opacity: 0;
            }
            .c-sidebar-backdrop.c-show {
                opacity: 0.5;
            }
        }

        @media (min-width: 992px) {
            .c-sidebar-minimized {
                z-index: 1031;
                -ms-flex: 0 0 56px;
                flex: 0 0 56px;
            }
            .c-sidebar-minimized.c-sidebar-fixed {
                z-index: 1031;
                width: 56px;
            }
            html:not([dir="rtl"]) .c-sidebar-minimized:not(.c-sidebar-right) {
                margin-left: -56px;
            }
            *[dir="rtl"] .c-sidebar-minimized:not(.c-sidebar-right) {
                margin-right: -56px;
            }
            html:not([dir="rtl"]) .c-sidebar-minimized.c-sidebar-right {
                margin-right: -56px;
                margin-left: -56px;
            }
            .c-sidebar-minimized .c-sidebar-brand-full {
                display: none;
            }
            .c-sidebar-minimized .c-sidebar-brand-minimized {
                display: block;
            }
            .c-sidebar-minimized .c-sidebar-nav {
                padding-bottom: 50px;
                overflow: visible;
            }
            .c-sidebar-minimized .c-d-minimized-none,
            .c-sidebar-minimized .c-sidebar-nav-divider,
            .c-sidebar-minimized .c-sidebar-nav-label,
            .c-sidebar-minimized .c-sidebar-nav-title,
            .c-sidebar-minimized .c-sidebar-footer,
            .c-sidebar-minimized .c-sidebar-form,
            .c-sidebar-minimized .c-sidebar-header {
                height: 0;
                padding: 0;
                margin: 0;
                visibility: hidden;
                opacity: 0;
            }
            .c-sidebar-minimized .c-sidebar-minimizer {
                position: fixed;
                bottom: 0;
                width: inherit;
            }
            html:not([dir="rtl"]) .c-sidebar-minimized .c-sidebar-minimizer::before {
                -webkit-transform: rotate(-180deg);
                transform: rotate(-180deg);
            }
            *[dir="rtl"] .c-sidebar-minimized .c-sidebar-minimizer::before,html:not([dir="rtl"]) .c-sidebar-minimized.c-sidebar-right .c-sidebar-minimizer::before {
                -webkit-transform: rotate(0deg);
                transform: rotate(0deg);
            }
            *[dir="rtl"] .c-sidebar-minimized.c-sidebar-right .c-sidebar-minimizer::before {
                -webkit-transform: rotate(180deg);
                transform: rotate(180deg);
            }
            html:not([dir="rtl"]) .c-sidebar-minimized.c-sidebar-right .c-sidebar-nav > .c-sidebar-nav-item:hover, html:not([dir="rtl"])
            .c-sidebar-minimized.c-sidebar-right .c-sidebar-nav > .c-sidebar-nav-dropdown:hover {
                margin-left: -256px;
            }
            *[dir="rtl"] .c-sidebar-minimized.c-sidebar-right .c-sidebar-nav > .c-sidebar-nav-item:hover, *[dir="rtl"]
            .c-sidebar-minimized.c-sidebar-right .c-sidebar-nav > .c-sidebar-nav-dropdown:hover {
                margin-right: -256px;
            }
            .c-sidebar-minimized .c-sidebar-nav-link, .c-sidebar-minimized .c-sidebar-nav-dropdown-toggle,
            .c-sidebar-minimized .c-sidebar-nav-dropdown-toggle {
                overflow: hidden;
                white-space: nowrap;
                border-left: 0;
            }
            .c-sidebar-minimized .c-sidebar-nav-link:hover, .c-sidebar-minimized .c-sidebar-nav-dropdown-toggle:hover,
            .c-sidebar-minimized .c-sidebar-nav-dropdown-toggle:hover {
                width: 312px;
            }
            .c-sidebar-minimized .c-sidebar-nav-dropdown-toggle::after {
                display: none;
            }
            .c-sidebar-minimized .c-sidebar-nav-dropdown-items .c-sidebar-nav-link, .c-sidebar-minimized .c-sidebar-nav-dropdown-items .c-sidebar-nav-dropdown-toggle {
                width: 256px;
            }
            .c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown {
                position: relative;
            }
            .c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown > .c-sidebar-nav-dropdown-items,.c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown > .c-sidebar-nav-dropdown-items .c-sidebar-nav-dropdown:not(.c-show) > .c-sidebar-nav-dropdown-items {
                display: none;
            }
            .c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown .c-sidebar-nav-dropdown-items {
                max-height: 1500px;
            }
            .c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown:hover {
                width: 312px;
                overflow: visible;
            }
            .c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown:hover > .c-sidebar-nav-dropdown-items {
                position: absolute;
                display: inline;
            }
            html:not([dir="rtl"]) .c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown:hover > .c-sidebar-nav-dropdown-items {
                left: 56px;
            }
            *[dir="rtl"] .c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown:hover > .c-sidebar-nav-dropdown-items {
                right: 56px;
            }
            html:not([dir="rtl"]) .c-sidebar-minimized.c-sidebar-right > .c-sidebar-nav-dropdown:hover > .c-sidebar-nav-dropdown-items {
                left: 0;
            }
            *[dir="rtl"] .c-sidebar-minimized.c-sidebar-right > .c-sidebar-nav-dropdown:hover > .c-sidebar-nav-dropdown-items {
                right: 0;
            }
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-show:not(.c-sidebar-right), html:not([dir="rtl"])
        .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
            margin-left: 0;
        }

        *[dir="rtl"] .c-sidebar.c-sidebar-show:not(.c-sidebar-right), *[dir="rtl"]
        .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
            margin-right: 0;
        }

        @media (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-show.c-sidebar-right, html:not([dir="rtl"])
        .c-sidebar.c-sidebar-show.c-sidebar-right {
            margin-right: 0;
        }

        *[dir="rtl"] .c-sidebar.c-sidebar-show.c-sidebar-right, *[dir="rtl"]
        .c-sidebar.c-sidebar-show.c-sidebar-right {
            margin-left: 0;
        }

        @media (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
        }

        @media (min-width: 576px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right), html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
                margin-left: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right), *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
                margin-right: 0;
            }
        }

        @media (min-width: 576px) and (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
        }

        @media (min-width: 576px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show.c-sidebar-right, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right {
                margin-right: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show.c-sidebar-right, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right {
                margin-left: 0;
            }
        }

        @media (min-width: 576px) and (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-sm-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
        }

        @media (min-width: 768px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right), html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
                margin-left: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right), *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
                margin-right: 0;
            }
        }

        @media (min-width: 768px) and (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
        }

        @media (min-width: 768px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show.c-sidebar-right, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right {
                margin-right: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show.c-sidebar-right, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right {
                margin-left: 0;
            }
        }

        @media (min-width: 768px) and (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-md-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
        }

        @media (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right), html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
                margin-left: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right), *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
                margin-right: 0;
            }
        }

        @media (min-width: 992px) and (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
        }

        @media (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show.c-sidebar-right, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right {
                margin-right: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show.c-sidebar-right, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right {
                margin-left: 0;
            }
        }

        @media (min-width: 992px) and (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-lg-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
        }

        @media (min-width: 1200px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right), html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
                margin-left: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right), *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right) {
                margin-right: 0;
            }
        }

        @media (min-width: 1200px) and (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show:not(.c-sidebar-right).c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
        }

        @media (min-width: 1200px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show.c-sidebar-right, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right {
                margin-right: 0;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show.c-sidebar-right, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right {
                margin-left: 0;
            }
        }

        @media (min-width: 1200px) and (min-width: 992px) {
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-right: 256px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed ~ .c-wrapper {
                margin-left: 256px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-right: 192px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-sm ~ .c-wrapper {
                margin-left: 192px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-right: 320px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-lg ~ .c-wrapper {
                margin-left: 320px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-right: 384px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-xl ~ .c-wrapper {
                margin-left: 384px;
            }
            html:not([dir="rtl"]) .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, html:not([dir="rtl"])
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-right: 56px;
            }
            *[dir="rtl"] .c-sidebar.c-sidebar-xl-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper, *[dir="rtl"]
            .c-sidebar.c-sidebar-show.c-sidebar-right.c-sidebar-fixed.c-sidebar-minimized ~ .c-wrapper {
                margin-left: 56px;
            }
        }

        .c-sidebar .c-sidebar-close {
            color: #fff;
        }

        .c-sidebar .c-sidebar-brand {
            color: #fff;
        }

        .c-sidebar .c-sidebar-brand,.c-sidebar .c-sidebar-header {
            background: rgba(0, 0, 21, 0.2);
        }

        .c-sidebar .c-sidebar-form .c-form-control {
            color: #fff;
            background: rgba(0, 0, 21, 0.1);
            border: 0;
        }

        .c-sidebar .c-sidebar-form .c-form-control::-webkit-input-placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-form .c-form-control::-moz-placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-form .c-form-control:-ms-input-placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-form .c-form-control::-ms-input-placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-form .c-form-control::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-title {
            color: rgba(255, 255, 255, 0.6);
        }

        .c-sidebar .c-sidebar-nav-link, .c-sidebar .c-sidebar-nav-dropdown-toggle {
            color: rgba(255, 255, 255, 0.8);
            background: transparent;
        }

        .c-sidebar .c-sidebar-nav-link .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.5);
        }

        .c-sidebar .c-sidebar-nav-link.c-active, .c-sidebar .c-active.c-sidebar-nav-dropdown-toggle {
            color: #fff;
            background: rgba(255, 255, 255, 0.05);
        }

        .c-sidebar .c-sidebar-nav-link.c-active .c-sidebar-nav-icon, .c-sidebar .c-active.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: #fff;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .c-sidebar .c-sidebar-nav-link:hover, .c-sidebar .c-sidebar-nav-dropdown-toggle:hover {
                color: #fff;
                background: #321fdb;
            }
            .c-sidebar .c-sidebar-nav-link:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
                color: #fff;
            }
            .c-sidebar .c-sidebar-nav-link:hover.c-sidebar-nav-dropdown-toggle::after, .c-sidebar :hover.c-sidebar-nav-dropdown-toggle::after {
                background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='%23fff' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
            }
        }

        .c-sidebar .c-sidebar-nav-link.c-disabled, .c-sidebar .c-disabled.c-sidebar-nav-dropdown-toggle {
            color: #b3b2b2;
            background: transparent;
        }

        .c-sidebar .c-sidebar-nav-link.c-disabled .c-sidebar-nav-icon, .c-sidebar .c-disabled.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.5);
        }

        .c-sidebar .c-sidebar-nav-link.c-disabled:hover, .c-sidebar .c-disabled.c-sidebar-nav-dropdown-toggle:hover {
            color: #b3b2b2;
        }

        .c-sidebar .c-sidebar-nav-link.c-disabled:hover .c-sidebar-nav-icon, .c-sidebar .c-disabled.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.5);
        }

        .c-sidebar .c-sidebar-nav-link.c-disabled:hover.c-sidebar-nav-dropdown-toggle::after, .c-sidebar .c-disabled:hover.c-sidebar-nav-dropdown-toggle::after {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='%23fff' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
        }

        .c-sidebar .c-sidebar-nav-dropdown-toggle {
            position: relative;
        }

        .c-sidebar .c-sidebar-nav-dropdown-toggle::after {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='rgba(255, 255, 255, 0.5)' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
        }

        .c-sidebar .c-sidebar-nav-dropdown.c-show {
            background: rgba(0, 0, 0, 0.2);
        }

        .c-sidebar .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-link, .c-sidebar .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-dropdown-toggle {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-link.c-disabled, .c-sidebar .c-sidebar-nav-dropdown.c-show .c-disabled.c-sidebar-nav-dropdown-toggle {
            color: #b3b2b2;
            background: transparent;
        }

        .c-sidebar .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-link.c-disabled:hover, .c-sidebar .c-sidebar-nav-dropdown.c-show .c-disabled.c-sidebar-nav-dropdown-toggle:hover {
            color: #b3b2b2;
        }

        .c-sidebar .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-link.c-disabled:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-dropdown.c-show .c-disabled.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.5);
        }

        .c-sidebar .c-sidebar-nav-label {
            color: rgba(255, 255, 255, 0.6);
        }

        .c-sidebar .c-sidebar-nav-label:hover {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-label .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.5);
        }

        .c-sidebar .c-progress {
            background-color: #596f94 !important;
        }

        .c-sidebar .c-sidebar-footer {
            background: rgba(0, 0, 21, 0.2);
        }

        .c-sidebar .c-sidebar-minimizer {
            background-color: rgba(0, 0, 21, 0.2);
        }

        .c-sidebar .c-sidebar-minimizer::before {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='%238a93a2' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
        }

        .c-sidebar .c-sidebar-minimizer:focus, .c-sidebar .c-sidebar-minimizer.c-focus {
            outline: 0;
        }

        .c-sidebar .c-sidebar-minimizer:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }

        .c-sidebar .c-sidebar-minimizer:hover::before {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='%23fff' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
        }

        .c-sidebar.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-link, .c-sidebar.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-dropdown-toggle {
            background: #321fdb;
        }

        .c-sidebar.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-link .c-sidebar-nav-icon, .c-sidebar.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-link.c-disabled, .c-sidebar.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-disabled.c-sidebar-nav-dropdown-toggle {
            background: #3c4b64;
        }

        .c-sidebar.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-link.c-disabled .c-sidebar-nav-icon, .c-sidebar.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-disabled.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.5);
        }

        .c-sidebar.c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown > .c-sidebar-nav-dropdown-items {
            background: #3c4b64;
        }

        .c-sidebar.c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown:hover {
            background: #321fdb;
        }

        .c-sidebar.c-sidebar-light {
            color: #4f5d73;
            background: #fff;
            border-right: 1px solid rgba(159, 167, 179, 0.5);
        }

        html:not([dir="rtl"]) .c-sidebar.c-sidebar-light.c-sidebar-right,*[dir="rtl"] .c-sidebar.c-sidebar-light {
            border-right: 0;
            border-left: 1px solid rgba(159, 167, 179, 0.5);
        }

        *[dir="rtl"] .c-sidebar.c-sidebar-light.c-sidebar-right {
            border: 0;
            border-right: 1px solid rgba(159, 167, 179, 0.5);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-close {
            color: #4f5d73;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-brand {
            color: #fff;
            background: #321fdb;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-header {
            background: rgba(0, 0, 21, 0.2);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-form .c-form-control {
            color: #fff;
            background: rgba(0, 0, 21, 0.1);
            border: 0;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-form .c-form-control::-webkit-input-placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-form .c-form-control::-moz-placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-form .c-form-control:-ms-input-placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-form .c-form-control::-ms-input-placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-form .c-form-control::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-title {
            color: rgba(0, 0, 21, 0.4);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link, .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown-toggle {
            color: rgba(0, 0, 21, 0.8);
            background: transparent;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link .c-sidebar-nav-icon, .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link.c-active, .c-sidebar.c-sidebar-light .c-active.c-sidebar-nav-dropdown-toggle {
            color: rgba(0, 0, 21, 0.8);
            background: rgba(0, 0, 21, 0.05);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link.c-active .c-sidebar-nav-icon, .c-sidebar.c-sidebar-light .c-active.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: #321fdb;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .c-sidebar.c-sidebar-light .c-sidebar-nav-link:hover, .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown-toggle:hover {
                color: #fff;
                background: #321fdb;
            }
            .c-sidebar.c-sidebar-light .c-sidebar-nav-link:hover .c-sidebar-nav-icon, .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
                color: #fff;
            }
            .c-sidebar.c-sidebar-light .c-sidebar-nav-link:hover.c-sidebar-nav-dropdown-toggle::after, .c-sidebar.c-sidebar-light :hover.c-sidebar-nav-dropdown-toggle::after {
                background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='%23fff' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
            }
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link.c-disabled, .c-sidebar.c-sidebar-light .c-disabled.c-sidebar-nav-dropdown-toggle {
            color: #b3b2b2;
            background: transparent;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link.c-disabled .c-sidebar-nav-icon, .c-sidebar.c-sidebar-light .c-disabled.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link.c-disabled:hover, .c-sidebar.c-sidebar-light .c-disabled.c-sidebar-nav-dropdown-toggle:hover {
            color: #b3b2b2;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link.c-disabled:hover .c-sidebar-nav-icon, .c-sidebar.c-sidebar-light .c-disabled.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-link.c-disabled:hover.c-sidebar-nav-dropdown-toggle::after, .c-sidebar.c-sidebar-light .c-disabled:hover.c-sidebar-nav-dropdown-toggle::after {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='%23fff' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown-toggle {
            position: relative;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown-toggle::after {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='rgba(0, 0, 21, 0.5)' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show {
            background: rgba(0, 0, 0, 0.05);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-link, .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-dropdown-toggle {
            color: rgba(0, 0, 21, 0.8);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-link.c-disabled, .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show .c-disabled.c-sidebar-nav-dropdown-toggle {
            color: #b3b2b2;
            background: transparent;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-link.c-disabled:hover, .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show .c-disabled.c-sidebar-nav-dropdown-toggle:hover {
            color: #b3b2b2;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show .c-sidebar-nav-link.c-disabled:hover .c-sidebar-nav-icon, .c-sidebar.c-sidebar-light .c-sidebar-nav-dropdown.c-show .c-disabled.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-label {
            color: rgba(0, 0, 21, 0.4);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-label:hover {
            color: #4f5d73;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-nav-label .c-sidebar-nav-icon {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-footer {
            background: rgba(0, 0, 21, 0.2);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-minimizer {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-minimizer::before {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='%238a93a2' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
        }

        .c-sidebar.c-sidebar-light .c-sidebar-minimizer:focus, .c-sidebar.c-sidebar-light .c-sidebar-minimizer.c-focus {
            outline: 0;
        }

        .c-sidebar.c-sidebar-light .c-sidebar-minimizer:hover {
            background-color: rgba(0, 0, 0, 0.1);
        }

        .c-sidebar.c-sidebar-light .c-sidebar-minimizer:hover::before {
            background-image: url("data:image/svg+xml;charset=utf8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 11 14'%3E%3Cpath fill='%23768192' d='M9.148 2.352l-4.148 4.148 4.148 4.148q0.148 0.148 0.148 0.352t-0.148 0.352l-1.297 1.297q-0.148 0.148-0.352 0.148t-0.352-0.148l-5.797-5.797q-0.148-0.148-0.148-0.352t0.148-0.352l5.797-5.797q0.148-0.148 0.352-0.148t0.352 0.148l1.297 1.297q0.148 0.148 0.148 0.352t-0.148 0.352z'/%3E%3C/svg%3E");
        }

        .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-link, .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-dropdown-toggle {
            background: #321fdb;
        }

        .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-link .c-sidebar-nav-icon, .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-link.c-disabled, .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-disabled.c-sidebar-nav-dropdown-toggle {
            background: #fff;
        }

        .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-sidebar-nav-link.c-disabled .c-sidebar-nav-icon, .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav-item:hover > .c-disabled.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown > .c-sidebar-nav-dropdown-items {
            background: #fff;
        }

        .c-sidebar.c-sidebar-light.c-sidebar-minimized .c-sidebar-nav > .c-sidebar-nav-dropdown:hover,.c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-primary, .c-sidebar .c-sidebar-nav-link-primary.c-sidebar-nav-dropdown-toggle {
            background: #321fdb;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-primary .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-primary.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-primary:hover, .c-sidebar .c-sidebar-nav-link-primary.c-sidebar-nav-dropdown-toggle:hover {
            background: #2d1cc5;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-primary:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-primary.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-secondary, .c-sidebar .c-sidebar-nav-link-secondary.c-sidebar-nav-dropdown-toggle {
            background: #ced2d8;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-secondary .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-secondary.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-secondary:hover, .c-sidebar .c-sidebar-nav-link-secondary.c-sidebar-nav-dropdown-toggle:hover {
            background: #c0c5cd;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-secondary:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-secondary.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-success, .c-sidebar .c-sidebar-nav-link-success.c-sidebar-nav-dropdown-toggle {
            background: #2eb85c;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-success .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-success.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-success:hover, .c-sidebar .c-sidebar-nav-link-success.c-sidebar-nav-dropdown-toggle:hover {
            background: #29a452;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-success:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-success.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-info, .c-sidebar .c-sidebar-nav-link-info.c-sidebar-nav-dropdown-toggle {
            background: #39f;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-info .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-info.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-info:hover, .c-sidebar .c-sidebar-nav-link-info.c-sidebar-nav-dropdown-toggle:hover {
            background: #1a8cff;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-info:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-info.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-warning, .c-sidebar .c-sidebar-nav-link-warning.c-sidebar-nav-dropdown-toggle {
            background: #f9b115;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-warning .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-warning.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-warning:hover, .c-sidebar .c-sidebar-nav-link-warning.c-sidebar-nav-dropdown-toggle:hover {
            background: #eea506;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-warning:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-warning.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-danger, .c-sidebar .c-sidebar-nav-link-danger.c-sidebar-nav-dropdown-toggle {
            background: #e55353;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-danger .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-danger.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-danger:hover, .c-sidebar .c-sidebar-nav-link-danger.c-sidebar-nav-dropdown-toggle:hover {
            background: #e23d3d;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-danger:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-danger.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-light, .c-sidebar .c-sidebar-nav-link-light.c-sidebar-nav-dropdown-toggle {
            background: #ebedef;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-light .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-light.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-light:hover, .c-sidebar .c-sidebar-nav-link-light.c-sidebar-nav-dropdown-toggle:hover {
            background: #dde0e4;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-light:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-light.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: #fff;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-dark, .c-sidebar .c-sidebar-nav-link-dark.c-sidebar-nav-dropdown-toggle {
            background: #636f83;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-dark .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-dark.c-sidebar-nav-dropdown-toggle .c-sidebar-nav-icon {
            color: rgba(255, 255, 255, 0.7);
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-dark:hover, .c-sidebar .c-sidebar-nav-link-dark.c-sidebar-nav-dropdown-toggle:hover {
            background: #586374;
        }

        .c-sidebar .c-sidebar-nav-link.c-sidebar-nav-link-dark:hover .c-sidebar-nav-icon, .c-sidebar .c-sidebar-nav-link-dark.c-sidebar-nav-dropdown-toggle:hover .c-sidebar-nav-icon {
            color: #fff;
        }

        @-webkit-keyframes spinner-border {
            to {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }

        @keyframes spinner-border {
            to {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }

        .spinner-border {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            border: 0.25em solid currentColor;
            border-right-color: transparent;
            border-radius: 50%;
            -webkit-animation: spinner-border .75s linear infinite;
            animation: spinner-border .75s linear infinite;
        }

        .spinner-border-sm {
            width: 1rem;
            height: 1rem;
            border-width: 0.2em;
        }

        @-webkit-keyframes spinner-grow {
            0% {
                -webkit-transform: scale(0);
                transform: scale(0);
            }
            50% {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
            }
        }

        @keyframes spinner-grow {
            0% {
                -webkit-transform: scale(0);
                transform: scale(0);
            }
            50% {
                opacity: 1;
                -webkit-transform: none;
                transform: none;
            }
        }

        .spinner-grow {
            display: inline-block;
            width: 2rem;
            height: 2rem;
            vertical-align: text-bottom;
            background-color: currentColor;
            border-radius: 50%;
            opacity: 0;
            -webkit-animation: spinner-grow .75s linear infinite;
            animation: spinner-grow .75s linear infinite;
        }

        .spinner-grow-sm {
            width: 1rem;
            height: 1rem;
        }

        .c-subheader {
            position: relative;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: row;
            flex-direction: row;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap;
            width: 100%;
            min-height: 48px;
            background: #fff;
            border-bottom: 1px solid #d8dbe0;
        }

        .c-subheader[class*="bg-"] {
            border-color: rgba(0, 0, 21, 0.1);
        }

        .c-subheader.c-subheader-fixed {
            position: fixed;
            right: 0;
            left: 0;
            z-index: 1030;
        }

        .c-subheader-nav {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: row;
            flex-direction: row;
            -ms-flex-align: center;
            align-items: center;
            min-height: 48px;
            padding: 0;
            margin-bottom: 0;
            list-style: none;
        }

        .c-subheader-nav .c-subheader-nav-item {
            position: relative;
        }

        .c-subheader-nav .c-subheader-nav-btn {
            background-color: transparent;
            border: 1px solid transparent;
        }

        .c-subheader-nav .c-subheader-nav-link,
        .c-subheader-nav .c-subheader-nav-btn {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            padding-right: 0.5rem;
            padding-left: 0.5rem;
        }

        .c-subheader-nav .c-subheader-nav-link .badge,
        .c-subheader-nav .c-subheader-nav-btn .badge {
            position: absolute;
            top: 50%;
            margin-top: -16px;
        }

        html:not([dir="rtl"]) .c-subheader-nav .c-subheader-nav-link .badge, html:not([dir="rtl"])
        .c-subheader-nav .c-subheader-nav-btn .badge {
            left: 50%;
            margin-left: 0;
        }

        *[dir="rtl"] .c-subheader-nav .c-subheader-nav-link .badge, *[dir="rtl"]
        .c-subheader-nav .c-subheader-nav-btn .badge {
            right: 50%;
            margin-right: 0;
        }

        .c-subheader-nav .c-subheader-nav-link:hover,
        .c-subheader-nav .c-subheader-nav-btn:hover {
            text-decoration: none;
        }

        .c-subheader.c-subheader-dark {
            background: #3c4b64;
            border-bottom: 1px solid #636f83;
        }

        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-link,
        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-btn {
            color: rgba(255, 255, 255, 0.75);
        }

        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-link:hover, .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-link:focus,
        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-btn:hover,
        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-btn:focus {
            color: rgba(255, 255, 255, 0.9);
        }

        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-link.c-disabled,
        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-btn.c-disabled {
            color: rgba(255, 255, 255, 0.25);
        }

        .c-subheader.c-subheader-dark .c-subheader-nav .c-show > .c-subheader-nav-link,
        .c-subheader.c-subheader-dark .c-subheader-nav .c-active > .c-subheader-nav-link,
        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-link.c-show,
        .c-subheader.c-subheader-dark .c-subheader-nav .c-subheader-nav-link.c-active {
            color: #fff;
        }

        .c-subheader.c-subheader-dark .c-subheader-text {
            color: rgba(255, 255, 255, 0.75);
        }

        .c-subheader.c-subheader-dark .c-subheader-text a,.c-subheader.c-subheader-dark .c-subheader-text a:hover, .c-subheader.c-subheader-dark .c-subheader-text a:focus {
            color: #fff;
        }

        .c-subheader .c-subheader-nav .c-subheader-nav-link,
        .c-subheader .c-subheader-nav .c-subheader-nav-btn {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-subheader .c-subheader-nav .c-subheader-nav-link:hover, .c-subheader .c-subheader-nav .c-subheader-nav-link:focus,
        .c-subheader .c-subheader-nav .c-subheader-nav-btn:hover,
        .c-subheader .c-subheader-nav .c-subheader-nav-btn:focus {
            color: rgba(0, 0, 21, 0.7);
        }

        .c-subheader .c-subheader-nav .c-subheader-nav-link.c-disabled,
        .c-subheader .c-subheader-nav .c-subheader-nav-btn.c-disabled {
            color: rgba(0, 0, 21, 0.3);
        }

        .c-subheader .c-subheader-nav .c-show > .c-subheader-nav-link,
        .c-subheader .c-subheader-nav .c-active > .c-subheader-nav-link,
        .c-subheader .c-subheader-nav .c-subheader-nav-link.c-show,
        .c-subheader .c-subheader-nav .c-subheader-nav-link.c-active {
            color: rgba(0, 0, 21, 0.9);
        }

        .c-subheader .c-subheader-text {
            color: rgba(0, 0, 21, 0.5);
        }

        .c-subheader .c-subheader-text a,.c-subheader .c-subheader-text a:hover, .c-subheader .c-subheader-text a:focus {
            color: rgba(0, 0, 21, 0.9);
        }

        .c-switch {
            display: inline-block;
            width: 40px;
            height: 26px;
        }

        .c-switch-input {
            position: absolute;
            z-index: -1;
            opacity: 0;
        }

        .c-switch-slider {
            position: relative;
            display: block;
            height: inherit;
            cursor: pointer;
            border: 1px solid #d8dbe0;
            border-radius: 0.25rem;
        }

        .c-switch-slider,.c-switch-slider::before {
            background-color: #fff;
            transition: .15s ease-out;
        }

        .c-switch-slider::before {
            position: absolute;
            top: 2px;
            left: 2px;
            box-sizing: border-box;
            width: 20px;
            height: 20px;
            content: "";
            border: 1px solid #d8dbe0;
            border-radius: 0.125rem;
        }

        .c-switch-input:checked ~ .c-switch-slider::before {
            -webkit-transform: translateX(14px);
            transform: translateX(14px);
        }

        .c-switch-input:focus ~ .c-switch-slider {
            color: #768192;
            background-color: #fff;
            border-color: #958bef;
            outline: 0;
            box-shadow: 0 0 0 0.2rem rgba(50, 31, 219, 0.25);
        }

        .c-switch-input:disabled ~ .c-switch-slider {
            cursor: not-allowed;
            opacity: .5;
        }

        .c-switch-lg {
            width: 48px;
            height: 30px;
        }

        .c-switch-lg .c-switch-slider {
            font-size: 12px;
        }

        .c-switch-lg .c-switch-slider::before {
            width: 24px;
            height: 24px;
        }

        .c-switch-lg .c-switch-slider::after {
            font-size: 12px;
        }

        .c-switch-lg .c-switch-input:checked ~ .c-switch-slider::before {
            -webkit-transform: translateX(18px);
            transform: translateX(18px);
        }

        .c-switch-sm {
            width: 32px;
            height: 22px;
        }

        .c-switch-sm .c-switch-slider {
            font-size: 8px;
        }

        .c-switch-sm .c-switch-slider::before {
            width: 16px;
            height: 16px;
        }

        .c-switch-sm .c-switch-slider::after {
            font-size: 8px;
        }

        .c-switch-sm .c-switch-input:checked ~ .c-switch-slider::before {
            -webkit-transform: translateX(10px);
            transform: translateX(10px);
        }

        .c-switch-label {
            width: 48px;
        }

        .c-switch-label .c-switch-slider::before {
            z-index: 2;
        }

        .c-switch-label .c-switch-slider::after {
            position: absolute;
            top: 50%;
            z-index: 1;
            width: 50%;
            margin-top: -.5em;
            font-size: 10px;
            font-weight: 600;
            line-height: 1;
            color: #c4c9d0;
            text-align: center;
            text-transform: uppercase;
            content: attr(data-unchecked);
            transition: inherit;
        }

        html:not([dir="rtl"]) .c-switch-label .c-switch-slider::after {
            right: 1px;
        }

        .c-switch-label .c-switch-input:checked ~ .c-switch-slider::before {
            -webkit-transform: translateX(22px);
            transform: translateX(22px);
        }

        .c-switch-label .c-switch-input:checked ~ .c-switch-slider::after {
            left: 1px;
            color: #fff;
            content: attr(data-checked);
        }

        .c-switch-label.c-switch-lg {
            width: 56px;
            height: 30px;
        }

        .c-switch-label.c-switch-lg .c-switch-slider {
            font-size: 12px;
        }

        .c-switch-label.c-switch-lg .c-switch-slider::before {
            width: 24px;
            height: 24px;
        }

        .c-switch-label.c-switch-lg .c-switch-slider::after {
            font-size: 12px;
        }

        .c-switch-label.c-switch-lg .c-switch-input:checked ~ .c-switch-slider::before {
            -webkit-transform: translateX(26px);
            transform: translateX(26px);
        }

        .c-switch-label.c-switch-sm {
            width: 40px;
            height: 22px;
        }

        .c-switch-label.c-switch-sm .c-switch-slider {
            font-size: 8px;
        }

        .c-switch-label.c-switch-sm .c-switch-slider::before {
            width: 16px;
            height: 16px;
        }

        .c-switch-label.c-switch-sm .c-switch-slider::after {
            font-size: 8px;
        }

        .c-switch-label.c-switch-sm .c-switch-input:checked ~ .c-switch-slider::before {
            -webkit-transform: translateX(18px);
            transform: translateX(18px);
        }

        .c-switch[class*="-3d"] .c-switch-slider {
            background-color: #ebedef;
            border-radius: 50em;
        }

        .c-switch[class*="-3d"] .c-switch-slider::before {
            top: -1px;
            left: -1px;
            width: 26px;
            height: 26px;
            border: 0;
            border-radius: 50em;
            box-shadow: 0 2px 5px rgba(0, 0, 21, 0.3);
        }

        .c-switch[class*="-3d"].c-switch-lg {
            width: 48px;
            height: 30px;
        }

        .c-switch[class*="-3d"].c-switch-lg .c-switch-slider::before {
            width: 30px;
            height: 30px;
        }

        .c-switch[class*="-3d"].c-switch-lg .c-switch-input:checked ~ .c-switch-slider::before {
            -webkit-transform: translateX(18px);
            transform: translateX(18px);
        }

        .c-switch[class*="-3d"].c-switch-sm {
            width: 32px;
            height: 22px;
        }

        .c-switch[class*="-3d"].c-switch-sm .c-switch-slider::before {
            width: 22px;
            height: 22px;
        }

        .c-switch[class*="-3d"].c-switch-sm .c-switch-input:checked ~ .c-switch-slider::before {
            -webkit-transform: translateX(10px);
            transform: translateX(10px);
        }

        .c-switch-primary .c-switch-input:checked + .c-switch-slider {
            background-color: #321fdb;
            border-color: #2819ae;
        }

        .c-switch-primary .c-switch-input:checked + .c-switch-slider::before {
            border-color: #2819ae;
        }

        .c-switch-3d-primary .c-switch-input:checked + .c-switch-slider {
            background-color: #321fdb;
        }

        .c-switch-outline-primary .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #321fdb;
        }

        .c-switch-outline-primary .c-switch-input:checked + .c-switch-slider::before {
            border-color: #321fdb;
        }

        .c-switch-outline-primary .c-switch-input:checked + .c-switch-slider::after {
            color: #321fdb;
        }

        .c-switch-opposite-primary .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #321fdb;
        }

        .c-switch-opposite-primary .c-switch-input:checked + .c-switch-slider::before {
            background-color: #321fdb;
            border-color: #321fdb;
        }

        .c-switch-opposite-primary .c-switch-input:checked + .c-switch-slider::after {
            color: #321fdb;
        }

        .c-switch-secondary .c-switch-input:checked + .c-switch-slider {
            background-color: #ced2d8;
            border-color: #b2b8c1;
        }

        .c-switch-secondary .c-switch-input:checked + .c-switch-slider::before {
            border-color: #b2b8c1;
        }

        .c-switch-3d-secondary .c-switch-input:checked + .c-switch-slider {
            background-color: #ced2d8;
        }

        .c-switch-outline-secondary .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #ced2d8;
        }

        .c-switch-outline-secondary .c-switch-input:checked + .c-switch-slider::before {
            border-color: #ced2d8;
        }

        .c-switch-outline-secondary .c-switch-input:checked + .c-switch-slider::after {
            color: #ced2d8;
        }

        .c-switch-opposite-secondary .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #ced2d8;
        }

        .c-switch-opposite-secondary .c-switch-input:checked + .c-switch-slider::before {
            background-color: #ced2d8;
            border-color: #ced2d8;
        }

        .c-switch-opposite-secondary .c-switch-input:checked + .c-switch-slider::after {
            color: #ced2d8;
        }

        .c-switch-success .c-switch-input:checked + .c-switch-slider {
            background-color: #2eb85c;
            border-color: #248f48;
        }

        .c-switch-success .c-switch-input:checked + .c-switch-slider::before {
            border-color: #248f48;
        }

        .c-switch-3d-success .c-switch-input:checked + .c-switch-slider {
            background-color: #2eb85c;
        }

        .c-switch-outline-success .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #2eb85c;
        }

        .c-switch-outline-success .c-switch-input:checked + .c-switch-slider::before {
            border-color: #2eb85c;
        }

        .c-switch-outline-success .c-switch-input:checked + .c-switch-slider::after {
            color: #2eb85c;
        }

        .c-switch-opposite-success .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #2eb85c;
        }

        .c-switch-opposite-success .c-switch-input:checked + .c-switch-slider::before {
            background-color: #2eb85c;
            border-color: #2eb85c;
        }

        .c-switch-opposite-success .c-switch-input:checked + .c-switch-slider::after {
            color: #2eb85c;
        }

        .c-switch-info .c-switch-input:checked + .c-switch-slider {
            background-color: #39f;
            border-color: #0080ff;
        }

        .c-switch-info .c-switch-input:checked + .c-switch-slider::before {
            border-color: #0080ff;
        }

        .c-switch-3d-info .c-switch-input:checked + .c-switch-slider {
            background-color: #39f;
        }

        .c-switch-outline-info .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #39f;
        }

        .c-switch-outline-info .c-switch-input:checked + .c-switch-slider::before {
            border-color: #39f;
        }

        .c-switch-outline-info .c-switch-input:checked + .c-switch-slider::after {
            color: #39f;
        }

        .c-switch-opposite-info .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #39f;
        }

        .c-switch-opposite-info .c-switch-input:checked + .c-switch-slider::before {
            background-color: #39f;
            border-color: #39f;
        }

        .c-switch-opposite-info .c-switch-input:checked + .c-switch-slider::after {
            color: #39f;
        }

        .c-switch-warning .c-switch-input:checked + .c-switch-slider {
            background-color: #f9b115;
            border-color: #d69405;
        }

        .c-switch-warning .c-switch-input:checked + .c-switch-slider::before {
            border-color: #d69405;
        }

        .c-switch-3d-warning .c-switch-input:checked + .c-switch-slider {
            background-color: #f9b115;
        }

        .c-switch-outline-warning .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #f9b115;
        }

        .c-switch-outline-warning .c-switch-input:checked + .c-switch-slider::before {
            border-color: #f9b115;
        }

        .c-switch-outline-warning .c-switch-input:checked + .c-switch-slider::after {
            color: #f9b115;
        }

        .c-switch-opposite-warning .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #f9b115;
        }

        .c-switch-opposite-warning .c-switch-input:checked + .c-switch-slider::before {
            background-color: #f9b115;
            border-color: #f9b115;
        }

        .c-switch-opposite-warning .c-switch-input:checked + .c-switch-slider::after {
            color: #f9b115;
        }

        .c-switch-danger .c-switch-input:checked + .c-switch-slider {
            background-color: #e55353;
            border-color: #de2727;
        }

        .c-switch-danger .c-switch-input:checked + .c-switch-slider::before {
            border-color: #de2727;
        }

        .c-switch-3d-danger .c-switch-input:checked + .c-switch-slider {
            background-color: #e55353;
        }

        .c-switch-outline-danger .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #e55353;
        }

        .c-switch-outline-danger .c-switch-input:checked + .c-switch-slider::before {
            border-color: #e55353;
        }

        .c-switch-outline-danger .c-switch-input:checked + .c-switch-slider::after {
            color: #e55353;
        }

        .c-switch-opposite-danger .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #e55353;
        }

        .c-switch-opposite-danger .c-switch-input:checked + .c-switch-slider::before {
            background-color: #e55353;
            border-color: #e55353;
        }

        .c-switch-opposite-danger .c-switch-input:checked + .c-switch-slider::after {
            color: #e55353;
        }

        .c-switch-light .c-switch-input:checked + .c-switch-slider {
            background-color: #ebedef;
            border-color: #cfd4d8;
        }

        .c-switch-light .c-switch-input:checked + .c-switch-slider::before {
            border-color: #cfd4d8;
        }

        .c-switch-3d-light .c-switch-input:checked + .c-switch-slider {
            background-color: #ebedef;
        }

        .c-switch-outline-light .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #ebedef;
        }

        .c-switch-outline-light .c-switch-input:checked + .c-switch-slider::before {
            border-color: #ebedef;
        }

        .c-switch-outline-light .c-switch-input:checked + .c-switch-slider::after {
            color: #ebedef;
        }

        .c-switch-opposite-light .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #ebedef;
        }

        .c-switch-opposite-light .c-switch-input:checked + .c-switch-slider::before {
            background-color: #ebedef;
            border-color: #ebedef;
        }

        .c-switch-opposite-light .c-switch-input:checked + .c-switch-slider::after {
            color: #ebedef;
        }

        .c-switch-dark .c-switch-input:checked + .c-switch-slider {
            background-color: #636f83;
            border-color: #4d5666;
        }

        .c-switch-dark .c-switch-input:checked + .c-switch-slider::before {
            border-color: #4d5666;
        }

        .c-switch-3d-dark .c-switch-input:checked + .c-switch-slider {
            background-color: #636f83;
        }

        .c-switch-outline-dark .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #636f83;
        }

        .c-switch-outline-dark .c-switch-input:checked + .c-switch-slider::before {
            border-color: #636f83;
        }

        .c-switch-outline-dark .c-switch-input:checked + .c-switch-slider::after {
            color: #636f83;
        }

        .c-switch-opposite-dark .c-switch-input:checked + .c-switch-slider {
            background-color: #fff;
            border-color: #636f83;
        }

        .c-switch-opposite-dark .c-switch-input:checked + .c-switch-slider::before {
            background-color: #636f83;
            border-color: #636f83;
        }

        .c-switch-opposite-dark .c-switch-input:checked + .c-switch-slider::after {
            color: #636f83;
        }

        .c-switch-pill .c-switch-slider,.c-switch-pill .c-switch-slider::before {
            border-radius: 50em;
        }

        .c-switch-square .c-switch-slider,.c-switch-square .c-switch-slider::before {
            border-radius: 0;
        }

        .table {
            width: 100%;
            margin-bottom: 1rem;
            color: #4f5d73;
        }

        .table th,
        .table td {
            padding: 0.75rem;
            vertical-align: top;
            border-top: 1px solid;
            border-top-color: #d8dbe0;
        }

        .table thead th {
            vertical-align: bottom;
            border-bottom: 2px solid;
            border-bottom-color: #d8dbe0;
        }

        .table tbody + tbody {
            border-top: 2px solid;
            border-top-color: #d8dbe0;
        }

        .table-sm th,
        .table-sm td {
            padding: 0.3rem;
        }

        .table-bordered,.table-bordered th,
        .table-bordered td {
            border: 1px solid;
            border-color: #d8dbe0;
        }

        .table-bordered thead th,
        .table-bordered thead td {
            border-bottom-width: 2px;
        }

        .table-borderless th,
        .table-borderless td,
        .table-borderless thead th,
        .table-borderless tbody + tbody {
            border: 0;
        }

        .table-striped tbody tr:nth-of-type(odd) {
            background-color: rgba(0, 0, 21, 0.05);
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover tbody tr:hover {
                color: #4f5d73;
                background-color: rgba(0, 0, 21, 0.075);
            }
        }

        .table-primary,
        .table-primary > th,
        .table-primary > td {
            color: #4f5d73;
            background-color: #c6c0f5;
        }

        .table-primary th,
        .table-primary td,
        .table-primary thead th,
        .table-primary tbody + tbody {
            border-color: #948bec;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-primary:hover,.table-hover .table-primary:hover > td,
            .table-hover .table-primary:hover > th {
                background-color: #b2aaf2;
            }
        }

        .table-secondary,
        .table-secondary > th,
        .table-secondary > td {
            color: #4f5d73;
            background-color: #f1f2f4;
        }

        .table-secondary th,
        .table-secondary td,
        .table-secondary thead th,
        .table-secondary tbody + tbody {
            border-color: #e6e8eb;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-secondary:hover,.table-hover .table-secondary:hover > td,
            .table-hover .table-secondary:hover > th {
                background-color: #e3e5e9;
            }
        }

        .table-success,
        .table-success > th,
        .table-success > td {
            color: #4f5d73;
            background-color: #c4ebd1;
        }

        .table-success th,
        .table-success td,
        .table-success thead th,
        .table-success tbody + tbody {
            border-color: #92daaa;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-success:hover,.table-hover .table-success:hover > td,
            .table-hover .table-success:hover > th {
                background-color: #b1e5c2;
            }
        }

        .table-info,
        .table-info > th,
        .table-info > td {
            color: #4f5d73;
            background-color: #c6e2ff;
        }

        .table-info th,
        .table-info td,
        .table-info thead th,
        .table-info tbody + tbody {
            border-color: #95caff;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-info:hover,.table-hover .table-info:hover > td,
            .table-hover .table-info:hover > th {
                background-color: #add5ff;
            }
        }

        .table-warning,
        .table-warning > th,
        .table-warning > td {
            color: #4f5d73;
            background-color: #fde9bd;
        }

        .table-warning th,
        .table-warning td,
        .table-warning thead th,
        .table-warning tbody + tbody {
            border-color: #fcd685;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-warning:hover,.table-hover .table-warning:hover > td,
            .table-hover .table-warning:hover > th {
                background-color: #fce1a4;
            }
        }

        .table-danger,
        .table-danger > th,
        .table-danger > td {
            color: #4f5d73;
            background-color: #f8cfcf;
        }

        .table-danger th,
        .table-danger td,
        .table-danger thead th,
        .table-danger tbody + tbody {
            border-color: #f1a6a6;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-danger:hover,.table-hover .table-danger:hover > td,
            .table-hover .table-danger:hover > th {
                background-color: #f5b9b9;
            }
        }

        .table-light,
        .table-light > th,
        .table-light > td {
            color: #4f5d73;
            background-color: #f9fafb;
        }

        .table-light th,
        .table-light td,
        .table-light thead th,
        .table-light tbody + tbody {
            border-color: #f5f6f7;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-light:hover,.table-hover .table-light:hover > td,
            .table-hover .table-light:hover > th {
                background-color: #eaedf1;
            }
        }

        .table-dark,
        .table-dark > th,
        .table-dark > td {
            color: #4f5d73;
            background-color: #d3d7dc;
        }

        .table-dark th,
        .table-dark td,
        .table-dark thead th,
        .table-dark tbody + tbody {
            border-color: #aeb4bf;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-dark:hover,.table-hover .table-dark:hover > td,
            .table-hover .table-dark:hover > th {
                background-color: #c5cad1;
            }
        }

        .table-active,
        .table-active > th,
        .table-active > td {
            color: #4f5d73;
            background-color: #d8dbe0;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-active:hover,.table-hover .table-active:hover > td,
            .table-hover .table-active:hover > th {
                background-color: #caced5;
            }
        }

        .table-selected,
        .table-selected > th,
        .table-selected > td {
            color: #4f5d73;
            background-color: #d8dbe0;
        }

        .table-selected th,
        .table-selected td,
        .table-selected thead th,
        .table-selected tbody + tbody {
            border-color: #d8dbe0;
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-hover .table-selected:hover,.table-hover .table-selected:hover > td,
            .table-hover .table-selected:hover > th {
                background-color: #caced5;
            }
        }

        .table tbody tr:focus {
            outline: 0;
            color: #4f5d73;
            background-color: rgba(0, 0, 21, 0.075);
        }

        .table .thead-dark th {
            color: #fff;
            background-color: #636f83;
            border-color: #758297;
        }

        .table .thead-light th {
            color: #768192;
            background-color: #d8dbe0;
            border-color: #d8dbe0;
        }

        .table-dark {
            color: #fff;
            background-color: #636f83;
        }

        .table-dark th,
        .table-dark td,
        .table-dark thead th {
            border-color: #758297;
        }

        .table-dark.table-bordered {
            border: 0;
        }

        .table-dark.table-striped tbody tr:nth-of-type(odd) {
            background-color: rgba(255, 255, 255, 0.05);
        }

        @media (hover: hover), (-ms-high-contrast: none) {
            .table-dark.table-hover tbody tr:hover {
                color: #fff;
                background-color: rgba(255, 255, 255, 0.075);
            }
        }

        @media (max-width: 575.98px) {
            .table-responsive-sm {
                display: block;
                width: 100%;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .table-responsive-sm > .table-bordered {
                border: 0;
            }
        }

        @media (max-width: 767.98px) {
            .table-responsive-md {
                display: block;
                width: 100%;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .table-responsive-md > .table-bordered {
                border: 0;
            }
        }

        @media (max-width: 991.98px) {
            .table-responsive-lg {
                display: block;
                width: 100%;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .table-responsive-lg > .table-bordered {
                border: 0;
            }
        }

        @media (max-width: 1199.98px) {
            .table-responsive-xl {
                display: block;
                width: 100%;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .table-responsive-xl > .table-bordered {
                border: 0;
            }
        }

        .table-responsive {
            display: block;
            width: 100%;
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .table-responsive > .table-bordered {
            border: 0;
        }

        .table-outline {
            border: 1px solid;
            border-color: #d8dbe0;
        }

        .table-outline td,.table-align-middle td {
            vertical-align: middle;
        }

        .table-clear td {
            border: 0;
        }

        .toast {
            width: 350px;
            max-width: 350px;
            overflow: hidden;
            font-size: 0.875rem;
            background-clip: padding-box;
            border: 1px solid;
            box-shadow: 0 0.25rem 0.75rem rgba(0, 0, 21, 0.1);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            opacity: 0;
            border-radius: 0.25rem;
            background-color: rgba(255, 255, 255, 0.85);
            border-color: rgba(0, 0, 21, 0.1);
        }

        .toast:not(:last-child) {
            margin-bottom: 0.75rem;
        }

        .toast.showing,.toast.show {
            opacity: 1;
        }

        .toast.show {
            display: block;
        }

        .toast.hide {
            display: none;
        }

        .toast-full {
            width: 100%;
            max-width: 100%;
        }

        .toast-header {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            padding: 0.25rem 0.75rem;
            background-clip: padding-box;
            border-bottom: 1px solid;
            color: #8a93a2;
            background-color: rgba(255, 255, 255, 0.85);
            border-color: rgba(0, 0, 21, 0.05);
        }

        .toast-body {
            padding: 0.75rem;
        }

        .toaster {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: column-reverse;
            flex-direction: column-reverse;
            width: 100%;
            padding: 0.25rem 0.5rem;
        }

        .toaster-top-full, .toaster-top-center, .toaster-top-right, .toaster-top-left, .toaster-bottom-full, .toaster-bottom-center, .toaster-bottom-right, .toaster-bottom-left {
            position: fixed;
            z-index: 1080;
            width: 350px;
        }

        .toaster-top-full, .toaster-top-center, .toaster-top-right, .toaster-top-left {
            top: 0;
        }

        .toaster-bottom-full, .toaster-bottom-center, .toaster-bottom-right, .toaster-bottom-left {
            bottom: 0;
            -ms-flex-direction: column;
            flex-direction: column;
        }

        .toaster-top-full, .toaster-bottom-full {
            width: auto;
        }

        .toaster-top-center, .toaster-bottom-center {
            left: 50%;
            -webkit-transform: translateX(-50%);
            transform: translateX(-50%);
        }

        .toaster-top-full, .toaster-bottom-full, .toaster-top-right, .toaster-bottom-right {
            right: 0;
        }

        .toaster-top-full, .toaster-bottom-full, .toaster-top-left, .toaster-bottom-left {
            left: 0;
        }

        .toaster .toast {
            width: 100%;
            max-width: 100%;
            margin-top: 0.125rem;
            margin-bottom: 0.125rem;
        }

        .tooltip {
            position: absolute;
            z-index: 1070;
            display: block;
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
            font-style: normal;
            font-weight: 400;
            line-height: 1.5;
            text-align: left;
            text-align: start;
            text-decoration: none;
            text-shadow: none;
            text-transform: none;
            letter-spacing: normal;
            word-break: normal;
            word-spacing: normal;
            white-space: normal;
            line-break: auto;
            font-size: 0.765625rem;
            word-wrap: break-word;
            opacity: 0;
        }

        .tooltip.show {
            opacity: 0.9;
        }

        .tooltip .tooltip-arrow {
            position: absolute;
            display: block;
        }

        .tooltip .tooltip-arrow::before {
            position: absolute;
            content: "";
            border-color: transparent;
            border-style: solid;
        }

        .tooltip[data-popper-placement^="top"],
        .tooltip[data-popper-placement^="bottom"] {
            padding: 0.4rem 0;
        }

        .tooltip[data-popper-placement^="top"] .tooltip-arrow,
        .tooltip[data-popper-placement^="bottom"] .tooltip-arrow {
            width: 0.8rem;
            height: 0.4rem;
        }

        .tooltip[data-popper-placement^="right"],
        .tooltip[data-popper-placement^="left"] {
            padding: 0 0.4rem;
        }

        .tooltip[data-popper-placement^="right"] .tooltip-arrow,
        .tooltip[data-popper-placement^="left"] .tooltip-arrow {
            width: 0.4rem;
            height: 0.8rem;
        }

        .tooltip[data-popper-placement^="top"] .tooltip-arrow {
            bottom: 0;
        }

        .tooltip[data-popper-placement^="top"] .tooltip-arrow::before {
            top: 0;
            border-width: 0.4rem 0.4rem 0;
            border-top-color: #000015;
        }

        .tooltip[data-popper-placement^="right"] .tooltip-arrow {
            left: 0;
        }

        .tooltip[data-popper-placement^="right"] .tooltip-arrow::before {
            right: 0;
            border-width: 0.4rem 0.4rem 0.4rem 0;
            border-right-color: #000015;
        }


        .tooltip[data-popper-placement^="bottom"] .tooltip-arrow {
            top: 0;
        }

        .tooltip[data-popper-placement^="bottom"] .tooltip-arrow::before {
            bottom: 0;
            border-width: 0 0.4rem 0.4rem;
            border-bottom-color: #000015;
        }


        .tooltip[data-popper-placement^="left"] .tooltip-arrow {
            right: 0;
        }

        .tooltip[data-popper-placement^="left"] .tooltip-arrow::before {
            left: 0;
            border-width: 0.4rem 0 0.4rem 0.4rem;
            border-left-color: #000015;
        }

        .tooltip-inner {
            max-width: 200px;
            padding: 0.25rem 0.5rem;
            color: #fff;
            text-align: center;
            background-color: #000015;
            border-radius: 0.25rem;
        }

        .fade {
            transition: opacity 0.15s linear;
        }

        @media (prefers-reduced-motion: reduce) {
            .fade {
                transition: none;
            }
        }

        .fade:not(.show) {
            opacity: 0;
        }

        .collapse:not(.show) {
            display: none;
        }

        .collapsing {
            position: relative;
            height: 0;
            overflow: hidden;
            transition: height 0.35s ease;
        }

        @media (prefers-reduced-motion: reduce) {
            .collapsing {
                transition: none;
            }
        }

        @-webkit-keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .fade-in {
            -webkit-animation-name: fadeIn;
            animation-name: fadeIn;
            -webkit-animation-duration: 1s;
            animation-duration: 1s;
        }

        .c-wrapper {
            transition: margin 0.3s;
            display: -ms-flexbox;
            display: flex;
            -ms-flex: 1;
            flex: 1;
            -ms-flex-direction: column;
            flex-direction: column;
            min-width: 0;
            min-height: 100vh;
        }

        .c-sidebar.c-sidebar-unfoldable {
            transition: margin-left 0.3s, margin-right 0.3s, width 0.3s, z-index 0s ease 0s, -webkit-transform 0.3s;
            transition: transform 0.3s, margin-left 0.3s, margin-right 0.3s, width 0.3s, z-index 0s ease 0s;
            transition: transform 0.3s, margin-left 0.3s, margin-right 0.3s, width 0.3s, z-index 0s ease 0s, -webkit-transform 0.3s;
        }

        .c-no-layout-transition .c-wrapper,
        .c-no-layout-transition .c-sidebar,.c-no-layout-transition .c-wrapper .c-sidebar-header,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-title,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-divider,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-link,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-dropdown-toggle,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-icon,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-dropdown,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-dropdown-toggle,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-dropdown-items,
        .c-no-layout-transition .c-wrapper .c-sidebar-nav-label,
        .c-no-layout-transition .c-wrapper .c-sidebar-footer,
        .c-no-layout-transition .c-wrapper .c-sidebar-minimizer,
        .c-no-layout-transition .c-sidebar .c-sidebar-header,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-title,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-divider,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-link,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-dropdown-toggle,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-icon,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-dropdown,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-dropdown-toggle,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-dropdown-items,
        .c-no-layout-transition .c-sidebar .c-sidebar-nav-label,
        .c-no-layout-transition .c-sidebar .c-sidebar-footer,
        .c-no-layout-transition .c-sidebar .c-sidebar-minimizer,.c-no-transition {
            transition: none;
        }

        h1, h2, h3, h4, h5, h6,
        .h1, .h2, .h3, .h4, .h5, .h6 {
            margin-bottom: 0.5rem;
            font-weight: 500;
            line-height: 1.2;
        }

        h1, .h1 {
            font-size: 2.1875rem;
        }

        h2, .h2 {
            font-size: 1.75rem;
        }

        h3, .h3 {
            font-size: 1.53125rem;
        }

        h4, .h4 {
            font-size: 1.3125rem;
        }

        h5, .h5 {
            font-size: 1.09375rem;
        }

        h6, .h6 {
            font-size: 0.875rem;
        }

        .lead {
            font-size: 1.09375rem;
            font-weight: 300;
        }

        .display-1 {
            font-size: 6rem;
        }

        .display-1,.display-2 {
            font-weight: 300;
            line-height: 1.2;
        }

        .display-2 {
            font-size: 5.5rem;
        }

        .display-3 {
            font-size: 4.5rem;
        }

        .display-3,.display-4 {
            font-weight: 300;
            line-height: 1.2;
        }

        .display-4 {
            font-size: 3.5rem;
        }

        .c-vr {
            width: 1px;
            background-color: rgba(0, 0, 21, 0.2);
        }

        small,
        .small {
            font-size: 80%;
            font-weight: 400;
        }

        mark,
        .mark {
            padding: 0.2em;
            background-color: #fcf8e3;
        }

        .list-unstyled {
            list-style: none;
        }

        html:not([dir="rtl"]) .list-unstyled {
            padding-left: 0;
        }

        *[dir="rtl"] .list-unstyled {
            padding-right: 0;
        }

        .list-inline {
            list-style: none;
        }

        html:not([dir="rtl"]) .list-inline {
            padding-left: 0;
        }

        *[dir="rtl"] .list-inline {
            padding-right: 0;
        }

        .list-inline-item {
            display: inline-block;
        }

        .list-inline-item:not(:last-child) {
            margin-right: 0.5rem;
        }

        .initialism {
            font-size: 90%;
            text-transform: uppercase;
        }

        .blockquote {
            margin-bottom: 1rem;
            font-size: 1.09375rem;
        }

        .blockquote-footer {
            display: block;
            font-size: 80%;
            color: #8a93a2;
        }

        .blockquote-footer::before {
            content: "\2014\00A0";
        }

        @media all and (-ms-high-contrast: none) {
            html {
                display: -ms-flexbox;
                display: flex;
                -ms-flex-direction: column;
                flex-direction: column;
            }
        }

        .c-wrapper:not(.c-wrapper-fluid) .c-subheader-fixed {
            position: relative;
        }

        .c-wrapper:not(.c-wrapper-fluid) .c-header-fixed {
            position: -webkit-sticky;
            position: sticky;
            top: 0;
        }

        @media all and (-ms-high-contrast: none) {
            .c-wrapper:not(.c-wrapper-fluid) .c-header-fixed {
                position: fixed;
                margin: inherit;
            }
            .c-wrapper:not(.c-wrapper-fluid) .c-header-fixed ~ .c-body {
                margin-top: 104px;
            }
        }

        .c-wrapper:not(.c-wrapper-fluid) .c-footer-fixed {
            position: -webkit-sticky;
            position: sticky;
            bottom: 0;
        }

        @media all and (-ms-high-contrast: none) {
            .c-wrapper:not(.c-wrapper-fluid) .c-footer-fixed {
                position: fixed;
                margin: inherit;
            }
            .c-wrapper:not(.c-wrapper-fluid) .c-footer-fixed ~ .c-body {
                margin-bottom: 49px;
            }
        }

        .c-wrapper:not(.c-wrapper-fluid) .c-body {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-direction: column;
            flex-direction: column;
            -ms-flex-positive: 1;
            flex-grow: 1;
        }

        .c-wrapper.c-wrapper-fluid {
            min-height: 100vh;
        }

        .c-wrapper.c-wrapper-fluid .c-header-fixed {
            margin: inherit;
        }

        .c-main {
            -ms-flex-preferred-size: auto;
            flex-basis: auto;
            -ms-flex-negative: 0;
            flex-shrink: 0;
            -ms-flex-positive: 1;
            flex-grow: 1;
            min-width: 0;
            padding-top: 2rem;
        }

        @media (min-width: 768px) {
            .c-main > .container-fluid, .c-main > .container-sm, .c-main > .container-md, .c-main > .container-lg, .c-main > .container-xl {
                padding-right: 30px;
                padding-left: 30px;
            }
        }

        .align-baseline {
            vertical-align: baseline !important;
        }

        .align-top {
            vertical-align: top !important;
        }

        .align-middle {
            vertical-align: middle !important;
        }

        .align-bottom {
            vertical-align: bottom !important;
        }

        .align-text-bottom {
            vertical-align: text-bottom !important;
        }

        .align-text-top {
            vertical-align: text-top !important;
        }

        .bg-primary {
            background-color: #321fdb !important;
        }

        a.bg-primary:hover, a.bg-primary:focus,
        button.bg-primary:hover,
        button.bg-primary:focus {
            background-color: #2819ae !important;
        }

        .bg-secondary {
            background-color: #ced2d8 !important;
        }

        a.bg-secondary:hover, a.bg-secondary:focus,
        button.bg-secondary:hover,
        button.bg-secondary:focus {
            background-color: #b2b8c1 !important;
        }

        .bg-success {
            background-color: #2eb85c !important;
        }

        a.bg-success:hover, a.bg-success:focus,
        button.bg-success:hover,
        button.bg-success:focus {
            background-color: #248f48 !important;
        }

        .bg-info {
            background-color: #39f !important;
        }

        a.bg-info:hover, a.bg-info:focus,
        button.bg-info:hover,
        button.bg-info:focus {
            background-color: #0080ff !important;
        }

        .bg-warning {
            background-color: #f9b115 !important;
        }

        a.bg-warning:hover, a.bg-warning:focus,
        button.bg-warning:hover,
        button.bg-warning:focus {
            background-color: #d69405 !important;
        }

        .bg-danger {
            background-color: #e55353 !important;
        }

        a.bg-danger:hover, a.bg-danger:focus,
        button.bg-danger:hover,
        button.bg-danger:focus {
            background-color: #de2727 !important;
        }

        .bg-light {
            background-color: #ebedef !important;
        }

        a.bg-light:hover, a.bg-light:focus,
        button.bg-light:hover,
        button.bg-light:focus {
            background-color: #cfd4d8 !important;
        }

        .bg-dark {
            background-color: #636f83 !important;
        }

        a.bg-dark:hover, a.bg-dark:focus,
        button.bg-dark:hover,
        button.bg-dark:focus {
            background-color: #4d5666 !important;
        }

        .bg-gradient-primary {
            background: #1f1498 !important;
            background: linear-gradient(45deg, #321fdb 0%, #1f1498 100%) !important;
            border-color: #1f1498 !important;
        }

        .bg-gradient-secondary {
            background: #fff !important;
            background: linear-gradient(45deg, #c8d2dc 0%, #fff 100%) !important;
            border-color: #fff !important;
        }

        .bg-gradient-success {
            background: #1b9e3e !important;
            background: linear-gradient(45deg, #2eb85c 0%, #1b9e3e 100%) !important;
            border-color: #1b9e3e !important;
        }

        .bg-gradient-info {
            background: #2982cc !important;
            background: linear-gradient(45deg, #39f 0%, #2982cc 100%) !important;
            border-color: #2982cc !important;
        }

        .bg-gradient-warning {
            background: #f6960b !important;
            background: linear-gradient(45deg, #f9b115 0%, #f6960b 100%) !important;
            border-color: #f6960b !important;
        }

        .bg-gradient-danger {
            background: #d93737 !important;
            background: linear-gradient(45deg, #e55353 0%, #d93737 100%) !important;
            border-color: #d93737 !important;
        }

        .bg-gradient-light {
            background: #fff !important;
            background: linear-gradient(45deg, #e3e8ed 0%, #fff 100%) !important;
            border-color: #fff !important;
        }

        .bg-gradient-dark {
            background: #212333 !important;
            background: linear-gradient(45deg, #3c4b64 0%, #212333 100%) !important;
            border-color: #212333 !important;
        }

        .bg-white {
            background-color: #fff !important;
        }

        .bg-transparent {
            background-color: transparent !important;
        }

        [class^="bg-"] {
            color: #fff;
        }

        .bg-facebook {
            background-color: #3b5998 !important;
        }

        a.bg-facebook:hover, a.bg-facebook:focus,
        button.bg-facebook:hover,
        button.bg-facebook:focus {
            background-color: #2d4373 !important;
        }

        .bg-twitter {
            background-color: #00aced !important;
        }

        a.bg-twitter:hover, a.bg-twitter:focus,
        button.bg-twitter:hover,
        button.bg-twitter:focus {
            background-color: #0087ba !important;
        }

        .bg-linkedin {
            background-color: #4875b4 !important;
        }

        a.bg-linkedin:hover, a.bg-linkedin:focus,
        button.bg-linkedin:hover,
        button.bg-linkedin:focus {
            background-color: #395d90 !important;
        }

        .bg-flickr {
            background-color: #ff0084 !important;
        }

        a.bg-flickr:hover, a.bg-flickr:focus,
        button.bg-flickr:hover,
        button.bg-flickr:focus {
            background-color: #cc006a !important;
        }

        .bg-tumblr {
            background-color: #32506d !important;
        }

        a.bg-tumblr:hover, a.bg-tumblr:focus,
        button.bg-tumblr:hover,
        button.bg-tumblr:focus {
            background-color: #22364a !important;
        }

        .bg-xing {
            background-color: #026466 !important;
        }

        a.bg-xing:hover, a.bg-xing:focus,
        button.bg-xing:hover,
        button.bg-xing:focus {
            background-color: #013334 !important;
        }

        .bg-github {
            background-color: #4183c4 !important;
        }

        a.bg-github:hover, a.bg-github:focus,
        button.bg-github:hover,
        button.bg-github:focus {
            background-color: #3269a0 !important;
        }

        .bg-stack-overflow {
            background-color: #fe7a15 !important;
        }

        a.bg-stack-overflow:hover, a.bg-stack-overflow:focus,
        button.bg-stack-overflow:hover,
        button.bg-stack-overflow:focus {
            background-color: #df6101 !important;
        }

        .bg-youtube {
            background-color: #b00 !important;
        }

        a.bg-youtube:hover, a.bg-youtube:focus,
        button.bg-youtube:hover,
        button.bg-youtube:focus {
            background-color: #880000 !important;
        }

        .bg-dribbble {
            background-color: #ea4c89 !important;
        }

        a.bg-dribbble:hover, a.bg-dribbble:focus,
        button.bg-dribbble:hover,
        button.bg-dribbble:focus {
            background-color: #e51e6b !important;
        }

        .bg-instagram {
            background-color: #517fa4 !important;
        }

        a.bg-instagram:hover, a.bg-instagram:focus,
        button.bg-instagram:hover,
        button.bg-instagram:focus {
            background-color: #406582 !important;
        }

        .bg-pinterest {
            background-color: #cb2027 !important;
        }

        a.bg-pinterest:hover, a.bg-pinterest:focus,
        button.bg-pinterest:hover,
        button.bg-pinterest:focus {
            background-color: #9f191f !important;
        }

        .bg-vk {
            background-color: #45668e !important;
        }

        a.bg-vk:hover, a.bg-vk:focus,
        button.bg-vk:hover,
        button.bg-vk:focus {
            background-color: #344d6c !important;
        }

        .bg-yahoo {
            background-color: #400191 !important;
        }

        a.bg-yahoo:hover, a.bg-yahoo:focus,
        button.bg-yahoo:hover,
        button.bg-yahoo:focus {
            background-color: #2a015e !important;
        }

        .bg-behance {
            background-color: #1769ff !important;
        }

        a.bg-behance:hover, a.bg-behance:focus,
        button.bg-behance:hover,
        button.bg-behance:focus {
            background-color: #0050e3 !important;
        }

        .bg-reddit {
            background-color: #ff4500 !important;
        }

        a.bg-reddit:hover, a.bg-reddit:focus,
        button.bg-reddit:hover,
        button.bg-reddit:focus {
            background-color: #cc3700 !important;
        }

        .bg-vimeo {
            background-color: #aad450 !important;
        }

        a.bg-vimeo:hover, a.bg-vimeo:focus,
        button.bg-vimeo:hover,
        button.bg-vimeo:focus {
            background-color: #93c130 !important;
        }

        .bg-gray-100 {
            background-color: #ebedef !important;
        }

        a.bg-gray-100:hover, a.bg-gray-100:focus,
        button.bg-gray-100:hover,
        button.bg-gray-100:focus {
            background-color: #cfd4d8 !important;
        }

        .bg-gray-200 {
            background-color: #d8dbe0 !important;
        }

        a.bg-gray-200:hover, a.bg-gray-200:focus,
        button.bg-gray-200:hover,
        button.bg-gray-200:focus {
            background-color: #bcc1c9 !important;
        }

        .bg-gray-300 {
            background-color: #c4c9d0 !important;
        }

        a.bg-gray-300:hover, a.bg-gray-300:focus,
        button.bg-gray-300:hover,
        button.bg-gray-300:focus {
            background-color: #a8afb9 !important;
        }

        .bg-gray-400 {
            background-color: #b1b7c1 !important;
        }

        a.bg-gray-400:hover, a.bg-gray-400:focus,
        button.bg-gray-400:hover,
        button.bg-gray-400:focus {
            background-color: #959daa !important;
        }

        .bg-gray-500 {
            background-color: #9da5b1 !important;
        }

        a.bg-gray-500:hover, a.bg-gray-500:focus,
        button.bg-gray-500:hover,
        button.bg-gray-500:focus {
            background-color: #818b9a !important;
        }

        .bg-gray-600 {
            background-color: #8a93a2 !important;
        }

        a.bg-gray-600:hover, a.bg-gray-600:focus,
        button.bg-gray-600:hover,
        button.bg-gray-600:focus {
            background-color: #6e798b !important;
        }

        .bg-gray-700 {
            background-color: #768192 !important;
        }

        a.bg-gray-700:hover, a.bg-gray-700:focus,
        button.bg-gray-700:hover,
        button.bg-gray-700:focus {
            background-color: #5e6877 !important;
        }

        .bg-gray-800 {
            background-color: #636f83 !important;
        }

        a.bg-gray-800:hover, a.bg-gray-800:focus,
        button.bg-gray-800:hover,
        button.bg-gray-800:focus {
            background-color: #4d5666 !important;
        }

        .bg-gray-900 {
            background-color: #4f5d73 !important;
        }

        a.bg-gray-900:hover, a.bg-gray-900:focus,
        button.bg-gray-900:hover,
        button.bg-gray-900:focus {
            background-color: #3a4555 !important;
        }

        .bg-box {
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            -ms-flex-pack: center;
            justify-content: center;
            width: 2.5rem;
            height: 2.5rem;
        }

        .border {
            border: 1px solid #d8dbe0 !important;
        }

        .border-top {
            border-top: 1px solid #d8dbe0 !important;
        }

        .border-right {
            border-right: 1px solid #d8dbe0 !important;
        }

        .border-bottom {
            border-bottom: 1px solid #d8dbe0 !important;
        }

        .border-left {
            border-left: 1px solid #d8dbe0 !important;
        }

        .border-0 {
            border: 0 !important;
        }

        .border-top-0 {
            border-top: 0 !important;
        }

        .border-right-0 {
            border-right: 0 !important;
        }

        .border-bottom-0 {
            border-bottom: 0 !important;
        }

        .border-left-0 {
            border-left: 0 !important;
        }

        .border-primary {
            border: 1px solid !important;
            border-color: #321fdb !important;
        }

        .border-secondary {
            border: 1px solid !important;
            border-color: #ced2d8 !important;
        }

        .border-success {
            border: 1px solid !important;
            border-color: #2eb85c !important;
        }

        .border-info {
            border: 1px solid !important;
            border-color: #39f !important;
        }

        .border-warning {
            border: 1px solid !important;
            border-color: #f9b115 !important;
        }

        .border-danger {
            border: 1px solid !important;
            border-color: #e55353 !important;
        }

        .border-light {
            border: 1px solid !important;
            border-color: #ebedef !important;
        }

        .border-dark {
            border: 1px solid !important;
            border-color: #636f83 !important;
        }

        .border-white {
            border-color: #fff !important;
        }

        .rounded-sm {
            border-radius: 0.2rem !important;
        }

        .rounded {
            border-radius: 0.25rem !important;
        }

        .rounded-top {
            border-top-left-radius: 0.25rem !important;
        }

        .rounded-top,.rounded-right {
            border-top-right-radius: 0.25rem !important;
        }

        .rounded-right,.rounded-bottom {
            border-bottom-right-radius: 0.25rem !important;
        }

        .rounded-bottom,.rounded-left {
            border-bottom-left-radius: 0.25rem !important;
        }

        .rounded-left {
            border-top-left-radius: 0.25rem !important;
        }

        .rounded-lg {
            border-radius: 0.3rem !important;
        }

        .rounded-circle {
            border-radius: 50% !important;
        }

        .rounded-pill {
            border-radius: 50rem !important;
        }

        .rounded-0 {
            border-radius: 0 !important;
        }

        .b-a-0 {
            border: 0 !important;
        }

        .b-t-0 {
            border-top: 0 !important;
        }

        .b-r-0 {
            border-right: 0 !important;
        }

        .b-b-0 {
            border-bottom: 0 !important;
        }

        .b-l-0 {
            border-left: 0 !important;
        }

        .b-a-1 {
            border: 1px solid #d8dbe0;
        }

        .b-t-1 {
            border-top: 1px solid #d8dbe0;
        }

        .b-r-1 {
            border-right: 1px solid #d8dbe0;
        }

        .b-b-1 {
            border-bottom: 1px solid #d8dbe0;
        }

        .b-l-1 {
            border-left: 1px solid #d8dbe0;
        }

        .b-a-2 {
            border: 2px solid #d8dbe0;
        }

        .b-t-2 {
            border-top: 2px solid #d8dbe0;
        }

        .b-r-2 {
            border-right: 2px solid #d8dbe0;
        }

        .b-b-2 {
            border-bottom: 2px solid #d8dbe0;
        }

        .b-l-2 {
            border-left: 2px solid #d8dbe0;
        }

        .content-center {
            position: relative;
            display: -ms-flexbox;
            display: flex;
            -ms-flex-align: center;
            align-items: center;
            -ms-flex-pack: center;
            justify-content: center;
            padding: 0;
            text-align: center;
        }

        .clearfix::after {
            display: block;
            clear: both;
            content: "";
        }

        .d-none {
            display: none !important;
        }

        .d-inline {
            display: inline !important;
        }

        .d-inline-block {
            display: inline-block !important;
        }

        .d-block {
            display: block !important;
        }

        .d-table {
            display: table !important;
        }

        .d-table-row {
            display: table-row !important;
        }

        .d-table-cell {
            display: table-cell !important;
        }

        .d-flex {
            display: -ms-flexbox !important;
            display: flex !important;
        }

        .d-inline-flex {
            display: -ms-inline-flexbox !important;
            display: inline-flex !important;
        }

        @media (min-width: 576px) {
            .d-sm-none {
                display: none !important;
            }
            .d-sm-inline {
                display: inline !important;
            }
            .d-sm-inline-block {
                display: inline-block !important;
            }
            .d-sm-block {
                display: block !important;
            }
            .d-sm-table {
                display: table !important;
            }
            .d-sm-table-row {
                display: table-row !important;
            }
            .d-sm-table-cell {
                display: table-cell !important;
            }
            .d-sm-flex {
                display: -ms-flexbox !important;
                display: flex !important;
            }
            .d-sm-inline-flex {
                display: -ms-inline-flexbox !important;
                display: inline-flex !important;
            }
        }

        @media (min-width: 768px) {
            .d-md-none {
                display: none !important;
            }
            .d-md-inline {
                display: inline !important;
            }
            .d-md-inline-block {
                display: inline-block !important;
            }
            .d-md-block {
                display: block !important;
            }
            .d-md-table {
                display: table !important;
            }
            .d-md-table-row {
                display: table-row !important;
            }
            .d-md-table-cell {
                display: table-cell !important;
            }
            .d-md-flex {
                display: -ms-flexbox !important;
                display: flex !important;
            }
            .d-md-inline-flex {
                display: -ms-inline-flexbox !important;
                display: inline-flex !important;
            }
        }

        @media (min-width: 992px) {
            .d-lg-none {
                display: none !important;
            }
            .d-lg-inline {
                display: inline !important;
            }
            .d-lg-inline-block {
                display: inline-block !important;
            }
            .d-lg-block {
                display: block !important;
            }
            .d-lg-table {
                display: table !important;
            }
            .d-lg-table-row {
                display: table-row !important;
            }
            .d-lg-table-cell {
                display: table-cell !important;
            }
            .d-lg-flex {
                display: -ms-flexbox !important;
                display: flex !important;
            }
            .d-lg-inline-flex {
                display: -ms-inline-flexbox !important;
                display: inline-flex !important;
            }
        }

        @media (min-width: 1200px) {
            .d-xl-none {
                display: none !important;
            }
            .d-xl-inline {
                display: inline !important;
            }
            .d-xl-inline-block {
                display: inline-block !important;
            }
            .d-xl-block {
                display: block !important;
            }
            .d-xl-table {
                display: table !important;
            }
            .d-xl-table-row {
                display: table-row !important;
            }
            .d-xl-table-cell {
                display: table-cell !important;
            }
            .d-xl-flex {
                display: -ms-flexbox !important;
                display: flex !important;
            }
            .d-xl-inline-flex {
                display: -ms-inline-flexbox !important;
                display: inline-flex !important;
            }
        }

        @media (max-width: 575.98px) {
            .d-down-none {
                display: none !important;
            }
        }

        @media (max-width: 767.98px) {
            .d-sm-down-none {
                display: none !important;
            }
        }

        @media (max-width: 991.98px) {
            .d-md-down-none {
                display: none !important;
            }
        }

        @media (max-width: 1199.98px) {
            .d-lg-down-none {
                display: none !important;
            }
        }

        .d-xl-down-none,.c-default-theme .c-d-default-none {
            display: none !important;
        }

        @media print {
            .d-print-none {
                display: none !important;
            }
            .d-print-inline {
                display: inline !important;
            }
            .d-print-inline-block {
                display: inline-block !important;
            }
            .d-print-block {
                display: block !important;
            }
            .d-print-table {
                display: table !important;
            }
            .d-print-table-row {
                display: table-row !important;
            }
            .d-print-table-cell {
                display: table-cell !important;
            }
            .d-print-flex {
                display: -ms-flexbox !important;
                display: flex !important;
            }
            .d-print-inline-flex {
                display: -ms-inline-flexbox !important;
                display: inline-flex !important;
            }
        }

        .embed-responsive {
            position: relative;
            display: block;
            width: 100%;
            padding: 0;
            overflow: hidden;
        }

        .embed-responsive::before {
            display: block;
            content: "";
        }

        .embed-responsive .embed-responsive-item,
        .embed-responsive iframe,
        .embed-responsive embed,
        .embed-responsive object,
        .embed-responsive video {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border: 0;
        }

        .embed-responsive-21by9::before {
            padding-top: 42.85714286%;
        }

        .embed-responsive-16by9::before {
            padding-top: 56.25%;
        }

        .embed-responsive-4by3::before {
            padding-top: 75%;
        }

        .embed-responsive-1by1::before {
            padding-top: 100%;
        }

        .flex-row {
            -ms-flex-direction: row !important;
            flex-direction: row !important;
        }

        .flex-column {
            -ms-flex-direction: column !important;
            flex-direction: column !important;
        }

        .flex-row-reverse {
            -ms-flex-direction: row-reverse !important;
            flex-direction: row-reverse !important;
        }

        .flex-column-reverse {
            -ms-flex-direction: column-reverse !important;
            flex-direction: column-reverse !important;
        }

        .flex-wrap {
            -ms-flex-wrap: wrap !important;
            flex-wrap: wrap !important;
        }

        .flex-nowrap {
            -ms-flex-wrap: nowrap !important;
            flex-wrap: nowrap !important;
        }

        .flex-wrap-reverse {
            -ms-flex-wrap: wrap-reverse !important;
            flex-wrap: wrap-reverse !important;
        }

        .flex-fill {
            -ms-flex: 1 1 auto !important;
            flex: 1 1 auto !important;
        }

        .flex-grow-0 {
            -ms-flex-positive: 0 !important;
            flex-grow: 0 !important;
        }

        .flex-grow-1 {
            -ms-flex-positive: 1 !important;
            flex-grow: 1 !important;
        }

        .flex-shrink-0 {
            -ms-flex-negative: 0 !important;
            flex-shrink: 0 !important;
        }

        .flex-shrink-1 {
            -ms-flex-negative: 1 !important;
            flex-shrink: 1 !important;
        }

        .justify-content-start {
            -ms-flex-pack: start !important;
            justify-content: flex-start !important;
        }

        .justify-content-end {
            -ms-flex-pack: end !important;
            justify-content: flex-end !important;
        }

        .justify-content-center {
            -ms-flex-pack: center !important;
            justify-content: center !important;
        }

        .justify-content-between {
            -ms-flex-pack: justify !important;
            justify-content: space-between !important;
        }

        .justify-content-around {
            -ms-flex-pack: distribute !important;
            justify-content: space-around !important;
        }

        .align-items-start {
            -ms-flex-align: start !important;
            align-items: flex-start !important;
        }

        .align-items-end {
            -ms-flex-align: end !important;
            align-items: flex-end !important;
        }

        .align-items-center {
            -ms-flex-align: center !important;
            align-items: center !important;
        }

        .align-items-baseline {
            -ms-flex-align: baseline !important;
            align-items: baseline !important;
        }

        .align-items-stretch {
            -ms-flex-align: stretch !important;
            align-items: stretch !important;
        }

        .align-content-start {
            -ms-flex-line-pack: start !important;
            align-content: flex-start !important;
        }

        .align-content-end {
            -ms-flex-line-pack: end !important;
            align-content: flex-end !important;
        }

        .align-content-center {
            -ms-flex-line-pack: center !important;
            align-content: center !important;
        }

        .align-content-between {
            -ms-flex-line-pack: justify !important;
            align-content: space-between !important;
        }

        .align-content-around {
            -ms-flex-line-pack: distribute !important;
            align-content: space-around !important;
        }

        .align-content-stretch {
            -ms-flex-line-pack: stretch !important;
            align-content: stretch !important;
        }

        .align-self-auto {
            -ms-flex-item-align: auto !important;
            align-self: auto !important;
        }

        .align-self-start {
            -ms-flex-item-align: start !important;
            align-self: flex-start !important;
        }

        .align-self-end {
            -ms-flex-item-align: end !important;
            align-self: flex-end !important;
        }

        .align-self-center {
            -ms-flex-item-align: center !important;
            align-self: center !important;
        }

        .align-self-baseline {
            -ms-flex-item-align: baseline !important;
            align-self: baseline !important;
        }

        .align-self-stretch {
            -ms-flex-item-align: stretch !important;
            align-self: stretch !important;
        }

        @media (min-width: 576px) {
            .flex-sm-row {
                -ms-flex-direction: row !important;
                flex-direction: row !important;
            }
            .flex-sm-column {
                -ms-flex-direction: column !important;
                flex-direction: column !important;
            }
            .flex-sm-row-reverse {
                -ms-flex-direction: row-reverse !important;
                flex-direction: row-reverse !important;
            }
            .flex-sm-column-reverse {
                -ms-flex-direction: column-reverse !important;
                flex-direction: column-reverse !important;
            }
            .flex-sm-wrap {
                -ms-flex-wrap: wrap !important;
                flex-wrap: wrap !important;
            }
            .flex-sm-nowrap {
                -ms-flex-wrap: nowrap !important;
                flex-wrap: nowrap !important;
            }
            .flex-sm-wrap-reverse {
                -ms-flex-wrap: wrap-reverse !important;
                flex-wrap: wrap-reverse !important;
            }
            .flex-sm-fill {
                -ms-flex: 1 1 auto !important;
                flex: 1 1 auto !important;
            }
            .flex-sm-grow-0 {
                -ms-flex-positive: 0 !important;
                flex-grow: 0 !important;
            }
            .flex-sm-grow-1 {
                -ms-flex-positive: 1 !important;
                flex-grow: 1 !important;
            }
            .flex-sm-shrink-0 {
                -ms-flex-negative: 0 !important;
                flex-shrink: 0 !important;
            }
            .flex-sm-shrink-1 {
                -ms-flex-negative: 1 !important;
                flex-shrink: 1 !important;
            }
            .justify-content-sm-start {
                -ms-flex-pack: start !important;
                justify-content: flex-start !important;
            }
            .justify-content-sm-end {
                -ms-flex-pack: end !important;
                justify-content: flex-end !important;
            }
            .justify-content-sm-center {
                -ms-flex-pack: center !important;
                justify-content: center !important;
            }
            .justify-content-sm-between {
                -ms-flex-pack: justify !important;
                justify-content: space-between !important;
            }
            .justify-content-sm-around {
                -ms-flex-pack: distribute !important;
                justify-content: space-around !important;
            }
            .align-items-sm-start {
                -ms-flex-align: start !important;
                align-items: flex-start !important;
            }
            .align-items-sm-end {
                -ms-flex-align: end !important;
                align-items: flex-end !important;
            }
            .align-items-sm-center {
                -ms-flex-align: center !important;
                align-items: center !important;
            }
            .align-items-sm-baseline {
                -ms-flex-align: baseline !important;
                align-items: baseline !important;
            }
            .align-items-sm-stretch {
                -ms-flex-align: stretch !important;
                align-items: stretch !important;
            }
            .align-content-sm-start {
                -ms-flex-line-pack: start !important;
                align-content: flex-start !important;
            }
            .align-content-sm-end {
                -ms-flex-line-pack: end !important;
                align-content: flex-end !important;
            }
            .align-content-sm-center {
                -ms-flex-line-pack: center !important;
                align-content: center !important;
            }
            .align-content-sm-between {
                -ms-flex-line-pack: justify !important;
                align-content: space-between !important;
            }
            .align-content-sm-around {
                -ms-flex-line-pack: distribute !important;
                align-content: space-around !important;
            }
            .align-content-sm-stretch {
                -ms-flex-line-pack: stretch !important;
                align-content: stretch !important;
            }
            .align-self-sm-auto {
                -ms-flex-item-align: auto !important;
                align-self: auto !important;
            }
            .align-self-sm-start {
                -ms-flex-item-align: start !important;
                align-self: flex-start !important;
            }
            .align-self-sm-end {
                -ms-flex-item-align: end !important;
                align-self: flex-end !important;
            }
            .align-self-sm-center {
                -ms-flex-item-align: center !important;
                align-self: center !important;
            }
            .align-self-sm-baseline {
                -ms-flex-item-align: baseline !important;
                align-self: baseline !important;
            }
            .align-self-sm-stretch {
                -ms-flex-item-align: stretch !important;
                align-self: stretch !important;
            }
        }

        @media (min-width: 768px) {
            .flex-md-row {
                -ms-flex-direction: row !important;
                flex-direction: row !important;
            }
            .flex-md-column {
                -ms-flex-direction: column !important;
                flex-direction: column !important;
            }
            .flex-md-row-reverse {
                -ms-flex-direction: row-reverse !important;
                flex-direction: row-reverse !important;
            }
            .flex-md-column-reverse {
                -ms-flex-direction: column-reverse !important;
                flex-direction: column-reverse !important;
            }
            .flex-md-wrap {
                -ms-flex-wrap: wrap !important;
                flex-wrap: wrap !important;
            }
            .flex-md-nowrap {
                -ms-flex-wrap: nowrap !important;
                flex-wrap: nowrap !important;
            }
            .flex-md-wrap-reverse {
                -ms-flex-wrap: wrap-reverse !important;
                flex-wrap: wrap-reverse !important;
            }
            .flex-md-fill {
                -ms-flex: 1 1 auto !important;
                flex: 1 1 auto !important;
            }
            .flex-md-grow-0 {
                -ms-flex-positive: 0 !important;
                flex-grow: 0 !important;
            }
            .flex-md-grow-1 {
                -ms-flex-positive: 1 !important;
                flex-grow: 1 !important;
            }
            .flex-md-shrink-0 {
                -ms-flex-negative: 0 !important;
                flex-shrink: 0 !important;
            }
            .flex-md-shrink-1 {
                -ms-flex-negative: 1 !important;
                flex-shrink: 1 !important;
            }
            .justify-content-md-start {
                -ms-flex-pack: start !important;
                justify-content: flex-start !important;
            }
            .justify-content-md-end {
                -ms-flex-pack: end !important;
                justify-content: flex-end !important;
            }
            .justify-content-md-center {
                -ms-flex-pack: center !important;
                justify-content: center !important;
            }
            .justify-content-md-between {
                -ms-flex-pack: justify !important;
                justify-content: space-between !important;
            }
            .justify-content-md-around {
                -ms-flex-pack: distribute !important;
                justify-content: space-around !important;
            }
            .align-items-md-start {
                -ms-flex-align: start !important;
                align-items: flex-start !important;
            }
            .align-items-md-end {
                -ms-flex-align: end !important;
                align-items: flex-end !important;
            }
            .align-items-md-center {
                -ms-flex-align: center !important;
                align-items: center !important;
            }
            .align-items-md-baseline {
                -ms-flex-align: baseline !important;
                align-items: baseline !important;
            }
            .align-items-md-stretch {
                -ms-flex-align: stretch !important;
                align-items: stretch !important;
            }
            .align-content-md-start {
                -ms-flex-line-pack: start !important;
                align-content: flex-start !important;
            }
            .align-content-md-end {
                -ms-flex-line-pack: end !important;
                align-content: flex-end !important;
            }
            .align-content-md-center {
                -ms-flex-line-pack: center !important;
                align-content: center !important;
            }
            .align-content-md-between {
                -ms-flex-line-pack: justify !important;
                align-content: space-between !important;
            }
            .align-content-md-around {
                -ms-flex-line-pack: distribute !important;
                align-content: space-around !important;
            }
            .align-content-md-stretch {
                -ms-flex-line-pack: stretch !important;
                align-content: stretch !important;
            }
            .align-self-md-auto {
                -ms-flex-item-align: auto !important;
                align-self: auto !important;
            }
            .align-self-md-start {
                -ms-flex-item-align: start !important;
                align-self: flex-start !important;
            }
            .align-self-md-end {
                -ms-flex-item-align: end !important;
                align-self: flex-end !important;
            }
            .align-self-md-center {
                -ms-flex-item-align: center !important;
                align-self: center !important;
            }
            .align-self-md-baseline {
                -ms-flex-item-align: baseline !important;
                align-self: baseline !important;
            }
            .align-self-md-stretch {
                -ms-flex-item-align: stretch !important;
                align-self: stretch !important;
            }
        }

        @media (min-width: 992px) {
            .flex-lg-row {
                -ms-flex-direction: row !important;
                flex-direction: row !important;
            }
            .flex-lg-column {
                -ms-flex-direction: column !important;
                flex-direction: column !important;
            }
            .flex-lg-row-reverse {
                -ms-flex-direction: row-reverse !important;
                flex-direction: row-reverse !important;
            }
            .flex-lg-column-reverse {
                -ms-flex-direction: column-reverse !important;
                flex-direction: column-reverse !important;
            }
            .flex-lg-wrap {
                -ms-flex-wrap: wrap !important;
                flex-wrap: wrap !important;
            }
            .flex-lg-nowrap {
                -ms-flex-wrap: nowrap !important;
                flex-wrap: nowrap !important;
            }
            .flex-lg-wrap-reverse {
                -ms-flex-wrap: wrap-reverse !important;
                flex-wrap: wrap-reverse !important;
            }
            .flex-lg-fill {
                -ms-flex: 1 1 auto !important;
                flex: 1 1 auto !important;
            }
            .flex-lg-grow-0 {
                -ms-flex-positive: 0 !important;
                flex-grow: 0 !important;
            }
            .flex-lg-grow-1 {
                -ms-flex-positive: 1 !important;
                flex-grow: 1 !important;
            }
            .flex-lg-shrink-0 {
                -ms-flex-negative: 0 !important;
                flex-shrink: 0 !important;
            }
            .flex-lg-shrink-1 {
                -ms-flex-negative: 1 !important;
                flex-shrink: 1 !important;
            }
            .justify-content-lg-start {
                -ms-flex-pack: start !important;
                justify-content: flex-start !important;
            }
            .justify-content-lg-end {
                -ms-flex-pack: end !important;
                justify-content: flex-end !important;
            }
            .justify-content-lg-center {
                -ms-flex-pack: center !important;
                justify-content: center !important;
            }
            .justify-content-lg-between {
                -ms-flex-pack: justify !important;
                justify-content: space-between !important;
            }
            .justify-content-lg-around {
                -ms-flex-pack: distribute !important;
                justify-content: space-around !important;
            }
            .align-items-lg-start {
                -ms-flex-align: start !important;
                align-items: flex-start !important;
            }
            .align-items-lg-end {
                -ms-flex-align: end !important;
                align-items: flex-end !important;
            }
            .align-items-lg-center {
                -ms-flex-align: center !important;
                align-items: center !important;
            }
            .align-items-lg-baseline {
                -ms-flex-align: baseline !important;
                align-items: baseline !important;
            }
            .align-items-lg-stretch {
                -ms-flex-align: stretch !important;
                align-items: stretch !important;
            }
            .align-content-lg-start {
                -ms-flex-line-pack: start !important;
                align-content: flex-start !important;
            }
            .align-content-lg-end {
                -ms-flex-line-pack: end !important;
                align-content: flex-end !important;
            }
            .align-content-lg-center {
                -ms-flex-line-pack: center !important;
                align-content: center !important;
            }
            .align-content-lg-between {
                -ms-flex-line-pack: justify !important;
                align-content: space-between !important;
            }
            .align-content-lg-around {
                -ms-flex-line-pack: distribute !important;
                align-content: space-around !important;
            }
            .align-content-lg-stretch {
                -ms-flex-line-pack: stretch !important;
                align-content: stretch !important;
            }
            .align-self-lg-auto {
                -ms-flex-item-align: auto !important;
                align-self: auto !important;
            }
            .align-self-lg-start {
                -ms-flex-item-align: start !important;
                align-self: flex-start !important;
            }
            .align-self-lg-end {
                -ms-flex-item-align: end !important;
                align-self: flex-end !important;
            }
            .align-self-lg-center {
                -ms-flex-item-align: center !important;
                align-self: center !important;
            }
            .align-self-lg-baseline {
                -ms-flex-item-align: baseline !important;
                align-self: baseline !important;
            }
            .align-self-lg-stretch {
                -ms-flex-item-align: stretch !important;
                align-self: stretch !important;
            }
        }

        @media (min-width: 1200px) {
            .flex-xl-row {
                -ms-flex-direction: row !important;
                flex-direction: row !important;
            }
            .flex-xl-column {
                -ms-flex-direction: column !important;
                flex-direction: column !important;
            }
            .flex-xl-row-reverse {
                -ms-flex-direction: row-reverse !important;
                flex-direction: row-reverse !important;
            }
            .flex-xl-column-reverse {
                -ms-flex-direction: column-reverse !important;
                flex-direction: column-reverse !important;
            }
            .flex-xl-wrap {
                -ms-flex-wrap: wrap !important;
                flex-wrap: wrap !important;
            }
            .flex-xl-nowrap {
                -ms-flex-wrap: nowrap !important;
                flex-wrap: nowrap !important;
            }
            .flex-xl-wrap-reverse {
                -ms-flex-wrap: wrap-reverse !important;
                flex-wrap: wrap-reverse !important;
            }
            .flex-xl-fill {
                -ms-flex: 1 1 auto !important;
                flex: 1 1 auto !important;
            }
            .flex-xl-grow-0 {
                -ms-flex-positive: 0 !important;
                flex-grow: 0 !important;
            }
            .flex-xl-grow-1 {
                -ms-flex-positive: 1 !important;
                flex-grow: 1 !important;
            }
            .flex-xl-shrink-0 {
                -ms-flex-negative: 0 !important;
                flex-shrink: 0 !important;
            }
            .flex-xl-shrink-1 {
                -ms-flex-negative: 1 !important;
                flex-shrink: 1 !important;
            }
            .justify-content-xl-start {
                -ms-flex-pack: start !important;
                justify-content: flex-start !important;
            }
            .justify-content-xl-end {
                -ms-flex-pack: end !important;
                justify-content: flex-end !important;
            }
            .justify-content-xl-center {
                -ms-flex-pack: center !important;
                justify-content: center !important;
            }
            .justify-content-xl-between {
                -ms-flex-pack: justify !important;
                justify-content: space-between !important;
            }
            .justify-content-xl-around {
                -ms-flex-pack: distribute !important;
                justify-content: space-around !important;
            }
            .align-items-xl-start {
                -ms-flex-align: start !important;
                align-items: flex-start !important;
            }
            .align-items-xl-end {
                -ms-flex-align: end !important;
                align-items: flex-end !important;
            }
            .align-items-xl-center {
                -ms-flex-align: center !important;
                align-items: center !important;
            }
            .align-items-xl-baseline {
                -ms-flex-align: baseline !important;
                align-items: baseline !important;
            }
            .align-items-xl-stretch {
                -ms-flex-align: stretch !important;
                align-items: stretch !important;
            }
            .align-content-xl-start {
                -ms-flex-line-pack: start !important;
                align-content: flex-start !important;
            }
            .align-content-xl-end {
                -ms-flex-line-pack: end !important;
                align-content: flex-end !important;
            }
            .align-content-xl-center {
                -ms-flex-line-pack: center !important;
                align-content: center !important;
            }
            .align-content-xl-between {
                -ms-flex-line-pack: justify !important;
                align-content: space-between !important;
            }
            .align-content-xl-around {
                -ms-flex-line-pack: distribute !important;
                align-content: space-around !important;
            }
            .align-content-xl-stretch {
                -ms-flex-line-pack: stretch !important;
                align-content: stretch !important;
            }
            .align-self-xl-auto {
                -ms-flex-item-align: auto !important;
                align-self: auto !important;
            }
            .align-self-xl-start {
                -ms-flex-item-align: start !important;
                align-self: flex-start !important;
            }
            .align-self-xl-end {
                -ms-flex-item-align: end !important;
                align-self: flex-end !important;
            }
            .align-self-xl-center {
                -ms-flex-item-align: center !important;
                align-self: center !important;
            }
            .align-self-xl-baseline {
                -ms-flex-item-align: baseline !important;
                align-self: baseline !important;
            }
            .align-self-xl-stretch {
                -ms-flex-item-align: stretch !important;
                align-self: stretch !important;
            }
        }

        .float-left {
            float: left !important;
        }

        .float-right {
            float: right !important;
        }

        .float-none {
            float: none !important;
        }

        @media (min-width: 576px) {
            .float-sm-left {
                float: left !important;
            }
            .float-sm-right {
                float: right !important;
            }
            .float-sm-none {
                float: none !important;
            }
        }

        @media (min-width: 768px) {
            .float-md-left {
                float: left !important;
            }
            .float-md-right {
                float: right !important;
            }
            .float-md-none {
                float: none !important;
            }
        }

        @media (min-width: 992px) {
            .float-lg-left {
                float: left !important;
            }
            .float-lg-right {
                float: right !important;
            }
            .float-lg-none {
                float: none !important;
            }
        }

        @media (min-width: 1200px) {
            .float-xl-left {
                float: left !important;
            }
            .float-xl-right {
                float: right !important;
            }
            .float-xl-none {
                float: none !important;
            }
        }

        .user-select-all {
            -webkit-user-select: all !important;
            -moz-user-select: all !important;
            -ms-user-select: all !important;
            user-select: all !important;
        }

        .user-select-auto {
            -webkit-user-select: auto !important;
            -moz-user-select: auto !important;
            -ms-user-select: auto !important;
            user-select: auto !important;
        }

        .user-select-none {
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
        }

        .overflow-auto {
            overflow: auto !important;
        }

        .overflow-hidden {
            overflow: hidden !important;
        }

        .position-static {
            position: static !important;
        }

        .position-relative {
            position: relative !important;
        }

        .position-absolute {
            position: absolute !important;
        }

        .position-fixed {
            position: fixed !important;
        }

        .position-sticky {
            position: -webkit-sticky !important;
            position: sticky !important;
        }

        .fixed-top {
            top: 0;
        }

        .fixed-top,.fixed-bottom {
            position: fixed;
            right: 0;
            left: 0;
            z-index: 1030;
        }

        .fixed-bottom {
            bottom: 0;
        }

        @supports ((position: -webkit-sticky) or (position: sticky)) {
            .sticky-top {
                position: -webkit-sticky;
                position: sticky;
                top: 0;
                z-index: 1020;
            }
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        .sr-only-focusable:active, .sr-only-focusable:focus {
            position: static;
            width: auto;
            height: auto;
            overflow: visible;
            clip: auto;
            white-space: normal;
        }

        .shadow-sm {
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 21, 0.075) !important;
        }

        .shadow {
            box-shadow: 0 0.5rem 1rem rgba(0, 0, 21, 0.15) !important;
        }

        .shadow-lg {
            box-shadow: 0 1rem 3rem rgba(0, 0, 21, 0.175) !important;
        }

        .shadow-none {
            box-shadow: none !important;
        }

        .w-25 {
            width: 25% !important;
        }

        .w-50 {
            width: 50% !important;
        }

        .w-75 {
            width: 75% !important;
        }

        .w-100 {
            width: 100% !important;
        }

        .w-auto {
            width: auto !important;
        }

        .h-25 {
            height: 25% !important;
        }

        .h-50 {
            height: 50% !important;
        }

        .h-75 {
            height: 75% !important;
        }

        .h-100 {
            height: 100% !important;
        }

        .h-auto {
            height: auto !important;
        }

        .mw-100 {
            max-width: 100% !important;
        }

        .mh-100 {
            max-height: 100% !important;
        }

        .min-vw-100 {
            min-width: 100vw !important;
        }

        .min-vh-100 {
            min-height: 100vh !important;
        }

        .vw-100 {
            width: 100vw !important;
        }

        .vh-100 {
            height: 100vh !important;
        }

        .m-0 {
            margin: 0 !important;
        }

        .mt-0,
        .my-0 {
            margin-top: 0 !important;
        }

        .mr-0,
        .mx-0 {
            margin-right: 0 !important;
        }

        .mb-0,
        .my-0 {
            margin-bottom: 0 !important;
        }

        .ml-0,
        .mx-0,html:not([dir="rtl"]) .mfs-0 {
            margin-left: 0 !important;
        }

        *[dir="rtl"] .mfs-0,html:not([dir="rtl"]) .mfe-0 {
            margin-right: 0 !important;
        }

        *[dir="rtl"] .mfe-0 {
            margin-left: 0 !important;
        }

        .m-1 {
            margin: 0.25rem !important;
        }

        .mt-1,
        .my-1 {
            margin-top: 0.25rem !important;
        }

        .mr-1,
        .mx-1 {
            margin-right: 0.25rem !important;
        }

        .mb-1,
        .my-1 {
            margin-bottom: 0.25rem !important;
        }

        .ml-1,
        .mx-1,html:not([dir="rtl"]) .mfs-1 {
            margin-left: 0.25rem !important;
        }

        *[dir="rtl"] .mfs-1,html:not([dir="rtl"]) .mfe-1 {
            margin-right: 0.25rem !important;
        }

        *[dir="rtl"] .mfe-1 {
            margin-left: 0.25rem !important;
        }

        .m-2 {
            margin: 0.5rem !important;
        }

        .mt-2,
        .my-2 {
            margin-top: 0.5rem !important;
        }

        .mr-2,
        .mx-2 {
            margin-right: 0.5rem !important;
        }

        .mb-2,
        .my-2 {
            margin-bottom: 0.5rem !important;
        }

        .ml-2,
        .mx-2,html:not([dir="rtl"]) .mfs-2 {
            margin-left: 0.5rem !important;
        }

        *[dir="rtl"] .mfs-2,html:not([dir="rtl"]) .mfe-2 {
            margin-right: 0.5rem !important;
        }

        *[dir="rtl"] .mfe-2 {
            margin-left: 0.5rem !important;
        }

        .m-3 {
            margin: 1rem !important;
        }

        .mt-3,
        .my-3 {
            margin-top: 1rem !important;
        }

        .mr-3,
        .mx-3 {
            margin-right: 1rem !important;
        }

        .mb-3,
        .my-3 {
            margin-bottom: 1rem !important;
        }

        .ml-3,
        .mx-3,html:not([dir="rtl"]) .mfs-3 {
            margin-left: 1rem !important;
        }

        *[dir="rtl"] .mfs-3,html:not([dir="rtl"]) .mfe-3 {
            margin-right: 1rem !important;
        }

        *[dir="rtl"] .mfe-3 {
            margin-left: 1rem !important;
        }

        .m-4 {
            margin: 1.5rem !important;
        }

        .mt-4,
        .my-4 {
            margin-top: 1.5rem !important;
        }

        .mr-4,
        .mx-4 {
            margin-right: 1.5rem !important;
        }

        .mb-4,
        .my-4 {
            margin-bottom: 1.5rem !important;
        }

        .ml-4,
        .mx-4,html:not([dir="rtl"]) .mfs-4 {
            margin-left: 1.5rem !important;
        }

        *[dir="rtl"] .mfs-4,html:not([dir="rtl"]) .mfe-4 {
            margin-right: 1.5rem !important;
        }

        *[dir="rtl"] .mfe-4 {
            margin-left: 1.5rem !important;
        }

        .m-5 {
            margin: 3rem !important;
        }

        .mt-5,
        .my-5 {
            margin-top: 3rem !important;
        }

        .mr-5,
        .mx-5 {
            margin-right: 3rem !important;
        }

        .mb-5,
        .my-5 {
            margin-bottom: 3rem !important;
        }

        .ml-5,
        .mx-5,html:not([dir="rtl"]) .mfs-5 {
            margin-left: 3rem !important;
        }

        *[dir="rtl"] .mfs-5,html:not([dir="rtl"]) .mfe-5 {
            margin-right: 3rem !important;
        }

        *[dir="rtl"] .mfe-5 {
            margin-left: 3rem !important;
        }

        .p-0 {
            padding: 0 !important;
        }

        .pt-0,
        .py-0 {
            padding-top: 0 !important;
        }

        .pr-0,
        .px-0 {
            padding-right: 0 !important;
        }

        .pb-0,
        .py-0 {
            padding-bottom: 0 !important;
        }

        .pl-0,
        .px-0,html:not([dir="rtl"]) .pfs-0 {
            padding-left: 0 !important;
        }

        *[dir="rtl"] .pfs-0,html:not([dir="rtl"]) .pfe-0 {
            padding-right: 0 !important;
        }

        *[dir="rtl"] .pfe-0 {
            padding-left: 0 !important;
        }

        .p-1 {
            padding: 0.25rem !important;
        }

        .pt-1,
        .py-1 {
            padding-top: 0.25rem !important;
        }

        .pr-1,
        .px-1 {
            padding-right: 0.25rem !important;
        }

        .pb-1,
        .py-1 {
            padding-bottom: 0.25rem !important;
        }

        .pl-1,
        .px-1,html:not([dir="rtl"]) .pfs-1 {
            padding-left: 0.25rem !important;
        }

        *[dir="rtl"] .pfs-1,html:not([dir="rtl"]) .pfe-1 {
            padding-right: 0.25rem !important;
        }

        *[dir="rtl"] .pfe-1 {
            padding-left: 0.25rem !important;
        }

        .p-2 {
            padding: 0.5rem !important;
        }

        .pt-2,
        .py-2 {
            padding-top: 0.5rem !important;
        }

        .pr-2,
        .px-2 {
            padding-right: 0.5rem !important;
        }

        .pb-2,
        .py-2 {
            padding-bottom: 0.5rem !important;
        }

        .pl-2,
        .px-2,html:not([dir="rtl"]) .pfs-2 {
            padding-left: 0.5rem !important;
        }

        *[dir="rtl"] .pfs-2,html:not([dir="rtl"]) .pfe-2 {
            padding-right: 0.5rem !important;
        }

        *[dir="rtl"] .pfe-2 {
            padding-left: 0.5rem !important;
        }

        .p-3 {
            padding: 1rem !important;
        }

        .pt-3,
        .py-3 {
            padding-top: 1rem !important;
        }

        .pr-3,
        .px-3 {
            padding-right: 1rem !important;
        }

        .pb-3,
        .py-3 {
            padding-bottom: 1rem !important;
        }

        .pl-3,
        .px-3,html:not([dir="rtl"]) .pfs-3 {
            padding-left: 1rem !important;
        }

        *[dir="rtl"] .pfs-3,html:not([dir="rtl"]) .pfe-3 {
            padding-right: 1rem !important;
        }

        *[dir="rtl"] .pfe-3 {
            padding-left: 1rem !important;
        }

        .p-4 {
            padding: 1.5rem !important;
        }

        .pt-4,
        .py-4 {
            padding-top: 1.5rem !important;
        }

        .pr-4,
        .px-4 {
            padding-right: 1.5rem !important;
        }

        .pb-4,
        .py-4 {
            padding-bottom: 1.5rem !important;
        }

        .pl-4,
        .px-4,html:not([dir="rtl"]) .pfs-4 {
            padding-left: 1.5rem !important;
        }

        *[dir="rtl"] .pfs-4,html:not([dir="rtl"]) .pfe-4 {
            padding-right: 1.5rem !important;
        }

        *[dir="rtl"] .pfe-4 {
            padding-left: 1.5rem !important;
        }

        .p-5 {
            padding: 3rem !important;
        }

        .pt-5,
        .py-5 {
            padding-top: 3rem !important;
        }

        .pr-5,
        .px-5 {
            padding-right: 3rem !important;
        }

        .pb-5,
        .py-5 {
            padding-bottom: 3rem !important;
        }

        .pl-5,
        .px-5,html:not([dir="rtl"]) .pfs-5 {
            padding-left: 3rem !important;
        }

        *[dir="rtl"] .pfs-5,html:not([dir="rtl"]) .pfe-5 {
            padding-right: 3rem !important;
        }

        *[dir="rtl"] .pfe-5 {
            padding-left: 3rem !important;
        }

        .m-n1 {
            margin: -0.25rem !important;
        }

        .mt-n1,
        .my-n1 {
            margin-top: -0.25rem !important;
        }

        .mr-n1,
        .mx-n1 {
            margin-right: -0.25rem !important;
        }

        .mb-n1,
        .my-n1 {
            margin-bottom: -0.25rem !important;
        }

        .ml-n1,
        .mx-n1,html:not([dir="rtl"]) .mfs-n1 {
            margin-left: -0.25rem !important;
        }

        *[dir="rtl"] .mfs-n1,html:not([dir="rtl"]) .mfe-n1 {
            margin-right: -0.25rem !important;
        }

        *[dir="rtl"] .mfe-n1 {
            margin-left: -0.25rem !important;
        }

        .m-n2 {
            margin: -0.5rem !important;
        }

        .mt-n2,
        .my-n2 {
            margin-top: -0.5rem !important;
        }

        .mr-n2,
        .mx-n2 {
            margin-right: -0.5rem !important;
        }

        .mb-n2,
        .my-n2 {
            margin-bottom: -0.5rem !important;
        }

        .ml-n2,
        .mx-n2,html:not([dir="rtl"]) .mfs-n2 {
            margin-left: -0.5rem !important;
        }

        *[dir="rtl"] .mfs-n2,html:not([dir="rtl"]) .mfe-n2 {
            margin-right: -0.5rem !important;
        }

        *[dir="rtl"] .mfe-n2 {
            margin-left: -0.5rem !important;
        }

        .m-n3 {
            margin: -1rem !important;
        }

        .mt-n3,
        .my-n3 {
            margin-top: -1rem !important;
        }

        .mr-n3,
        .mx-n3 {
            margin-right: -1rem !important;
        }

        .mb-n3,
        .my-n3 {
            margin-bottom: -1rem !important;
        }

        .ml-n3,
        .mx-n3,html:not([dir="rtl"]) .mfs-n3 {
            margin-left: -1rem !important;
        }

        *[dir="rtl"] .mfs-n3,html:not([dir="rtl"]) .mfe-n3 {
            margin-right: -1rem !important;
        }

        *[dir="rtl"] .mfe-n3 {
            margin-left: -1rem !important;
        }

        .m-n4 {
            margin: -1.5rem !important;
        }

        .mt-n4,
        .my-n4 {
            margin-top: -1.5rem !important;
        }

        .mr-n4,
        .mx-n4 {
            margin-right: -1.5rem !important;
        }

        .mb-n4,
        .my-n4 {
            margin-bottom: -1.5rem !important;
        }

        .ml-n4,
        .mx-n4,html:not([dir="rtl"]) .mfs-n4 {
            margin-left: -1.5rem !important;
        }

        *[dir="rtl"] .mfs-n4,html:not([dir="rtl"]) .mfe-n4 {
            margin-right: -1.5rem !important;
        }

        *[dir="rtl"] .mfe-n4 {
            margin-left: -1.5rem !important;
        }

        .m-n5 {
            margin: -3rem !important;
        }

        .mt-n5,
        .my-n5 {
            margin-top: -3rem !important;
        }

        .mr-n5,
        .mx-n5 {
            margin-right: -3rem !important;
        }

        .mb-n5,
        .my-n5 {
            margin-bottom: -3rem !important;
        }

        .ml-n5,
        .mx-n5,html:not([dir="rtl"]) .mfs-n5 {
            margin-left: -3rem !important;
        }

        *[dir="rtl"] .mfs-n5,html:not([dir="rtl"]) .mfe-n5 {
            margin-right: -3rem !important;
        }

        *[dir="rtl"] .mfe-n5 {
            margin-left: -3rem !important;
        }

        .m-auto {
            margin: auto !important;
        }

        .mt-auto,
        .my-auto {
            margin-top: auto !important;
        }

        .mr-auto,
        .mx-auto {
            margin-right: auto !important;
        }

        .mb-auto,
        .my-auto {
            margin-bottom: auto !important;
        }

        .ml-auto,
        .mx-auto,html:not([dir="rtl"]) .mfs-auto {
            margin-left: auto !important;
        }

        *[dir="rtl"] .mfs-auto,html:not([dir="rtl"]) .mfe-auto {
            margin-right: auto !important;
        }

        *[dir="rtl"] .mfe-auto {
            margin-left: auto !important;
        }

        @media (min-width: 576px) {
            .m-sm-0 {
                margin: 0 !important;
            }
            .mt-sm-0,
            .my-sm-0 {
                margin-top: 0 !important;
            }
            .mr-sm-0,
            .mx-sm-0 {
                margin-right: 0 !important;
            }
            .mb-sm-0,
            .my-sm-0 {
                margin-bottom: 0 !important;
            }
            .ml-sm-0,
            .mx-sm-0,html:not([dir="rtl"]) .mfs-sm-0 {
                margin-left: 0 !important;
            }
            *[dir="rtl"] .mfs-sm-0,html:not([dir="rtl"]) .mfe-sm-0 {
                margin-right: 0 !important;
            }
            *[dir="rtl"] .mfe-sm-0 {
                margin-left: 0 !important;
            }
            .m-sm-1 {
                margin: 0.25rem !important;
            }
            .mt-sm-1,
            .my-sm-1 {
                margin-top: 0.25rem !important;
            }
            .mr-sm-1,
            .mx-sm-1 {
                margin-right: 0.25rem !important;
            }
            .mb-sm-1,
            .my-sm-1 {
                margin-bottom: 0.25rem !important;
            }
            .ml-sm-1,
            .mx-sm-1,html:not([dir="rtl"]) .mfs-sm-1 {
                margin-left: 0.25rem !important;
            }
            *[dir="rtl"] .mfs-sm-1,html:not([dir="rtl"]) .mfe-sm-1 {
                margin-right: 0.25rem !important;
            }
            *[dir="rtl"] .mfe-sm-1 {
                margin-left: 0.25rem !important;
            }
            .m-sm-2 {
                margin: 0.5rem !important;
            }
            .mt-sm-2,
            .my-sm-2 {
                margin-top: 0.5rem !important;
            }
            .mr-sm-2,
            .mx-sm-2 {
                margin-right: 0.5rem !important;
            }
            .mb-sm-2,
            .my-sm-2 {
                margin-bottom: 0.5rem !important;
            }
            .ml-sm-2,
            .mx-sm-2,html:not([dir="rtl"]) .mfs-sm-2 {
                margin-left: 0.5rem !important;
            }
            *[dir="rtl"] .mfs-sm-2,html:not([dir="rtl"]) .mfe-sm-2 {
                margin-right: 0.5rem !important;
            }
            *[dir="rtl"] .mfe-sm-2 {
                margin-left: 0.5rem !important;
            }
            .m-sm-3 {
                margin: 1rem !important;
            }
            .mt-sm-3,
            .my-sm-3 {
                margin-top: 1rem !important;
            }
            .mr-sm-3,
            .mx-sm-3 {
                margin-right: 1rem !important;
            }
            .mb-sm-3,
            .my-sm-3 {
                margin-bottom: 1rem !important;
            }
            .ml-sm-3,
            .mx-sm-3,html:not([dir="rtl"]) .mfs-sm-3 {
                margin-left: 1rem !important;
            }
            *[dir="rtl"] .mfs-sm-3,html:not([dir="rtl"]) .mfe-sm-3 {
                margin-right: 1rem !important;
            }
            *[dir="rtl"] .mfe-sm-3 {
                margin-left: 1rem !important;
            }
            .m-sm-4 {
                margin: 1.5rem !important;
            }
            .mt-sm-4,
            .my-sm-4 {
                margin-top: 1.5rem !important;
            }
            .mr-sm-4,
            .mx-sm-4 {
                margin-right: 1.5rem !important;
            }
            .mb-sm-4,
            .my-sm-4 {
                margin-bottom: 1.5rem !important;
            }
            .ml-sm-4,
            .mx-sm-4,html:not([dir="rtl"]) .mfs-sm-4 {
                margin-left: 1.5rem !important;
            }
            *[dir="rtl"] .mfs-sm-4,html:not([dir="rtl"]) .mfe-sm-4 {
                margin-right: 1.5rem !important;
            }
            *[dir="rtl"] .mfe-sm-4 {
                margin-left: 1.5rem !important;
            }
            .m-sm-5 {
                margin: 3rem !important;
            }
            .mt-sm-5,
            .my-sm-5 {
                margin-top: 3rem !important;
            }
            .mr-sm-5,
            .mx-sm-5 {
                margin-right: 3rem !important;
            }
            .mb-sm-5,
            .my-sm-5 {
                margin-bottom: 3rem !important;
            }
            .ml-sm-5,
            .mx-sm-5,html:not([dir="rtl"]) .mfs-sm-5 {
                margin-left: 3rem !important;
            }
            *[dir="rtl"] .mfs-sm-5,html:not([dir="rtl"]) .mfe-sm-5 {
                margin-right: 3rem !important;
            }
            *[dir="rtl"] .mfe-sm-5 {
                margin-left: 3rem !important;
            }
            .p-sm-0 {
                padding: 0 !important;
            }
            .pt-sm-0,
            .py-sm-0 {
                padding-top: 0 !important;
            }
            .pr-sm-0,
            .px-sm-0 {
                padding-right: 0 !important;
            }
            .pb-sm-0,
            .py-sm-0 {
                padding-bottom: 0 !important;
            }
            .pl-sm-0,
            .px-sm-0,html:not([dir="rtl"]) .pfs-sm-0 {
                padding-left: 0 !important;
            }
            *[dir="rtl"] .pfs-sm-0,html:not([dir="rtl"]) .pfe-sm-0 {
                padding-right: 0 !important;
            }
            *[dir="rtl"] .pfe-sm-0 {
                padding-left: 0 !important;
            }
            .p-sm-1 {
                padding: 0.25rem !important;
            }
            .pt-sm-1,
            .py-sm-1 {
                padding-top: 0.25rem !important;
            }
            .pr-sm-1,
            .px-sm-1 {
                padding-right: 0.25rem !important;
            }
            .pb-sm-1,
            .py-sm-1 {
                padding-bottom: 0.25rem !important;
            }
            .pl-sm-1,
            .px-sm-1,html:not([dir="rtl"]) .pfs-sm-1 {
                padding-left: 0.25rem !important;
            }
            *[dir="rtl"] .pfs-sm-1,html:not([dir="rtl"]) .pfe-sm-1 {
                padding-right: 0.25rem !important;
            }
            *[dir="rtl"] .pfe-sm-1 {
                padding-left: 0.25rem !important;
            }
            .p-sm-2 {
                padding: 0.5rem !important;
            }
            .pt-sm-2,
            .py-sm-2 {
                padding-top: 0.5rem !important;
            }
            .pr-sm-2,
            .px-sm-2 {
                padding-right: 0.5rem !important;
            }
            .pb-sm-2,
            .py-sm-2 {
                padding-bottom: 0.5rem !important;
            }
            .pl-sm-2,
            .px-sm-2,html:not([dir="rtl"]) .pfs-sm-2 {
                padding-left: 0.5rem !important;
            }
            *[dir="rtl"] .pfs-sm-2,html:not([dir="rtl"]) .pfe-sm-2 {
                padding-right: 0.5rem !important;
            }
            *[dir="rtl"] .pfe-sm-2 {
                padding-left: 0.5rem !important;
            }
            .p-sm-3 {
                padding: 1rem !important;
            }
            .pt-sm-3,
            .py-sm-3 {
                padding-top: 1rem !important;
            }
            .pr-sm-3,
            .px-sm-3 {
                padding-right: 1rem !important;
            }
            .pb-sm-3,
            .py-sm-3 {
                padding-bottom: 1rem !important;
            }
            .pl-sm-3,
            .px-sm-3,html:not([dir="rtl"]) .pfs-sm-3 {
                padding-left: 1rem !important;
            }
            *[dir="rtl"] .pfs-sm-3,html:not([dir="rtl"]) .pfe-sm-3 {
                padding-right: 1rem !important;
            }
            *[dir="rtl"] .pfe-sm-3 {
                padding-left: 1rem !important;
            }
            .p-sm-4 {
                padding: 1.5rem !important;
            }
            .pt-sm-4,
            .py-sm-4 {
                padding-top: 1.5rem !important;
            }
            .pr-sm-4,
            .px-sm-4 {
                padding-right: 1.5rem !important;
            }
            .pb-sm-4,
            .py-sm-4 {
                padding-bottom: 1.5rem !important;
            }
            .pl-sm-4,
            .px-sm-4,html:not([dir="rtl"]) .pfs-sm-4 {
                padding-left: 1.5rem !important;
            }
            *[dir="rtl"] .pfs-sm-4,html:not([dir="rtl"]) .pfe-sm-4 {
                padding-right: 1.5rem !important;
            }
            *[dir="rtl"] .pfe-sm-4 {
                padding-left: 1.5rem !important;
            }
            .p-sm-5 {
                padding: 3rem !important;
            }
            .pt-sm-5,
            .py-sm-5 {
                padding-top: 3rem !important;
            }
            .pr-sm-5,
            .px-sm-5 {
                padding-right: 3rem !important;
            }
            .pb-sm-5,
            .py-sm-5 {
                padding-bottom: 3rem !important;
            }
            .pl-sm-5,
            .px-sm-5,html:not([dir="rtl"]) .pfs-sm-5 {
                padding-left: 3rem !important;
            }
            *[dir="rtl"] .pfs-sm-5,html:not([dir="rtl"]) .pfe-sm-5 {
                padding-right: 3rem !important;
            }
            *[dir="rtl"] .pfe-sm-5 {
                padding-left: 3rem !important;
            }
            .m-sm-n1 {
                margin: -0.25rem !important;
            }
            .mt-sm-n1,
            .my-sm-n1 {
                margin-top: -0.25rem !important;
            }
            .mr-sm-n1,
            .mx-sm-n1 {
                margin-right: -0.25rem !important;
            }
            .mb-sm-n1,
            .my-sm-n1 {
                margin-bottom: -0.25rem !important;
            }
            .ml-sm-n1,
            .mx-sm-n1,html:not([dir="rtl"]) .mfs-sm-n1 {
                margin-left: -0.25rem !important;
            }
            *[dir="rtl"] .mfs-sm-n1,html:not([dir="rtl"]) .mfe-sm-n1 {
                margin-right: -0.25rem !important;
            }
            *[dir="rtl"] .mfe-sm-n1 {
                margin-left: -0.25rem !important;
            }
            .m-sm-n2 {
                margin: -0.5rem !important;
            }
            .mt-sm-n2,
            .my-sm-n2 {
                margin-top: -0.5rem !important;
            }
            .mr-sm-n2,
            .mx-sm-n2 {
                margin-right: -0.5rem !important;
            }
            .mb-sm-n2,
            .my-sm-n2 {
                margin-bottom: -0.5rem !important;
            }
            .ml-sm-n2,
            .mx-sm-n2,html:not([dir="rtl"]) .mfs-sm-n2 {
                margin-left: -0.5rem !important;
            }
            *[dir="rtl"] .mfs-sm-n2,html:not([dir="rtl"]) .mfe-sm-n2 {
                margin-right: -0.5rem !important;
            }
            *[dir="rtl"] .mfe-sm-n2 {
                margin-left: -0.5rem !important;
            }
            .m-sm-n3 {
                margin: -1rem !important;
            }
            .mt-sm-n3,
            .my-sm-n3 {
                margin-top: -1rem !important;
            }
            .mr-sm-n3,
            .mx-sm-n3 {
                margin-right: -1rem !important;
            }
            .mb-sm-n3,
            .my-sm-n3 {
                margin-bottom: -1rem !important;
            }
            .ml-sm-n3,
            .mx-sm-n3,html:not([dir="rtl"]) .mfs-sm-n3 {
                margin-left: -1rem !important;
            }
            *[dir="rtl"] .mfs-sm-n3,html:not([dir="rtl"]) .mfe-sm-n3 {
                margin-right: -1rem !important;
            }
            *[dir="rtl"] .mfe-sm-n3 {
                margin-left: -1rem !important;
            }
            .m-sm-n4 {
                margin: -1.5rem !important;
            }
            .mt-sm-n4,
            .my-sm-n4 {
                margin-top: -1.5rem !important;
            }
            .mr-sm-n4,
            .mx-sm-n4 {
                margin-right: -1.5rem !important;
            }
            .mb-sm-n4,
            .my-sm-n4 {
                margin-bottom: -1.5rem !important;
            }
            .ml-sm-n4,
            .mx-sm-n4,html:not([dir="rtl"]) .mfs-sm-n4 {
                margin-left: -1.5rem !important;
            }
            *[dir="rtl"] .mfs-sm-n4,html:not([dir="rtl"]) .mfe-sm-n4 {
                margin-right: -1.5rem !important;
            }
            *[dir="rtl"] .mfe-sm-n4 {
                margin-left: -1.5rem !important;
            }
            .m-sm-n5 {
                margin: -3rem !important;
            }
            .mt-sm-n5,
            .my-sm-n5 {
                margin-top: -3rem !important;
            }
            .mr-sm-n5,
            .mx-sm-n5 {
                margin-right: -3rem !important;
            }
            .mb-sm-n5,
            .my-sm-n5 {
                margin-bottom: -3rem !important;
            }
            .ml-sm-n5,
            .mx-sm-n5,html:not([dir="rtl"]) .mfs-sm-n5 {
                margin-left: -3rem !important;
            }
            *[dir="rtl"] .mfs-sm-n5,html:not([dir="rtl"]) .mfe-sm-n5 {
                margin-right: -3rem !important;
            }
            *[dir="rtl"] .mfe-sm-n5 {
                margin-left: -3rem !important;
            }
            .m-sm-auto {
                margin: auto !important;
            }
            .mt-sm-auto,
            .my-sm-auto {
                margin-top: auto !important;
            }
            .mr-sm-auto,
            .mx-sm-auto {
                margin-right: auto !important;
            }
            .mb-sm-auto,
            .my-sm-auto {
                margin-bottom: auto !important;
            }
            .ml-sm-auto,
            .mx-sm-auto,html:not([dir="rtl"]) .mfs-sm-auto {
                margin-left: auto !important;
            }
            *[dir="rtl"] .mfs-sm-auto,html:not([dir="rtl"]) .mfe-sm-auto {
                margin-right: auto !important;
            }
            *[dir="rtl"] .mfe-sm-auto {
                margin-left: auto !important;
            }
        }

        @media (min-width: 768px) {
            .m-md-0 {
                margin: 0 !important;
            }
            .mt-md-0,
            .my-md-0 {
                margin-top: 0 !important;
            }
            .mr-md-0,
            .mx-md-0 {
                margin-right: 0 !important;
            }
            .mb-md-0,
            .my-md-0 {
                margin-bottom: 0 !important;
            }
            .ml-md-0,
            .mx-md-0,html:not([dir="rtl"]) .mfs-md-0 {
                margin-left: 0 !important;
            }
            *[dir="rtl"] .mfs-md-0,html:not([dir="rtl"]) .mfe-md-0 {
                margin-right: 0 !important;
            }
            *[dir="rtl"] .mfe-md-0 {
                margin-left: 0 !important;
            }
            .m-md-1 {
                margin: 0.25rem !important;
            }
            .mt-md-1,
            .my-md-1 {
                margin-top: 0.25rem !important;
            }
            .mr-md-1,
            .mx-md-1 {
                margin-right: 0.25rem !important;
            }
            .mb-md-1,
            .my-md-1 {
                margin-bottom: 0.25rem !important;
            }
            .ml-md-1,
            .mx-md-1,html:not([dir="rtl"]) .mfs-md-1 {
                margin-left: 0.25rem !important;
            }
            *[dir="rtl"] .mfs-md-1,html:not([dir="rtl"]) .mfe-md-1 {
                margin-right: 0.25rem !important;
            }
            *[dir="rtl"] .mfe-md-1 {
                margin-left: 0.25rem !important;
            }
            .m-md-2 {
                margin: 0.5rem !important;
            }
            .mt-md-2,
            .my-md-2 {
                margin-top: 0.5rem !important;
            }
            .mr-md-2,
            .mx-md-2 {
                margin-right: 0.5rem !important;
            }
            .mb-md-2,
            .my-md-2 {
                margin-bottom: 0.5rem !important;
            }
            .ml-md-2,
            .mx-md-2,html:not([dir="rtl"]) .mfs-md-2 {
                margin-left: 0.5rem !important;
            }
            *[dir="rtl"] .mfs-md-2,html:not([dir="rtl"]) .mfe-md-2 {
                margin-right: 0.5rem !important;
            }
            *[dir="rtl"] .mfe-md-2 {
                margin-left: 0.5rem !important;
            }
            .m-md-3 {
                margin: 1rem !important;
            }
            .mt-md-3,
            .my-md-3 {
                margin-top: 1rem !important;
            }
            .mr-md-3,
            .mx-md-3 {
                margin-right: 1rem !important;
            }
            .mb-md-3,
            .my-md-3 {
                margin-bottom: 1rem !important;
            }
            .ml-md-3,
            .mx-md-3,html:not([dir="rtl"]) .mfs-md-3 {
                margin-left: 1rem !important;
            }
            *[dir="rtl"] .mfs-md-3,html:not([dir="rtl"]) .mfe-md-3 {
                margin-right: 1rem !important;
            }
            *[dir="rtl"] .mfe-md-3 {
                margin-left: 1rem !important;
            }
            .m-md-4 {
                margin: 1.5rem !important;
            }
            .mt-md-4,
            .my-md-4 {
                margin-top: 1.5rem !important;
            }
            .mr-md-4,
            .mx-md-4 {
                margin-right: 1.5rem !important;
            }
            .mb-md-4,
            .my-md-4 {
                margin-bottom: 1.5rem !important;
            }
            .ml-md-4,
            .mx-md-4,html:not([dir="rtl"]) .mfs-md-4 {
                margin-left: 1.5rem !important;
            }
            *[dir="rtl"] .mfs-md-4,html:not([dir="rtl"]) .mfe-md-4 {
                margin-right: 1.5rem !important;
            }
            *[dir="rtl"] .mfe-md-4 {
                margin-left: 1.5rem !important;
            }
            .m-md-5 {
                margin: 3rem !important;
            }
            .mt-md-5,
            .my-md-5 {
                margin-top: 3rem !important;
            }
            .mr-md-5,
            .mx-md-5 {
                margin-right: 3rem !important;
            }
            .mb-md-5,
            .my-md-5 {
                margin-bottom: 3rem !important;
            }
            .ml-md-5,
            .mx-md-5,html:not([dir="rtl"]) .mfs-md-5 {
                margin-left: 3rem !important;
            }
            *[dir="rtl"] .mfs-md-5,html:not([dir="rtl"]) .mfe-md-5 {
                margin-right: 3rem !important;
            }
            *[dir="rtl"] .mfe-md-5 {
                margin-left: 3rem !important;
            }
            .p-md-0 {
                padding: 0 !important;
            }
            .pt-md-0,
            .py-md-0 {
                padding-top: 0 !important;
            }
            .pr-md-0,
            .px-md-0 {
                padding-right: 0 !important;
            }
            .pb-md-0,
            .py-md-0 {
                padding-bottom: 0 !important;
            }
            .pl-md-0,
            .px-md-0,html:not([dir="rtl"]) .pfs-md-0 {
                padding-left: 0 !important;
            }
            *[dir="rtl"] .pfs-md-0,html:not([dir="rtl"]) .pfe-md-0 {
                padding-right: 0 !important;
            }
            *[dir="rtl"] .pfe-md-0 {
                padding-left: 0 !important;
            }
            .p-md-1 {
                padding: 0.25rem !important;
            }
            .pt-md-1,
            .py-md-1 {
                padding-top: 0.25rem !important;
            }
            .pr-md-1,
            .px-md-1 {
                padding-right: 0.25rem !important;
            }
            .pb-md-1,
            .py-md-1 {
                padding-bottom: 0.25rem !important;
            }
            .pl-md-1,
            .px-md-1,html:not([dir="rtl"]) .pfs-md-1 {
                padding-left: 0.25rem !important;
            }
            *[dir="rtl"] .pfs-md-1,html:not([dir="rtl"]) .pfe-md-1 {
                padding-right: 0.25rem !important;
            }
            *[dir="rtl"] .pfe-md-1 {
                padding-left: 0.25rem !important;
            }
            .p-md-2 {
                padding: 0.5rem !important;
            }
            .pt-md-2,
            .py-md-2 {
                padding-top: 0.5rem !important;
            }
            .pr-md-2,
            .px-md-2 {
                padding-right: 0.5rem !important;
            }
            .pb-md-2,
            .py-md-2 {
                padding-bottom: 0.5rem !important;
            }
            .pl-md-2,
            .px-md-2,html:not([dir="rtl"]) .pfs-md-2 {
                padding-left: 0.5rem !important;
            }
            *[dir="rtl"] .pfs-md-2,html:not([dir="rtl"]) .pfe-md-2 {
                padding-right: 0.5rem !important;
            }
            *[dir="rtl"] .pfe-md-2 {
                padding-left: 0.5rem !important;
            }
            .p-md-3 {
                padding: 1rem !important;
            }
            .pt-md-3,
            .py-md-3 {
                padding-top: 1rem !important;
            }
            .pr-md-3,
            .px-md-3 {
                padding-right: 1rem !important;
            }
            .pb-md-3,
            .py-md-3 {
                padding-bottom: 1rem !important;
            }
            .pl-md-3,
            .px-md-3,html:not([dir="rtl"]) .pfs-md-3 {
                padding-left: 1rem !important;
            }
            *[dir="rtl"] .pfs-md-3,html:not([dir="rtl"]) .pfe-md-3 {
                padding-right: 1rem !important;
            }
            *[dir="rtl"] .pfe-md-3 {
                padding-left: 1rem !important;
            }
            .p-md-4 {
                padding: 1.5rem !important;
            }
            .pt-md-4,
            .py-md-4 {
                padding-top: 1.5rem !important;
            }
            .pr-md-4,
            .px-md-4 {
                padding-right: 1.5rem !important;
            }
            .pb-md-4,
            .py-md-4 {
                padding-bottom: 1.5rem !important;
            }
            .pl-md-4,
            .px-md-4,html:not([dir="rtl"]) .pfs-md-4 {
                padding-left: 1.5rem !important;
            }
            *[dir="rtl"] .pfs-md-4,html:not([dir="rtl"]) .pfe-md-4 {
                padding-right: 1.5rem !important;
            }
            *[dir="rtl"] .pfe-md-4 {
                padding-left: 1.5rem !important;
            }
            .p-md-5 {
                padding: 3rem !important;
            }
            .pt-md-5,
            .py-md-5 {
                padding-top: 3rem !important;
            }
            .pr-md-5,
            .px-md-5 {
                padding-right: 3rem !important;
            }
            .pb-md-5,
            .py-md-5 {
                padding-bottom: 3rem !important;
            }
            .pl-md-5,
            .px-md-5,html:not([dir="rtl"]) .pfs-md-5 {
                padding-left: 3rem !important;
            }
            *[dir="rtl"] .pfs-md-5,html:not([dir="rtl"]) .pfe-md-5 {
                padding-right: 3rem !important;
            }
            *[dir="rtl"] .pfe-md-5 {
                padding-left: 3rem !important;
            }
            .m-md-n1 {
                margin: -0.25rem !important;
            }
            .mt-md-n1,
            .my-md-n1 {
                margin-top: -0.25rem !important;
            }
            .mr-md-n1,
            .mx-md-n1 {
                margin-right: -0.25rem !important;
            }
            .mb-md-n1,
            .my-md-n1 {
                margin-bottom: -0.25rem !important;
            }
            .ml-md-n1,
            .mx-md-n1,html:not([dir="rtl"]) .mfs-md-n1 {
                margin-left: -0.25rem !important;
            }
            *[dir="rtl"] .mfs-md-n1,html:not([dir="rtl"]) .mfe-md-n1 {
                margin-right: -0.25rem !important;
            }
            *[dir="rtl"] .mfe-md-n1 {
                margin-left: -0.25rem !important;
            }
            .m-md-n2 {
                margin: -0.5rem !important;
            }
            .mt-md-n2,
            .my-md-n2 {
                margin-top: -0.5rem !important;
            }
            .mr-md-n2,
            .mx-md-n2 {
                margin-right: -0.5rem !important;
            }
            .mb-md-n2,
            .my-md-n2 {
                margin-bottom: -0.5rem !important;
            }
            .ml-md-n2,
            .mx-md-n2,html:not([dir="rtl"]) .mfs-md-n2 {
                margin-left: -0.5rem !important;
            }
            *[dir="rtl"] .mfs-md-n2,html:not([dir="rtl"]) .mfe-md-n2 {
                margin-right: -0.5rem !important;
            }
            *[dir="rtl"] .mfe-md-n2 {
                margin-left: -0.5rem !important;
            }
            .m-md-n3 {
                margin: -1rem !important;
            }
            .mt-md-n3,
            .my-md-n3 {
                margin-top: -1rem !important;
            }
            .mr-md-n3,
            .mx-md-n3 {
                margin-right: -1rem !important;
            }
            .mb-md-n3,
            .my-md-n3 {
                margin-bottom: -1rem !important;
            }
            .ml-md-n3,
            .mx-md-n3,html:not([dir="rtl"]) .mfs-md-n3 {
                margin-left: -1rem !important;
            }
            *[dir="rtl"] .mfs-md-n3,html:not([dir="rtl"]) .mfe-md-n3 {
                margin-right: -1rem !important;
            }
            *[dir="rtl"] .mfe-md-n3 {
                margin-left: -1rem !important;
            }
            .m-md-n4 {
                margin: -1.5rem !important;
            }
            .mt-md-n4,
            .my-md-n4 {
                margin-top: -1.5rem !important;
            }
            .mr-md-n4,
            .mx-md-n4 {
                margin-right: -1.5rem !important;
            }
            .mb-md-n4,
            .my-md-n4 {
                margin-bottom: -1.5rem !important;
            }
            .ml-md-n4,
            .mx-md-n4,html:not([dir="rtl"]) .mfs-md-n4 {
                margin-left: -1.5rem !important;
            }
            *[dir="rtl"] .mfs-md-n4,html:not([dir="rtl"]) .mfe-md-n4 {
                margin-right: -1.5rem !important;
            }
            *[dir="rtl"] .mfe-md-n4 {
                margin-left: -1.5rem !important;
            }
            .m-md-n5 {
                margin: -3rem !important;
            }
            .mt-md-n5,
            .my-md-n5 {
                margin-top: -3rem !important;
            }
            .mr-md-n5,
            .mx-md-n5 {
                margin-right: -3rem !important;
            }
            .mb-md-n5,
            .my-md-n5 {
                margin-bottom: -3rem !important;
            }
            .ml-md-n5,
            .mx-md-n5,html:not([dir="rtl"]) .mfs-md-n5 {
                margin-left: -3rem !important;
            }
            *[dir="rtl"] .mfs-md-n5,html:not([dir="rtl"]) .mfe-md-n5 {
                margin-right: -3rem !important;
            }
            *[dir="rtl"] .mfe-md-n5 {
                margin-left: -3rem !important;
            }
            .m-md-auto {
                margin: auto !important;
            }
            .mt-md-auto,
            .my-md-auto {
                margin-top: auto !important;
            }
            .mr-md-auto,
            .mx-md-auto {
                margin-right: auto !important;
            }
            .mb-md-auto,
            .my-md-auto {
                margin-bottom: auto !important;
            }
            .ml-md-auto,
            .mx-md-auto,html:not([dir="rtl"]) .mfs-md-auto {
                margin-left: auto !important;
            }
            *[dir="rtl"] .mfs-md-auto,html:not([dir="rtl"]) .mfe-md-auto {
                margin-right: auto !important;
            }
            *[dir="rtl"] .mfe-md-auto {
                margin-left: auto !important;
            }
        }

        @media (min-width: 992px) {
            .m-lg-0 {
                margin: 0 !important;
            }
            .mt-lg-0,
            .my-lg-0 {
                margin-top: 0 !important;
            }
            .mr-lg-0,
            .mx-lg-0 {
                margin-right: 0 !important;
            }
            .mb-lg-0,
            .my-lg-0 {
                margin-bottom: 0 !important;
            }
            .ml-lg-0,
            .mx-lg-0,html:not([dir="rtl"]) .mfs-lg-0 {
                margin-left: 0 !important;
            }
            *[dir="rtl"] .mfs-lg-0,html:not([dir="rtl"]) .mfe-lg-0 {
                margin-right: 0 !important;
            }
            *[dir="rtl"] .mfe-lg-0 {
                margin-left: 0 !important;
            }
            .m-lg-1 {
                margin: 0.25rem !important;
            }
            .mt-lg-1,
            .my-lg-1 {
                margin-top: 0.25rem !important;
            }
            .mr-lg-1,
            .mx-lg-1 {
                margin-right: 0.25rem !important;
            }
            .mb-lg-1,
            .my-lg-1 {
                margin-bottom: 0.25rem !important;
            }
            .ml-lg-1,
            .mx-lg-1,html:not([dir="rtl"]) .mfs-lg-1 {
                margin-left: 0.25rem !important;
            }
            *[dir="rtl"] .mfs-lg-1,html:not([dir="rtl"]) .mfe-lg-1 {
                margin-right: 0.25rem !important;
            }
            *[dir="rtl"] .mfe-lg-1 {
                margin-left: 0.25rem !important;
            }
            .m-lg-2 {
                margin: 0.5rem !important;
            }
            .mt-lg-2,
            .my-lg-2 {
                margin-top: 0.5rem !important;
            }
            .mr-lg-2,
            .mx-lg-2 {
                margin-right: 0.5rem !important;
            }
            .mb-lg-2,
            .my-lg-2 {
                margin-bottom: 0.5rem !important;
            }
            .ml-lg-2,
            .mx-lg-2,html:not([dir="rtl"]) .mfs-lg-2 {
                margin-left: 0.5rem !important;
            }
            *[dir="rtl"] .mfs-lg-2,html:not([dir="rtl"]) .mfe-lg-2 {
                margin-right: 0.5rem !important;
            }
            *[dir="rtl"] .mfe-lg-2 {
                margin-left: 0.5rem !important;
            }
            .m-lg-3 {
                margin: 1rem !important;
            }
            .mt-lg-3,
            .my-lg-3 {
                margin-top: 1rem !important;
            }
            .mr-lg-3,
            .mx-lg-3 {
                margin-right: 1rem !important;
            }
            .mb-lg-3,
            .my-lg-3 {
                margin-bottom: 1rem !important;
            }
            .ml-lg-3,
            .mx-lg-3,html:not([dir="rtl"]) .mfs-lg-3 {
                margin-left: 1rem !important;
            }
            *[dir="rtl"] .mfs-lg-3,html:not([dir="rtl"]) .mfe-lg-3 {
                margin-right: 1rem !important;
            }
            *[dir="rtl"] .mfe-lg-3 {
                margin-left: 1rem !important;
            }
            .m-lg-4 {
                margin: 1.5rem !important;
            }
            .mt-lg-4,
            .my-lg-4 {
                margin-top: 1.5rem !important;
            }
            .mr-lg-4,
            .mx-lg-4 {
                margin-right: 1.5rem !important;
            }
            .mb-lg-4,
            .my-lg-4 {
                margin-bottom: 1.5rem !important;
            }
            .ml-lg-4,
            .mx-lg-4,html:not([dir="rtl"]) .mfs-lg-4 {
                margin-left: 1.5rem !important;
            }
            *[dir="rtl"] .mfs-lg-4,html:not([dir="rtl"]) .mfe-lg-4 {
                margin-right: 1.5rem !important;
            }
            *[dir="rtl"] .mfe-lg-4 {
                margin-left: 1.5rem !important;
            }
            .m-lg-5 {
                margin: 3rem !important;
            }
            .mt-lg-5,
            .my-lg-5 {
                margin-top: 3rem !important;
            }
            .mr-lg-5,
            .mx-lg-5 {
                margin-right: 3rem !important;
            }
            .mb-lg-5,
            .my-lg-5 {
                margin-bottom: 3rem !important;
            }
            .ml-lg-5,
            .mx-lg-5,html:not([dir="rtl"]) .mfs-lg-5 {
                margin-left: 3rem !important;
            }
            *[dir="rtl"] .mfs-lg-5,html:not([dir="rtl"]) .mfe-lg-5 {
                margin-right: 3rem !important;
            }
            *[dir="rtl"] .mfe-lg-5 {
                margin-left: 3rem !important;
            }
            .p-lg-0 {
                padding: 0 !important;
            }
            .pt-lg-0,
            .py-lg-0 {
                padding-top: 0 !important;
            }
            .pr-lg-0,
            .px-lg-0 {
                padding-right: 0 !important;
            }
            .pb-lg-0,
            .py-lg-0 {
                padding-bottom: 0 !important;
            }
            .pl-lg-0,
            .px-lg-0,html:not([dir="rtl"]) .pfs-lg-0 {
                padding-left: 0 !important;
            }
            *[dir="rtl"] .pfs-lg-0,html:not([dir="rtl"]) .pfe-lg-0 {
                padding-right: 0 !important;
            }
            *[dir="rtl"] .pfe-lg-0 {
                padding-left: 0 !important;
            }
            .p-lg-1 {
                padding: 0.25rem !important;
            }
            .pt-lg-1,
            .py-lg-1 {
                padding-top: 0.25rem !important;
            }
            .pr-lg-1,
            .px-lg-1 {
                padding-right: 0.25rem !important;
            }
            .pb-lg-1,
            .py-lg-1 {
                padding-bottom: 0.25rem !important;
            }
            .pl-lg-1,
            .px-lg-1,html:not([dir="rtl"]) .pfs-lg-1 {
                padding-left: 0.25rem !important;
            }
            *[dir="rtl"] .pfs-lg-1,html:not([dir="rtl"]) .pfe-lg-1 {
                padding-right: 0.25rem !important;
            }
            *[dir="rtl"] .pfe-lg-1 {
                padding-left: 0.25rem !important;
            }
            .p-lg-2 {
                padding: 0.5rem !important;
            }
            .pt-lg-2,
            .py-lg-2 {
                padding-top: 0.5rem !important;
            }
            .pr-lg-2,
            .px-lg-2 {
                padding-right: 0.5rem !important;
            }
            .pb-lg-2,
            .py-lg-2 {
                padding-bottom: 0.5rem !important;
            }
            .pl-lg-2,
            .px-lg-2,html:not([dir="rtl"]) .pfs-lg-2 {
                padding-left: 0.5rem !important;
            }
            *[dir="rtl"] .pfs-lg-2,html:not([dir="rtl"]) .pfe-lg-2 {
                padding-right: 0.5rem !important;
            }
            *[dir="rtl"] .pfe-lg-2 {
                padding-left: 0.5rem !important;
            }
            .p-lg-3 {
                padding: 1rem !important;
            }
            .pt-lg-3,
            .py-lg-3 {
                padding-top: 1rem !important;
            }
            .pr-lg-3,
            .px-lg-3 {
                padding-right: 1rem !important;
            }
            .pb-lg-3,
            .py-lg-3 {
                padding-bottom: 1rem !important;
            }
            .pl-lg-3,
            .px-lg-3,html:not([dir="rtl"]) .pfs-lg-3 {
                padding-left: 1rem !important;
            }
            *[dir="rtl"] .pfs-lg-3,html:not([dir="rtl"]) .pfe-lg-3 {
                padding-right: 1rem !important;
            }
            *[dir="rtl"] .pfe-lg-3 {
                padding-left: 1rem !important;
            }
            .p-lg-4 {
                padding: 1.5rem !important;
            }
            .pt-lg-4,
            .py-lg-4 {
                padding-top: 1.5rem !important;
            }
            .pr-lg-4,
            .px-lg-4 {
                padding-right: 1.5rem !important;
            }
            .pb-lg-4,
            .py-lg-4 {
                padding-bottom: 1.5rem !important;
            }
            .pl-lg-4,
            .px-lg-4,html:not([dir="rtl"]) .pfs-lg-4 {
                padding-left: 1.5rem !important;
            }
            *[dir="rtl"] .pfs-lg-4,html:not([dir="rtl"]) .pfe-lg-4 {
                padding-right: 1.5rem !important;
            }
            *[dir="rtl"] .pfe-lg-4 {
                padding-left: 1.5rem !important;
            }
            .p-lg-5 {
                padding: 3rem !important;
            }
            .pt-lg-5,
            .py-lg-5 {
                padding-top: 3rem !important;
            }
            .pr-lg-5,
            .px-lg-5 {
                padding-right: 3rem !important;
            }
            .pb-lg-5,
            .py-lg-5 {
                padding-bottom: 3rem !important;
            }
            .pl-lg-5,
            .px-lg-5,html:not([dir="rtl"]) .pfs-lg-5 {
                padding-left: 3rem !important;
            }
            *[dir="rtl"] .pfs-lg-5,html:not([dir="rtl"]) .pfe-lg-5 {
                padding-right: 3rem !important;
            }
            *[dir="rtl"] .pfe-lg-5 {
                padding-left: 3rem !important;
            }
            .m-lg-n1 {
                margin: -0.25rem !important;
            }
            .mt-lg-n1,
            .my-lg-n1 {
                margin-top: -0.25rem !important;
            }
            .mr-lg-n1,
            .mx-lg-n1 {
                margin-right: -0.25rem !important;
            }
            .mb-lg-n1,
            .my-lg-n1 {
                margin-bottom: -0.25rem !important;
            }
            .ml-lg-n1,
            .mx-lg-n1,html:not([dir="rtl"]) .mfs-lg-n1 {
                margin-left: -0.25rem !important;
            }
            *[dir="rtl"] .mfs-lg-n1,html:not([dir="rtl"]) .mfe-lg-n1 {
                margin-right: -0.25rem !important;
            }
            *[dir="rtl"] .mfe-lg-n1 {
                margin-left: -0.25rem !important;
            }
            .m-lg-n2 {
                margin: -0.5rem !important;
            }
            .mt-lg-n2,
            .my-lg-n2 {
                margin-top: -0.5rem !important;
            }
            .mr-lg-n2,
            .mx-lg-n2 {
                margin-right: -0.5rem !important;
            }
            .mb-lg-n2,
            .my-lg-n2 {
                margin-bottom: -0.5rem !important;
            }
            .ml-lg-n2,
            .mx-lg-n2,html:not([dir="rtl"]) .mfs-lg-n2 {
                margin-left: -0.5rem !important;
            }
            *[dir="rtl"] .mfs-lg-n2,html:not([dir="rtl"]) .mfe-lg-n2 {
                margin-right: -0.5rem !important;
            }
            *[dir="rtl"] .mfe-lg-n2 {
                margin-left: -0.5rem !important;
            }
            .m-lg-n3 {
                margin: -1rem !important;
            }
            .mt-lg-n3,
            .my-lg-n3 {
                margin-top: -1rem !important;
            }
            .mr-lg-n3,
            .mx-lg-n3 {
                margin-right: -1rem !important;
            }
            .mb-lg-n3,
            .my-lg-n3 {
                margin-bottom: -1rem !important;
            }
            .ml-lg-n3,
            .mx-lg-n3,html:not([dir="rtl"]) .mfs-lg-n3 {
                margin-left: -1rem !important;
            }
            *[dir="rtl"] .mfs-lg-n3,html:not([dir="rtl"]) .mfe-lg-n3 {
                margin-right: -1rem !important;
            }
            *[dir="rtl"] .mfe-lg-n3 {
                margin-left: -1rem !important;
            }
            .m-lg-n4 {
                margin: -1.5rem !important;
            }
            .mt-lg-n4,
            .my-lg-n4 {
                margin-top: -1.5rem !important;
            }
            .mr-lg-n4,
            .mx-lg-n4 {
                margin-right: -1.5rem !important;
            }
            .mb-lg-n4,
            .my-lg-n4 {
                margin-bottom: -1.5rem !important;
            }
            .ml-lg-n4,
            .mx-lg-n4,html:not([dir="rtl"]) .mfs-lg-n4 {
                margin-left: -1.5rem !important;
            }
            *[dir="rtl"] .mfs-lg-n4,html:not([dir="rtl"]) .mfe-lg-n4 {
                margin-right: -1.5rem !important;
            }
            *[dir="rtl"] .mfe-lg-n4 {
                margin-left: -1.5rem !important;
            }
            .m-lg-n5 {
                margin: -3rem !important;
            }
            .mt-lg-n5,
            .my-lg-n5 {
                margin-top: -3rem !important;
            }
            .mr-lg-n5,
            .mx-lg-n5 {
                margin-right: -3rem !important;
            }
            .mb-lg-n5,
            .my-lg-n5 {
                margin-bottom: -3rem !important;
            }
            .ml-lg-n5,
            .mx-lg-n5,html:not([dir="rtl"]) .mfs-lg-n5 {
                margin-left: -3rem !important;
            }
            *[dir="rtl"] .mfs-lg-n5,html:not([dir="rtl"]) .mfe-lg-n5 {
                margin-right: -3rem !important;
            }
            *[dir="rtl"] .mfe-lg-n5 {
                margin-left: -3rem !important;
            }
            .m-lg-auto {
                margin: auto !important;
            }
            .mt-lg-auto,
            .my-lg-auto {
                margin-top: auto !important;
            }
            .mr-lg-auto,
            .mx-lg-auto {
                margin-right: auto !important;
            }
            .mb-lg-auto,
            .my-lg-auto {
                margin-bottom: auto !important;
            }
            .ml-lg-auto,
            .mx-lg-auto,html:not([dir="rtl"]) .mfs-lg-auto {
                margin-left: auto !important;
            }
            *[dir="rtl"] .mfs-lg-auto,html:not([dir="rtl"]) .mfe-lg-auto {
                margin-right: auto !important;
            }
            *[dir="rtl"] .mfe-lg-auto {
                margin-left: auto !important;
            }
        }

        @media (min-width: 1200px) {
            .m-xl-0 {
                margin: 0 !important;
            }
            .mt-xl-0,
            .my-xl-0 {
                margin-top: 0 !important;
            }
            .mr-xl-0,
            .mx-xl-0 {
                margin-right: 0 !important;
            }
            .mb-xl-0,
            .my-xl-0 {
                margin-bottom: 0 !important;
            }
            .ml-xl-0,
            .mx-xl-0,html:not([dir="rtl"]) .mfs-xl-0 {
                margin-left: 0 !important;
            }
            *[dir="rtl"] .mfs-xl-0,html:not([dir="rtl"]) .mfe-xl-0 {
                margin-right: 0 !important;
            }
            *[dir="rtl"] .mfe-xl-0 {
                margin-left: 0 !important;
            }
            .m-xl-1 {
                margin: 0.25rem !important;
            }
            .mt-xl-1,
            .my-xl-1 {
                margin-top: 0.25rem !important;
            }
            .mr-xl-1,
            .mx-xl-1 {
                margin-right: 0.25rem !important;
            }
            .mb-xl-1,
            .my-xl-1 {
                margin-bottom: 0.25rem !important;
            }
            .ml-xl-1,
            .mx-xl-1,html:not([dir="rtl"]) .mfs-xl-1 {
                margin-left: 0.25rem !important;
            }
            *[dir="rtl"] .mfs-xl-1,html:not([dir="rtl"]) .mfe-xl-1 {
                margin-right: 0.25rem !important;
            }
            *[dir="rtl"] .mfe-xl-1 {
                margin-left: 0.25rem !important;
            }
            .m-xl-2 {
                margin: 0.5rem !important;
            }
            .mt-xl-2,
            .my-xl-2 {
                margin-top: 0.5rem !important;
            }
            .mr-xl-2,
            .mx-xl-2 {
                margin-right: 0.5rem !important;
            }
            .mb-xl-2,
            .my-xl-2 {
                margin-bottom: 0.5rem !important;
            }
            .ml-xl-2,
            .mx-xl-2,html:not([dir="rtl"]) .mfs-xl-2 {
                margin-left: 0.5rem !important;
            }
            *[dir="rtl"] .mfs-xl-2,html:not([dir="rtl"]) .mfe-xl-2 {
                margin-right: 0.5rem !important;
            }
            *[dir="rtl"] .mfe-xl-2 {
                margin-left: 0.5rem !important;
            }
            .m-xl-3 {
                margin: 1rem !important;
            }
            .mt-xl-3,
            .my-xl-3 {
                margin-top: 1rem !important;
            }
            .mr-xl-3,
            .mx-xl-3 {
                margin-right: 1rem !important;
            }
            .mb-xl-3,
            .my-xl-3 {
                margin-bottom: 1rem !important;
            }
            .ml-xl-3,
            .mx-xl-3,html:not([dir="rtl"]) .mfs-xl-3 {
                margin-left: 1rem !important;
            }
            *[dir="rtl"] .mfs-xl-3,html:not([dir="rtl"]) .mfe-xl-3 {
                margin-right: 1rem !important;
            }
            *[dir="rtl"] .mfe-xl-3 {
                margin-left: 1rem !important;
            }
            .m-xl-4 {
                margin: 1.5rem !important;
            }
            .mt-xl-4,
            .my-xl-4 {
                margin-top: 1.5rem !important;
            }
            .mr-xl-4,
            .mx-xl-4 {
                margin-right: 1.5rem !important;
            }
            .mb-xl-4,
            .my-xl-4 {
                margin-bottom: 1.5rem !important;
            }
            .ml-xl-4,
            .mx-xl-4,html:not([dir="rtl"]) .mfs-xl-4 {
                margin-left: 1.5rem !important;
            }
            *[dir="rtl"] .mfs-xl-4,html:not([dir="rtl"]) .mfe-xl-4 {
                margin-right: 1.5rem !important;
            }
            *[dir="rtl"] .mfe-xl-4 {
                margin-left: 1.5rem !important;
            }
            .m-xl-5 {
                margin: 3rem !important;
            }
            .mt-xl-5,
            .my-xl-5 {
                margin-top: 3rem !important;
            }
            .mr-xl-5,
            .mx-xl-5 {
                margin-right: 3rem !important;
            }
            .mb-xl-5,
            .my-xl-5 {
                margin-bottom: 3rem !important;
            }
            .ml-xl-5,
            .mx-xl-5,html:not([dir="rtl"]) .mfs-xl-5 {
                margin-left: 3rem !important;
            }
            *[dir="rtl"] .mfs-xl-5,html:not([dir="rtl"]) .mfe-xl-5 {
                margin-right: 3rem !important;
            }
            *[dir="rtl"] .mfe-xl-5 {
                margin-left: 3rem !important;
            }
            .p-xl-0 {
                padding: 0 !important;
            }
            .pt-xl-0,
            .py-xl-0 {
                padding-top: 0 !important;
            }
            .pr-xl-0,
            .px-xl-0 {
                padding-right: 0 !important;
            }
            .pb-xl-0,
            .py-xl-0 {
                padding-bottom: 0 !important;
            }
            .pl-xl-0,
            .px-xl-0,html:not([dir="rtl"]) .pfs-xl-0 {
                padding-left: 0 !important;
            }
            *[dir="rtl"] .pfs-xl-0,html:not([dir="rtl"]) .pfe-xl-0 {
                padding-right: 0 !important;
            }
            *[dir="rtl"] .pfe-xl-0 {
                padding-left: 0 !important;
            }
            .p-xl-1 {
                padding: 0.25rem !important;
            }
            .pt-xl-1,
            .py-xl-1 {
                padding-top: 0.25rem !important;
            }
            .pr-xl-1,
            .px-xl-1 {
                padding-right: 0.25rem !important;
            }
            .pb-xl-1,
            .py-xl-1 {
                padding-bottom: 0.25rem !important;
            }
            .pl-xl-1,
            .px-xl-1,html:not([dir="rtl"]) .pfs-xl-1 {
                padding-left: 0.25rem !important;
            }
            *[dir="rtl"] .pfs-xl-1,html:not([dir="rtl"]) .pfe-xl-1 {
                padding-right: 0.25rem !important;
            }
            *[dir="rtl"] .pfe-xl-1 {
                padding-left: 0.25rem !important;
            }
            .p-xl-2 {
                padding: 0.5rem !important;
            }
            .pt-xl-2,
            .py-xl-2 {
                padding-top: 0.5rem !important;
            }
            .pr-xl-2,
            .px-xl-2 {
                padding-right: 0.5rem !important;
            }
            .pb-xl-2,
            .py-xl-2 {
                padding-bottom: 0.5rem !important;
            }
            .pl-xl-2,
            .px-xl-2,html:not([dir="rtl"]) .pfs-xl-2 {
                padding-left: 0.5rem !important;
            }
            *[dir="rtl"] .pfs-xl-2,html:not([dir="rtl"]) .pfe-xl-2 {
                padding-right: 0.5rem !important;
            }
            *[dir="rtl"] .pfe-xl-2 {
                padding-left: 0.5rem !important;
            }
            .p-xl-3 {
                padding: 1rem !important;
            }
            .pt-xl-3,
            .py-xl-3 {
                padding-top: 1rem !important;
            }
            .pr-xl-3,
            .px-xl-3 {
                padding-right: 1rem !important;
            }
            .pb-xl-3,
            .py-xl-3 {
                padding-bottom: 1rem !important;
            }
            .pl-xl-3,
            .px-xl-3,html:not([dir="rtl"]) .pfs-xl-3 {
                padding-left: 1rem !important;
            }
            *[dir="rtl"] .pfs-xl-3,html:not([dir="rtl"]) .pfe-xl-3 {
                padding-right: 1rem !important;
            }
            *[dir="rtl"] .pfe-xl-3 {
                padding-left: 1rem !important;
            }
            .p-xl-4 {
                padding: 1.5rem !important;
            }
            .pt-xl-4,
            .py-xl-4 {
                padding-top: 1.5rem !important;
            }
            .pr-xl-4,
            .px-xl-4 {
                padding-right: 1.5rem !important;
            }
            .pb-xl-4,
            .py-xl-4 {
                padding-bottom: 1.5rem !important;
            }
            .pl-xl-4,
            .px-xl-4,html:not([dir="rtl"]) .pfs-xl-4 {
                padding-left: 1.5rem !important;
            }
            *[dir="rtl"] .pfs-xl-4,html:not([dir="rtl"]) .pfe-xl-4 {
                padding-right: 1.5rem !important;
            }
            *[dir="rtl"] .pfe-xl-4 {
                padding-left: 1.5rem !important;
            }
            .p-xl-5 {
                padding: 3rem !important;
            }
            .pt-xl-5,
            .py-xl-5 {
                padding-top: 3rem !important;
            }
            .pr-xl-5,
            .px-xl-5 {
                padding-right: 3rem !important;
            }
            .pb-xl-5,
            .py-xl-5 {
                padding-bottom: 3rem !important;
            }
            .pl-xl-5,
            .px-xl-5,html:not([dir="rtl"]) .pfs-xl-5 {
                padding-left: 3rem !important;
            }
            *[dir="rtl"] .pfs-xl-5,html:not([dir="rtl"]) .pfe-xl-5 {
                padding-right: 3rem !important;
            }
            *[dir="rtl"] .pfe-xl-5 {
                padding-left: 3rem !important;
            }
            .m-xl-n1 {
                margin: -0.25rem !important;
            }
            .mt-xl-n1,
            .my-xl-n1 {
                margin-top: -0.25rem !important;
            }
            .mr-xl-n1,
            .mx-xl-n1 {
                margin-right: -0.25rem !important;
            }
            .mb-xl-n1,
            .my-xl-n1 {
                margin-bottom: -0.25rem !important;
            }
            .ml-xl-n1,
            .mx-xl-n1,html:not([dir="rtl"]) .mfs-xl-n1 {
                margin-left: -0.25rem !important;
            }
            *[dir="rtl"] .mfs-xl-n1,html:not([dir="rtl"]) .mfe-xl-n1 {
                margin-right: -0.25rem !important;
            }
            *[dir="rtl"] .mfe-xl-n1 {
                margin-left: -0.25rem !important;
            }
            .m-xl-n2 {
                margin: -0.5rem !important;
            }
            .mt-xl-n2,
            .my-xl-n2 {
                margin-top: -0.5rem !important;
            }
            .mr-xl-n2,
            .mx-xl-n2 {
                margin-right: -0.5rem !important;
            }
            .mb-xl-n2,
            .my-xl-n2 {
                margin-bottom: -0.5rem !important;
            }
            .ml-xl-n2,
            .mx-xl-n2,html:not([dir="rtl"]) .mfs-xl-n2 {
                margin-left: -0.5rem !important;
            }
            *[dir="rtl"] .mfs-xl-n2,html:not([dir="rtl"]) .mfe-xl-n2 {
                margin-right: -0.5rem !important;
            }
            *[dir="rtl"] .mfe-xl-n2 {
                margin-left: -0.5rem !important;
            }
            .m-xl-n3 {
                margin: -1rem !important;
            }
            .mt-xl-n3,
            .my-xl-n3 {
                margin-top: -1rem !important;
            }
            .mr-xl-n3,
            .mx-xl-n3 {
                margin-right: -1rem !important;
            }
            .mb-xl-n3,
            .my-xl-n3 {
                margin-bottom: -1rem !important;
            }
            .ml-xl-n3,
            .mx-xl-n3,html:not([dir="rtl"]) .mfs-xl-n3 {
                margin-left: -1rem !important;
            }
            *[dir="rtl"] .mfs-xl-n3,html:not([dir="rtl"]) .mfe-xl-n3 {
                margin-right: -1rem !important;
            }
            *[dir="rtl"] .mfe-xl-n3 {
                margin-left: -1rem !important;
            }
            .m-xl-n4 {
                margin: -1.5rem !important;
            }
            .mt-xl-n4,
            .my-xl-n4 {
                margin-top: -1.5rem !important;
            }
            .mr-xl-n4,
            .mx-xl-n4 {
                margin-right: -1.5rem !important;
            }
            .mb-xl-n4,
            .my-xl-n4 {
                margin-bottom: -1.5rem !important;
            }
            .ml-xl-n4,
            .mx-xl-n4,html:not([dir="rtl"]) .mfs-xl-n4 {
                margin-left: -1.5rem !important;
            }
            *[dir="rtl"] .mfs-xl-n4,html:not([dir="rtl"]) .mfe-xl-n4 {
                margin-right: -1.5rem !important;
            }
            *[dir="rtl"] .mfe-xl-n4 {
                margin-left: -1.5rem !important;
            }
            .m-xl-n5 {
                margin: -3rem !important;
            }
            .mt-xl-n5,
            .my-xl-n5 {
                margin-top: -3rem !important;
            }
            .mr-xl-n5,
            .mx-xl-n5 {
                margin-right: -3rem !important;
            }
            .mb-xl-n5,
            .my-xl-n5 {
                margin-bottom: -3rem !important;
            }
            .ml-xl-n5,
            .mx-xl-n5,html:not([dir="rtl"]) .mfs-xl-n5 {
                margin-left: -3rem !important;
            }
            *[dir="rtl"] .mfs-xl-n5,html:not([dir="rtl"]) .mfe-xl-n5 {
                margin-right: -3rem !important;
            }
            *[dir="rtl"] .mfe-xl-n5 {
                margin-left: -3rem !important;
            }
            .m-xl-auto {
                margin: auto !important;
            }
            .mt-xl-auto,
            .my-xl-auto {
                margin-top: auto !important;
            }
            .mr-xl-auto,
            .mx-xl-auto {
                margin-right: auto !important;
            }
            .mb-xl-auto,
            .my-xl-auto {
                margin-bottom: auto !important;
            }
            .ml-xl-auto,
            .mx-xl-auto,html:not([dir="rtl"]) .mfs-xl-auto {
                margin-left: auto !important;
            }
            *[dir="rtl"] .mfs-xl-auto,html:not([dir="rtl"]) .mfe-xl-auto {
                margin-right: auto !important;
            }
            *[dir="rtl"] .mfe-xl-auto {
                margin-left: auto !important;
            }
        }

        .stretched-link::after {
            position: absolute;
            top: 0;
            right: 0;
            bottom: 0;
            left: 0;
            z-index: 1;
            pointer-events: auto;
            content: "";
            background-color: rgba(0, 0, 21, 0);
        }

        .text-monospace {
            font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace !important;
        }

        .text-justify {
            text-align: justify !important;
        }

        .text-wrap {
            white-space: normal !important;
        }

        .text-nowrap {
            white-space: nowrap !important;
        }

        .text-truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .text-left {
            text-align: left !important;
        }

        .text-right {
            text-align: right !important;
        }

        .text-center {
            text-align: center !important;
        }

        @media (min-width: 576px) {
            .text-sm-left {
                text-align: left !important;
            }
            .text-sm-right {
                text-align: right !important;
            }
            .text-sm-center {
                text-align: center !important;
            }
        }

        @media (min-width: 768px) {
            .text-md-left {
                text-align: left !important;
            }
            .text-md-right {
                text-align: right !important;
            }
            .text-md-center {
                text-align: center !important;
            }
        }

        @media (min-width: 992px) {
            .text-lg-left {
                text-align: left !important;
            }
            .text-lg-right {
                text-align: right !important;
            }
            .text-lg-center {
                text-align: center !important;
            }
        }

        @media (min-width: 1200px) {
            .text-xl-left {
                text-align: left !important;
            }
            .text-xl-right {
                text-align: right !important;
            }
            .text-xl-center {
                text-align: center !important;
            }
        }

        .text-lowercase {
            text-transform: lowercase !important;
        }

        .text-uppercase {
            text-transform: uppercase !important;
        }

        .text-capitalize {
            text-transform: capitalize !important;
        }

        .font-weight-light {
            font-weight: 300 !important;
        }

        .font-weight-lighter {
            font-weight: lighter !important;
        }

        .font-weight-normal {
            font-weight: 400 !important;
        }

        .font-weight-bold {
            font-weight: 700 !important;
        }

        .font-weight-bolder {
            font-weight: bolder !important;
        }

        .font-italic {
            font-style: italic !important;
        }

        .text-white {
            color: #fff !important;
        }

        .text-primary {
            color: #321fdb !important;
        }

        a.text-primary:hover, a.text-primary:focus {
            color: #231698 !important;
        }

        .text-secondary {
            color: #ced2d8 !important;
        }

        a.text-secondary:hover, a.text-secondary:focus {
            color: #a3abb6 !important;
        }

        .text-success {
            color: #2eb85c !important;
        }

        a.text-success:hover, a.text-success:focus {
            color: #1f7b3d !important;
        }

        .text-info {
            color: #39f !important;
        }

        a.text-info:hover, a.text-info:focus {
            color: #0073e6 !important;
        }

        .text-warning {
            color: #f9b115 !important;
        }

        a.text-warning:hover, a.text-warning:focus {
            color: #bd8305 !important;
        }

        .text-danger {
            color: #e55353 !important;
        }

        a.text-danger:hover, a.text-danger:focus {
            color: #cd1f1f !important;
        }

        .text-light {
            color: #ebedef !important;
        }

        a.text-light:hover, a.text-light:focus {
            color: #c1c7cd !important;
        }

        .text-dark {
            color: #636f83 !important;
        }

        a.text-dark:hover, a.text-dark:focus {
            color: #424a57 !important;
        }

        .text-body {
            color: #4f5d73 !important;
        }

        .text-muted {
            color: #768192 !important;
        }

        .text-black-50 {
            color: rgba(0, 0, 21, 0.5) !important;
        }

        .text-white-50 {
            color: rgba(255, 255, 255, 0.5) !important;
        }

        .text-hide {
            font: 0/0 a;
            color: transparent;
            text-shadow: none;
            background-color: transparent;
            border: 0;
        }

        .text-decoration-none {
            text-decoration: none !important;
        }

        .text-break {
            word-break: break-word !important;
            overflow-wrap: break-word !important;
        }

        .text-reset {
            color: inherit !important;
        }

        .font-xs {
            font-size: .75rem !important;
        }

        .font-sm {
            font-size: .85rem !important;
        }

        .font-lg {
            font-size: 1rem !important;
        }

        .font-xl {
            font-size: 1.25rem !important;
        }

        .font-2xl {
            font-size: 1.5rem !important;
        }

        .font-3xl {
            font-size: 1.75rem !important;
        }

        .font-4xl {
            font-size: 2rem !important;
        }

        .font-5xl {
            font-size: 2.5rem !important;
        }

        [class^="text-value"] {
            font-weight: 600;
        }

        .text-value-xs {
            font-size: 0.65625rem;
        }

        .text-value-sm {
            font-size: 0.74375rem;
        }

        .text-value {
            font-size: 0.875rem;
        }

        .text-value-lg {
            font-size: 1.3125rem;
        }

        .text-value-xl {
            font-size: 1.53125rem;
        }

        .text-white .text-muted {
            color: rgba(255, 255, 255, 0.6) !important;
        }

        .visible {
            visibility: visible !important;
        }

        .invisible {
            visibility: hidden !important;
        }

        *[dir="rtl"] {
            direction: rtl;
            unicode-bidi: embed;
        }

        *[dir="rtl"] body {
            text-align: right;
        }

        .ie-custom-properties {
            primary: #321fdb;
            secondary: #ced2d8;
            success: #2eb85c;
            info: #39f;
            warning: #f9b115;
            danger: #e55353;
            light: #ebedef;
            dark: #636f83;
            breakpoint-xs: 0;
            breakpoint-sm: 576px;
            breakpoint-md: 768px;
            breakpoint-lg: 992px;
            breakpoint-xl: 1200px;
        }

        @media print {
            *,
            *::before,
            *::after {
                text-shadow: none !important;
                box-shadow: none !important;
            }
            a:not(.btn) {
                text-decoration: underline;
            }
            abbr[title]::after {
                content: " (" attr(title) ")";
            }
            pre {
                white-space: pre-wrap !important;
            }
            pre,
            blockquote {
                border: 1px solid #9da5b1;
                page-break-inside: avoid;
            }
            thead {
                display: table-header-group;
            }
            tr,
            img {
                page-break-inside: avoid;
            }
            p,
            h2,
            h3 {
                orphans: 3;
                widows: 3;
            }
            h2,
            h3 {
                page-break-after: avoid;
            }
            @page {
                size: a3;
            }
            body,.container {
                min-width: 992px !important;
            }
            .navbar {
                display: none;
            }
            .badge {
                border: 1px solid #000015;
            }
            .table {
                border-collapse: collapse !important;
            }
            .table td,
            .table th {
                background-color: #fff !important;
            }
            .table-bordered th,
            .table-bordered td {
                border: 1px solid #c4c9d0 !important;
            }
            .table-dark {
                color: inherit;
            }
            .table-dark th,
            .table-dark td,
            .table-dark thead th,
            .table-dark tbody + tbody,.table .thead-dark th {
                border-color: #d8dbe0;
            }
            .table .thead-dark th {
                color: inherit;
            }
        }
        /*# sourceMappingURL=style.css.map */
    </style>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        // Shared ID
        gtag('config', 'UA-118965717-3');
        // Bootstrap ID
        gtag('config', 'UA-118965717-5');
    </script>
</head>
<body class="c-app">
<div class="c-wrapper c-fixed-components">
    <div class="c-body">
        <main class="c-main">
            <div class="container-fluid">
                <div class="fade-in">
                    <div class="row">
                        <div class="col-sm-6 col-lg-4">
                            <div class="card text-white bg-gradient-primary">
                                <div class="card-body card-body pb-0 d-flex justify-content-between align-items-start">
                                    <div>
                                        <div class="text-value-lg">200</div>
                                        <div>Number of employees</div>
                                    </div>
                                    <div class="btn-group">
                                        <button class="btn btn-transparent dropdown-toggle p-0" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                            <svg class="c-icon">
                                                <use xlink:href="node_modules/@coreui/icons/sprites/free.svg#cil-settings"></use>
                                            </svg>
                                        </button>
                                        <div class="dropdown-menu dropdown-menu-right"><a class="dropdown-item" href="#">Action</a><a class="dropdown-item" href="#">Another action</a><a class="dropdown-item" href="#">Something else here</a></div>
                                    </div>
                                </div>
                                <div class="c-chart-wrapper mt-3 mx-3" style="height:70px;">
                                    <canvas class="chart" id="card-chart1" height="70"></canvas>
                                </div>
                            </div>
                        </div>
                        <!-- /.col-->
                        <div class="col-sm-6 col-lg-4">
                            <div class="card text-white bg-gradient-warning">
                                <div class="card-body card-body pb-0 d-flex justify-content-between align-items-start">
                                    <div>
                                        <div class="text-value-lg">Employees by age</div>
                                        <div>Average age 28</div>
                                    </div>
                                    <div class="btn-group">
                                        <button class="btn btn-transparent dropdown-toggle p-0" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                            <svg class="c-icon">
                                                <use xlink:href="node_modules/@coreui/icons/sprites/free.svg#cil-settings"></use>
                                            </svg>
                                        </button>
                                        <div class="dropdown-menu dropdown-menu-right"><a class="dropdown-item" href="#">Action</a><a class="dropdown-item" href="#">Another action</a><a class="dropdown-item" href="#">Something else here</a></div>
                                    </div>
                                </div>
                                <div class="c-chart-wrapper mt-3" style="height:70px;">
                                    <canvas class="chart" id="card-chart3" height="70"></canvas>
                                </div>
                            </div>
                        </div>
                        <!-- /.col-->
                        <div class="col-sm-6 col-lg-4">
                            <div class="card text-white bg-gradient-danger">
                                <div class="card-body card-body pb-0 d-flex justify-content-between align-items-start">
                                    <div>
                                        <div class="text-value-lg">Average vacation days left</div>
                                        <div>by team</div>
                                    </div>
                                    <div class="btn-group">
                                        <button class="btn btn-transparent dropdown-toggle p-0" type="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                                            <svg class="c-icon">
                                                <use xlink:href="node_modules/@coreui/icons/sprites/free.svg#cil-settings"></use>
                                            </svg>
                                        </button>
                                        <div class="dropdown-menu dropdown-menu-right"><a class="dropdown-item" href="#">Action</a><a class="dropdown-item" href="#">Another action</a><a class="dropdown-item" href="#">Something else here</a></div>
                                    </div>
                                </div>
                                <div class="c-chart-wrapper mt-3 mx-3" style="height:70px;">
                                    <canvas class="chart" id="card-chart4" height="70"></canvas>
                                </div>
                            </div>
                        </div>
                        <!-- /.col-->
                    </div>
                    <!-- /.row-->
                    <div class="card">
                        <div class="card-body">
                            <div class="d-flex justify-content-between">
                                <div>
                                    <h4 class="card-title mb-0">Overtime</h4>
                                    <div class="small text-muted">Average overtime in minutes for September 2019</div>
                                </div>
                                <div class="btn-toolbar d-none d-md-block" role="toolbar" aria-label="Toolbar with buttons">
                                    <div class="btn-group btn-group-toggle mx-3" data-toggle="buttons">
                                        <label class="btn btn-outline-secondary">
                                            <input id="option1" type="radio" name="options" autocomplete="off"> Day
                                        </label>
                                        <label class="btn btn-outline-secondary active">
                                            <input id="option2" type="radio" name="options" autocomplete="off" checked=""> Month
                                        </label>
                                        <label class="btn btn-outline-secondary">
                                            <input id="option3" type="radio" name="options" autocomplete="off"> Year
                                        </label>
                                    </div>
                                    <button class="btn btn-primary" type="button">
                                        <svg class="c-icon">
                                            <use xlink:href="node_modules/@coreui/icons/sprites/free.svg#cil-cloud-download"></use>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                            <div class="c-chart-wrapper" style="height:300px;margin-top:40px;">
                                <canvas class="chart" id="main-chart" height="300"></canvas>
                            </div>
                        </div>
                    </div>
                    <!-- /.row-->
                    <div class="row" style="margin: 0px;">
                        <div class="card-columns cols-3">
                            <div class="card">
                                <div class="card-header">Gender Ratio
                                    <div class="card-header-actions"><a class="card-header-action" href="http://www.chartjs.org" target="_blank"><small class="text-muted">docs</small></a></div>
                                </div>
                                <div class="card-body">
                                    <div class="c-chart-wrapper">
                                        <canvas id="canvas-2"></canvas>
                                    </div>
                                </div>
                            </div>
                            <div class="card">
                                <div class="card-header">Employment Status
                                    <div class="card-header-actions"><a class="card-header-action" href="http://www.chartjs.org" target="_blank"><small class="text-muted">docs</small></a></div>
                                </div>
                                <div class="card-body">
                                    <div class="c-chart-wrapper">
                                        <canvas id="canvas-7"></canvas>
                                    </div>
                                </div>
                            </div>
                            <div class="card">
                                <div class="card-header">Employees on the break
                                    <div class="card-header-actions"><a class="card-header-action" href="http://www.chartjs.org" target="_blank"><small class="text-muted">docs</small></a></div>
                                </div>
                                <div class="card-body">
                                    <div class="c-chart-wrapper">
                                        <canvas id="canvas-6"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="card-columns cols-2">

                            <div class="card">
                                <div class="card-header">Vacation Stats Today
                                    <div class="card-header-actions"><a class="card-header-action" href="http://www.chartjs.org" target="_blank"><small class="text-muted">docs</small></a></div>
                                </div>
                                <div class="card-body">
                                    <div class="c-chart-wrapper">
                                        <canvas id="canvas-3"></canvas>
                                    </div>
                                </div>
                            </div>
                            <div class="card">
                                <div class="card-header">Employee Growth
                                    <div class="card-header-actions"><a class="card-header-action" href="http://www.chartjs.org" target="_blank"><small class="text-muted">docs</small></a></div>
                                </div>
                                <div class="card-body">
                                    <div class="c-chart-wrapper">
                                        <canvas id="canvas-8"></canvas>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="row">
                        <div class="col-md-12">
                            <div class="card">
                                <div class="card-header">Employees</div>
                                <div class="card-body">
                                    <br>
                                    <table class="table table-responsive-sm table-hover table-outline mb-0">
                                        <thead class="thead-light">
                                        <tr>
                                            <th class="text-center">
                                                <svg class="c-icon">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/free.svg#cil-people"></use>
                                                </svg>
                                            </th>
                                            <th>User</th>
                                            <th class="text-center"></th>
                                            <th>Ratings</th>
                                            <th class="text-center"></th>
                                            <th>Activity</th>
                                        </tr>
                                        </thead>
                                        <tbody>
                                        <tr>
                                            <td class="text-center">
                                                <div class="c-avatar"><img class="c-avatar-img" src="assets/img/avatars/1.jpg" alt="user@email.com"><span class="c-avatar-status bg-success"></span></div>
                                            </td>
                                            <td>
                                                <div>Yiorgos Avraamu</div>
                                                <div class="small text-muted"><span>New</span> | Registered: Jan 1, 2015</div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/flag.svg#cif-us"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="clearfix">
                                                    <div class="float-left"><strong>50%</strong></div>
                                                    <div class="float-right"><small class="text-muted">Jun 11, 2015 - Jul 10, 2015</small></div>
                                                </div>
                                                <div class="progress progress-xs">
                                                    <div class="progress-bar bg-gradient-success" role="progressbar" style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"></div>
                                                </div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/brand.svg#cib-cc-mastercard"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="small text-muted">Last login</div><strong>10 sec ago</strong>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="text-center">
                                                <div class="c-avatar"><img class="c-avatar-img" src="assets/img/avatars/2.jpg" alt="user@email.com"><span class="c-avatar-status bg-danger"></span></div>
                                            </td>
                                            <td>
                                                <div>Avram Tarasios</div>
                                                <div class="small text-muted"><span>Recurring</span> | Registered: Jan 1, 2015</div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/flag.svg#cif-br"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="clearfix">
                                                    <div class="float-left"><strong>10%</strong></div>
                                                    <div class="float-right"><small class="text-muted">Jun 11, 2015 - Jul 10, 2015</small></div>
                                                </div>
                                                <div class="progress progress-xs">
                                                    <div class="progress-bar bg-gradient-info" role="progressbar" style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"></div>
                                                </div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/brand.svg#cib-cc-visa"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="small text-muted">Last login</div><strong>5 minutes ago</strong>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="text-center">
                                                <div class="c-avatar"><img class="c-avatar-img" src="assets/img/avatars/3.jpg" alt="user@email.com"><span class="c-avatar-status bg-warning"></span></div>
                                            </td>
                                            <td>
                                                <div>Quintin Ed</div>
                                                <div class="small text-muted"><span>New</span> | Registered: Jan 1, 2015</div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/flag.svg#cif-in"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="clearfix">
                                                    <div class="float-left"><strong>74%</strong></div>
                                                    <div class="float-right"><small class="text-muted">Jun 11, 2015 - Jul 10, 2015</small></div>
                                                </div>
                                                <div class="progress progress-xs">
                                                    <div class="progress-bar bg-gradient-warning" role="progressbar" style="width: 74%" aria-valuenow="74" aria-valuemin="0" aria-valuemax="100"></div>
                                                </div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/brand.svg#cib-cc-stripe"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="small text-muted">Last login</div><strong>1 hour ago</strong>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="text-center">
                                                <div class="c-avatar"><img class="c-avatar-img" src="assets/img/avatars/4.jpg" alt="user@email.com"><span class="c-avatar-status bg-secondary"></span></div>
                                            </td>
                                            <td>
                                                <div>En√©as Kwadwo</div>
                                                <div class="small text-muted"><span>New</span> | Registered: Jan 1, 2015</div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/flag.svg#cif-fr"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="clearfix">
                                                    <div class="float-left"><strong>98%</strong></div>
                                                    <div class="float-right"><small class="text-muted">Jun 11, 2015 - Jul 10, 2015</small></div>
                                                </div>
                                                <div class="progress progress-xs">
                                                    <div class="progress-bar bg-gradient-danger" role="progressbar" style="width: 98%" aria-valuenow="98" aria-valuemin="0" aria-valuemax="100"></div>
                                                </div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/brand.svg#cib-cc-paypal"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="small text-muted">Last login</div><strong>Last month</strong>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="text-center">
                                                <div class="c-avatar"><img class="c-avatar-img" src="assets/img/avatars/5.jpg" alt="user@email.com"><span class="c-avatar-status bg-success"></span></div>
                                            </td>
                                            <td>
                                                <div>Agapetus Tade√°≈°</div>
                                                <div class="small text-muted"><span>New</span> | Registered: Jan 1, 2015</div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/flag.svg#cif-es"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="clearfix">
                                                    <div class="float-left"><strong>22%</strong></div>
                                                    <div class="float-right"><small class="text-muted">Jun 11, 2015 - Jul 10, 2015</small></div>
                                                </div>
                                                <div class="progress progress-xs">
                                                    <div class="progress-bar bg-gradient-info" role="progressbar" style="width: 22%" aria-valuenow="22" aria-valuemin="0" aria-valuemax="100"></div>
                                                </div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/brand.svg#cib-cc-apple-pay"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="small text-muted">Last login</div><strong>Last week</strong>
                                            </td>
                                        </tr>
                                        <tr>
                                            <td class="text-center">
                                                <div class="c-avatar"><img class="c-avatar-img" src="assets/img/avatars/6.jpg" alt="user@email.com"><span class="c-avatar-status bg-danger"></span></div>
                                            </td>
                                            <td>
                                                <div>Friderik D√°vid</div>
                                                <div class="small text-muted"><span>New</span> | Registered: Jan 1, 2015</div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/flag.svg#cif-pl"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="clearfix">
                                                    <div class="float-left"><strong>43%</strong></div>
                                                    <div class="float-right"><small class="text-muted">Jun 11, 2015 - Jul 10, 2015</small></div>
                                                </div>
                                                <div class="progress progress-xs">
                                                    <div class="progress-bar bg-gradient-success" role="progressbar" style="width: 43%" aria-valuenow="43" aria-valuemin="0" aria-valuemax="100"></div>
                                                </div>
                                            </td>
                                            <td class="text-center">
                                                <svg class="c-icon c-icon-xl">
                                                    <use xlink:href="node_modules/@coreui/icons/sprites/brand.svg#cib-cc-amex"></use>
                                                </svg>
                                            </td>
                                            <td>
                                                <div class="small text-muted">Last login</div><strong>Yesterday</strong>
                                            </td>
                                        </tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <!-- /.col-->
                    </div>
                    <!-- /.row-->
                </div>
            </div>
        </main>
    </div>
</div>
</body>
<script>
    /*!
* CoreUI v3.2.0 (https://coreui.io)
* Copyright 2020 creativeLabs ≈Åukasz Holeczek
* Licensed under MIT (https://coreui.io)
*/
    !function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t=t||self).coreui=e()}(this,(function(){"use strict";function t(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function e(e,n,i){return n&&t(e.prototype,n),i&&t(e,i),e}function n(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function i(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}function o(t){for(var e=1;e<arguments.length;e++){var o=null!=arguments[e]?arguments[e]:{};e%2?i(Object(o),!0).forEach((function(e){n(t,e,o[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(o)):i(Object(o)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(o,e))}))}return t}var r,s,a,l,c=function(t){do{t+=Math.floor(1e6*Math.random())}while(document.getElementById(t));return t},u=function(t){var e=t.getAttribute("data-target");if(!e||"#"===e){var n=t.getAttribute("href");e=n&&"#"!==n?n.trim():null}return e},f=function(t){var e=u(t);return e&&document.querySelector(e)?e:null},d=function(t){var e=u(t);return e?document.querySelector(e):null},h=function(t){if(!t)return 0;var e=window.getComputedStyle(t),n=e.transitionDuration,i=e.transitionDelay,o=parseFloat(n),r=parseFloat(i);return o||r?(n=n.split(",")[0],i=i.split(",")[0],1e3*(parseFloat(n)+parseFloat(i))):0},p=function(t){t.dispatchEvent(new Event("transitionend"))},g=function(t){return(t[0]||t).nodeType},m=function(t,e){var n=!1,i=e+5;t.addEventListener("transitionend",(function e(){n=!0,t.removeEventListener("transitionend",e)})),setTimeout((function(){n||p(t)}),i)},v=function(t,e,n){Object.keys(n).forEach((function(i){var o,r=n[i],s=e[i],a=s&&g(s)?"element":null==(o=s)?""+o:{}.toString.call(o).match(/\s([a-z]+)/i)[1].toLowerCase();if(!new RegExp(r).test(a))throw new Error(t.toUpperCase()+': Option "'+i+'" provided type "'+a+'" but expected type "'+r+'".')}))},_=function(t){if(!t)return!1;if(t.style&&t.parentNode&&t.parentNode.style){var e=getComputedStyle(t),n=getComputedStyle(t.parentNode);return"none"!==e.display&&"none"!==n.display&&"hidden"!==e.visibility}return!1},b=function(){return function(){}},y=function(t){return t.offsetHeight},w=function(){var t=window.jQuery;return t&&!document.body.hasAttribute("data-no-jquery")?t:null},E=(r={},s=1,{set:function(t,e,n){"undefined"==typeof t.key&&(t.key={key:e,id:s},s++),r[t.key.id]=n},get:function(t,e){if(!t||"undefined"==typeof t.key)return null;var n=t.key;return n.key===e?r[n.id]:null},delete:function(t,e){if("undefined"!=typeof t.key){var n=t.key;n.key===e&&(delete r[n.id],delete t.key)}}}),L=function(t,e,n){E.set(t,e,n)},k=function(t,e){return E.get(t,e)},T=function(t,e){E.delete(t,e)},A=Element.prototype.querySelectorAll,O=Element.prototype.querySelector,S=(a=new CustomEvent("Bootstrap",{cancelable:!0}),(l=document.createElement("div")).addEventListener("Bootstrap",(function(){return null})),a.preventDefault(),l.dispatchEvent(a),a.defaultPrevented),C=/:scope\b/;(function(){var t=document.createElement("div");try{t.querySelectorAll(":scope *")}catch(t){return!1}return!0})()||(A=function(t){if(!C.test(t))return this.querySelectorAll(t);var e=Boolean(this.id);e||(this.id=c("scope"));var n=null;try{t=t.replace(C,"#"+this.id),n=this.querySelectorAll(t)}finally{e||this.removeAttribute("id")}return n},O=function(t){if(!C.test(t))return this.querySelector(t);var e=A.call(this,t);return"undefined"!=typeof e[0]?e[0]:null});var D=w(),x=/[^.]*(?=\..*)\.|.*/,j=/\..*/,N=/::\d+$/,I={},P=1,R={mouseenter:"mouseover",mouseleave:"mouseout"},M=["click","dblclick","mouseup","mousedown","contextmenu","mousewheel","DOMMouseScroll","mouseover","mouseout","mousemove","selectstart","selectend","keydown","keypress","keyup","orientationchange","touchstart","touchmove","touchend","touchcancel","pointerdown","pointermove","pointerup","pointerleave","pointercancel","gesturestart","gesturechange","gestureend","focus","blur","change","reset","select","submit","focusin","focusout","load","unload","beforeunload","resize","move","DOMContentLoaded","readystatechange","error","abort","scroll"];function H(t,e){return e&&e+"::"+P++||t.uidEvent||P++}function W(t){var e=H(t);return t.uidEvent=e,I[e]=I[e]||{},I[e]}function Y(t,e,n){void 0===n&&(n=null);for(var i=Object.keys(t),o=0,r=i.length;o<r;o++){var s=t[i[o]];if(s.originalHandler===e&&s.delegationSelector===n)return s}return null}function X(t,e,n){var i="string"==typeof e,o=i?n:e,r=t.replace(j,""),s=R[r];return s&&(r=s),M.indexOf(r)>-1||(r=t),[i,o,r]}function B(t,e,n,i,o){if("string"==typeof e&&t){n||(n=i,i=null);var r=X(e,n,i),s=r[0],a=r[1],l=r[2],c=W(t),u=c[l]||(c[l]={}),f=Y(u,a,s?n:null);if(f)f.oneOff=f.oneOff&&o;else{var d=H(a,e.replace(x,"")),h=s?function(t,e,n){return function i(o){for(var r=t.querySelectorAll(e),s=o.target;s&&s!==this;s=s.parentNode)for(var a=r.length;a--;)if(r[a]===s)return i.oneOff&&q.off(t,o.type,n),n.apply(s,[o]);return null}}(t,n,i):function(t,e){return function n(i){return n.oneOff&&q.off(t,i.type,e),e.apply(t,[i])}}(t,n);h.delegationSelector=s?n:null,h.originalHandler=a,h.oneOff=o,h.uidEvent=d,u[d]=h,t.addEventListener(l,h,s)}}}function U(t,e,n,i,o){var r=Y(e[n],i,o);r&&(t.removeEventListener(n,r,Boolean(o)),delete e[n][r.uidEvent])}var q={on:function(t,e,n,i){B(t,e,n,i,!1)},one:function(t,e,n,i){B(t,e,n,i,!0)},off:function(t,e,n,i){if("string"==typeof e&&t){var o=X(e,n,i),r=o[0],s=o[1],a=o[2],l=a!==e,c=W(t),u="."===e.charAt(0);if("undefined"==typeof s){u&&Object.keys(c).forEach((function(n){!function(t,e,n,i){var o=e[n]||{};Object.keys(o).forEach((function(r){if(r.indexOf(i)>-1){var s=o[r];U(t,e,n,s.originalHandler,s.delegationSelector)}}))}(t,c,n,e.slice(1))}));var f=c[a]||{};Object.keys(f).forEach((function(n){var i=n.replace(N,"");if(!l||e.indexOf(i)>-1){var o=f[n];U(t,c,a,o.originalHandler,o.delegationSelector)}}))}else{if(!c||!c[a])return;U(t,c,a,s,r?n:null)}}},trigger:function(t,e,n){if("string"!=typeof e||!t)return null;var i,o=e.replace(j,""),r=e!==o,s=M.indexOf(o)>-1,a=!0,l=!0,c=!1,u=null;return r&&D&&(i=D.Event(e,n),D(t).trigger(i),a=!i.isPropagationStopped(),l=!i.isImmediatePropagationStopped(),c=i.isDefaultPrevented()),s?(u=document.createEvent("HTMLEvents")).initEvent(o,a,!0):u=new CustomEvent(e,{bubbles:a,cancelable:!0}),"undefined"!=typeof n&&Object.keys(n).forEach((function(t){Object.defineProperty(u,t,{get:function(){return n[t]}})})),c&&(u.preventDefault(),S||Object.defineProperty(u,"defaultPrevented",{get:function(){return!0}})),l&&t.dispatchEvent(u),u.defaultPrevented&&"undefined"!=typeof i&&i.preventDefault(),u}},F="asyncLoad",Q=".c-xhr-link, .c-sidebar-nav-link",z={defaultPage:"main.html",errorPage:"404.html",subpagesDirectory:"views/"},V=function(){function t(t,e){this._config=this._getConfig(e),this._element=t;var n=location.hash.replace(/^#/,"");""!==n?this._setUpUrl(n):this._setUpUrl(this._config.defaultPage),this._addEventListeners()}var n=t.prototype;return n._getConfig=function(t){return t=o(o({},z),t)},n._loadPage=function(t){var e=this,n=this._element,i=this._config,o=new XMLHttpRequest;o.open("GET",i.subpagesDirectory+t);var r=new CustomEvent("xhr",{detail:{url:t,status:o.status}});n.dispatchEvent(r),o.onload=function(s){if(200===o.status){r=new CustomEvent("xhr",{detail:{url:t,status:o.status}}),n.dispatchEvent(r);var a=document.createElement("div");a.innerHTML=s.target.response;var l=Array.from(a.querySelectorAll("script")).map((function(t){return t.attributes.getNamedItem("src").nodeValue}));a.querySelectorAll("script").forEach((function(t){return t.remove(t)})),window.scrollTo(0,0),n.innerHTML="",n.appendChild(a),(c=document.querySelectorAll(".view-script")).length&&c.forEach((function(t){t.remove()})),l.length&&function t(n,i){void 0===i&&(i=0);var o=document.createElement("script");o.type="text/javascript",o.src=n[i],o.className="view-script",o.onload=o.onreadystatechange=function(){e.readyState&&"complete"!==e.readyState||n.length>i+1&&t(n,i+1)},document.getElementsByTagName("body")[0].appendChild(o)}(l),window.location.hash=t}else window.location.href=i.errorPage;var c},o.send()},n._setUpUrl=function(t){t=t.replace(/^\//,"").split("?")[0],Array.from(document.querySelectorAll(Q)).forEach((function(t){t.classList.remove("c-active")})),Array.from(document.querySelectorAll(Q)).forEach((function(t){t.classList.remove("c-active")})),Array.from(document.querySelectorAll(".c-sidebar-nav-dropdown")).forEach((function(t){t.classList.remove("c-show")})),Array.from(document.querySelectorAll(".c-sidebar-nav-dropdown")).forEach((function(e){Array.from(e.querySelectorAll('a[href*="'+t+'"]')).length>0&&e.classList.add("c-show")})),Array.from(document.querySelectorAll('.c-sidebar-nav-item a[href*="'+t+'"]')).forEach((function(t){t.classList.add("c-active")})),this._loadPage(t)},n._loadBlank=function(t){window.open(t)},n._loadTop=function(t){window.location=t},n._update=function(t){"#"!==t.href&&("undefined"!=typeof t.dataset.toggle&&"null"!==t.dataset.toggle||("_top"===t.target?this._loadTop(t.href):"_blank"===t.target?this._loadBlank(t.href):this._setUpUrl(t.getAttribute("href"))))},n._addEventListeners=function(){var t=this;q.on(document,"click.coreui.asyncLoad.data-api",Q,(function(e){e.preventDefault();var n=e.target;n.classList.contains("c-sidebar-nav-link")||(n=n.closest(Q)),n.classList.contains("c-sidebar-nav-dropdown-toggle")||"#"===n.getAttribute("href")||t._update(n)}))},t._asyncLoadInterface=function(e,n){var i=k(e,"coreui.asyncLoad");if(i||(i=new t(e,"object"==typeof n&&n)),"string"==typeof n){if("undefined"==typeof i[n])throw new TypeError('No method named "'+n+'"');i[n]()}},t.jQueryInterface=function(e){return this.each((function(){t._asyncLoadInterface(this,e)}))},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return z}}]),t}(),K=w();if(K){var $=K.fn[F];K.fn[F]=V.jQueryInterface,K.fn[F].Constructor=V,K.fn[F].noConflict=function(){return K.fn[F]=$,V.jQueryInterface}}var J=function(){function t(t){this._element=t,this._element&&L(t,"coreui.alert",this)}var n=t.prototype;return n.close=function(t){var e=this._element;t&&(e=this._getRootElement(t));var n=this._triggerCloseEvent(e);null===n||n.defaultPrevented||this._removeElement(e)},n.dispose=function(){T(this._element,"coreui.alert"),this._element=null},n._getRootElement=function(t){return d(t)||t.closest(".alert")},n._triggerCloseEvent=function(t){return q.trigger(t,"close.coreui.alert")},n._removeElement=function(t){var e=this;if(t.classList.remove("show"),t.classList.contains("fade")){var n=h(t);q.one(t,"transitionend",(function(){return e._destroyElement(t)})),m(t,n)}else this._destroyElement(t)},n._destroyElement=function(t){t.parentNode&&t.parentNode.removeChild(t),q.trigger(t,"closed.coreui.alert")},t.jQueryInterface=function(e){return this.each((function(){var n=k(this,"coreui.alert");n||(n=new t(this)),"close"===e&&n[e](this)}))},t.handleDismiss=function(t){return function(e){e&&e.preventDefault(),t.close(this)}},t.getInstance=function(t){return k(t,"coreui.alert")},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}}]),t}();q.on(document,"click.coreui.alert.data-api",'[data-dismiss="alert"]',J.handleDismiss(new J));var G=w();if(G){var Z=G.fn.alert;G.fn.alert=J.jQueryInterface,G.fn.alert.Constructor=J,G.fn.alert.noConflict=function(){return G.fn.alert=Z,J.jQueryInterface}}var tt={matches:function(t,e){return t.matches(e)},find:function(t,e){var n;return void 0===e&&(e=document.documentElement),(n=[]).concat.apply(n,A.call(e,t))},findOne:function(t,e){return void 0===e&&(e=document.documentElement),O.call(e,t)},children:function(t,e){var n,i=(n=[]).concat.apply(n,t.children);return i.filter((function(t){return t.matches(e)}))},parents:function(t,e){for(var n=[],i=t.parentNode;i&&i.nodeType===Node.ELEMENT_NODE&&3!==i.nodeType;)this.matches(i,e)&&n.push(i),i=i.parentNode;return n},prev:function(t,e){for(var n=t.previousElementSibling;n;){if(n.matches(e))return[n];n=n.previousElementSibling}return[]},next:function(t,e){for(var n=t.nextElementSibling;n;){if(this.matches(n,e))return[n];n=n.nextElementSibling}return[]}},et="coreui.button",nt=function(){function t(t){this._element=t,L(t,et,this)}var n=t.prototype;return n.toggle=function(){var t=!0,e=!0,n=this._element.closest('[data-toggle="buttons"]');if(n){var i=tt.findOne('input:not([type="hidden"])',this._element);if(i&&"radio"===i.type){if(i.checked&&this._element.classList.contains("active"))t=!1;else{var o=tt.findOne(".active",n);o&&o.classList.remove("active")}if(t){if(i.hasAttribute("disabled")||n.hasAttribute("disabled")||i.classList.contains("disabled")||n.classList.contains("disabled"))return;i.checked=!this._element.classList.contains("active"),q.trigger(i,"change")}i.focus(),e=!1}}e&&this._element.setAttribute("aria-pressed",!this._element.classList.contains("active")),t&&this._element.classList.toggle("active")},n.dispose=function(){T(this._element,et),this._element=null},t.jQueryInterface=function(e){return this.each((function(){var n=k(this,et);n||(n=new t(this)),"toggle"===e&&n[e]()}))},t.getInstance=function(t){return k(t,et)},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}}]),t}();q.on(document,"click.coreui.button.data-api",'[data-toggle^="button"]',(function(t){t.preventDefault();var e=t.target.closest(".btn"),n=k(e,et);n||(n=new nt(e)),n.toggle()})),q.on(document,"focus.coreui.button.data-api",'[data-toggle^="button"]',(function(t){var e=t.target.closest(".btn");e&&e.classList.add("focus")})),q.on(document,"blur.coreui.button.data-api",'[data-toggle^="button"]',(function(t){var e=t.target.closest(".btn");e&&e.classList.remove("focus")}));var it=w();if(it){var ot=it.fn.button;it.fn.button=nt.jQueryInterface,it.fn.button.Constructor=nt,it.fn.button.noConflict=function(){return it.fn.button=ot,nt.jQueryInterface}}function rt(t){return"true"===t||"false"!==t&&(t===Number(t).toString()?Number(t):""===t||"null"===t?null:t)}function st(t){return t.replace(/[A-Z]/g,(function(t){return"-"+t.toLowerCase()}))}var at={setDataAttribute:function(t,e,n){t.setAttribute("data-"+st(e),n)},removeDataAttribute:function(t,e){t.removeAttribute("data-"+st(e))},getDataAttributes:function(t){if(!t)return{};var e=o({},t.dataset);return Object.keys(e).forEach((function(t){e[t]=rt(e[t])})),e},getDataAttribute:function(t,e){return rt(t.getAttribute("data-"+st(e)))},offset:function(t){var e=t.getBoundingClientRect();return{top:e.top+document.body.scrollTop,left:e.left+document.body.scrollLeft}},position:function(t){return{top:t.offsetTop,left:t.offsetLeft}},toggleClass:function(t,e){t&&(t.classList.contains(e)?t.classList.remove(e):t.classList.add(e))}},lt="carousel",ct="coreui.carousel",ut="."+ct,ft={interval:5e3,keyboard:!0,slide:!1,pause:"hover",wrap:!0,touch:!0},dt={interval:"(number|boolean)",keyboard:"boolean",slide:"(boolean|string)",pause:"(string|boolean)",wrap:"boolean",touch:"boolean"},ht="slid"+ut,pt={TOUCH:"touch",PEN:"pen"},gt=function(){function t(t,e){this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this.touchStartX=0,this.touchDeltaX=0,this._config=this._getConfig(e),this._element=t,this._indicatorsElement=tt.findOne(".carousel-indicators",this._element),this._touchSupported="ontouchstart"in document.documentElement||navigator.maxTouchPoints>0,this._pointerEvent=Boolean(window.PointerEvent||window.MSPointerEvent),this._addEventListeners(),L(t,ct,this)}var n=t.prototype;return n.next=function(){this._isSliding||this._slide("next")},n.nextWhenVisible=function(){!document.hidden&&_(this._element)&&this.next()},n.prev=function(){this._isSliding||this._slide("prev")},n.pause=function(t){t||(this._isPaused=!0),tt.findOne(".carousel-item-next, .carousel-item-prev",this._element)&&(p(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null},n.cycle=function(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config&&this._config.interval&&!this._isPaused&&(this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))},n.to=function(t){var e=this;this._activeElement=tt.findOne(".active.carousel-item",this._element);var n=this._getItemIndex(this._activeElement);if(!(t>this._items.length-1||t<0))if(this._isSliding)q.one(this._element,ht,(function(){return e.to(t)}));else{if(n===t)return this.pause(),void this.cycle();var i=t>n?"next":"prev";this._slide(i,this._items[t])}},n.dispose=function(){q.off(this._element,ut),T(this._element,ct),this._items=null,this._config=null,this._element=null,this._interval=null,this._isPaused=null,this._isSliding=null,this._activeElement=null,this._indicatorsElement=null},n._getConfig=function(t){return t=o(o({},ft),t),v(lt,t,dt),t},n._handleSwipe=function(){var t=Math.abs(this.touchDeltaX);if(!(t<=40)){var e=t/this.touchDeltaX;this.touchDeltaX=0,e>0&&this.prev(),e<0&&this.next()}},n._addEventListeners=function(){var t=this;this._config.keyboard&&q.on(this._element,"keydown.coreui.carousel",(function(e){return t._keydown(e)})),"hover"===this._config.pause&&(q.on(this._element,"mouseenter.coreui.carousel",(function(e){return t.pause(e)})),q.on(this._element,"mouseleave.coreui.carousel",(function(e){return t.cycle(e)}))),this._config.touch&&this._touchSupported&&this._addTouchEventListeners()},n._addTouchEventListeners=function(){var t=this,e=function(e){t._pointerEvent&&pt[e.pointerType.toUpperCase()]?t.touchStartX=e.clientX:t._pointerEvent||(t.touchStartX=e.touches[0].clientX)},n=function(e){t._pointerEvent&&pt[e.pointerType.toUpperCase()]&&(t.touchDeltaX=e.clientX-t.touchStartX),t._handleSwipe(),"hover"===t._config.pause&&(t.pause(),t.touchTimeout&&clearTimeout(t.touchTimeout),t.touchTimeout=setTimeout((function(e){return t.cycle(e)}),500+t._config.interval))};tt.find(".carousel-item img",this._element).forEach((function(t){q.on(t,"dragstart.coreui.carousel",(function(t){return t.preventDefault()}))})),this._pointerEvent?(q.on(this._element,"pointerdown.coreui.carousel",(function(t){return e(t)})),q.on(this._element,"pointerup.coreui.carousel",(function(t){return n(t)})),this._element.classList.add("pointer-event")):(q.on(this._element,"touchstart.coreui.carousel",(function(t){return e(t)})),q.on(this._element,"touchmove.coreui.carousel",(function(e){return function(e){e.touches&&e.touches.length>1?t.touchDeltaX=0:t.touchDeltaX=e.touches[0].clientX-t.touchStartX}(e)})),q.on(this._element,"touchend.coreui.carousel",(function(t){return n(t)})))},n._keydown=function(t){if(!/input|textarea/i.test(t.target.tagName))switch(t.key){case"ArrowLeft":t.preventDefault(),this.prev();break;case"ArrowRight":t.preventDefault(),this.next()}},n._getItemIndex=function(t){return this._items=t&&t.parentNode?tt.find(".carousel-item",t.parentNode):[],this._items.indexOf(t)},n._getItemByDirection=function(t,e){var n="next"===t,i="prev"===t,o=this._getItemIndex(e),r=this._items.length-1;if((i&&0===o||n&&o===r)&&!this._config.wrap)return e;var s=(o+("prev"===t?-1:1))%this._items.length;return-1===s?this._items[this._items.length-1]:this._items[s]},n._triggerSlideEvent=function(t,e){var n=this._getItemIndex(t),i=this._getItemIndex(tt.findOne(".active.carousel-item",this._element));return q.trigger(this._element,"slide.coreui.carousel",{relatedTarget:t,direction:e,from:i,to:n})},n._setActiveIndicatorElement=function(t){if(this._indicatorsElement){for(var e=tt.find(".active",this._indicatorsElement),n=0;n<e.length;n++)e[n].classList.remove("active");var i=this._indicatorsElement.children[this._getItemIndex(t)];i&&i.classList.add("active")}},n._slide=function(t,e){var n,i,o,r=this,s=tt.findOne(".active.carousel-item",this._element),a=this._getItemIndex(s),l=e||s&&this._getItemByDirection(t,s),c=this._getItemIndex(l),u=Boolean(this._interval);if("next"===t?(n="carousel-item-left",i="carousel-item-next",o="left"):(n="carousel-item-right",i="carousel-item-prev",o="right"),l&&l.classList.contains("active"))this._isSliding=!1;else if(!this._triggerSlideEvent(l,o).defaultPrevented&&s&&l){if(this._isSliding=!0,u&&this.pause(),this._setActiveIndicatorElement(l),this._element.classList.contains("slide")){l.classList.add(i),y(l),s.classList.add(n),l.classList.add(n);var f=parseInt(l.getAttribute("data-interval"),10);f?(this._config.defaultInterval=this._config.defaultInterval||this._config.interval,this._config.interval=f):this._config.interval=this._config.defaultInterval||this._config.interval;var d=h(s);q.one(s,"transitionend",(function(){l.classList.remove(n,i),l.classList.add("active"),s.classList.remove("active",i,n),r._isSliding=!1,setTimeout((function(){q.trigger(r._element,ht,{relatedTarget:l,direction:o,from:a,to:c})}),0)})),m(s,d)}else s.classList.remove("active"),l.classList.add("active"),this._isSliding=!1,q.trigger(this._element,ht,{relatedTarget:l,direction:o,from:a,to:c});u&&this.cycle()}},t.carouselInterface=function(e,n){var i=k(e,ct),r=o(o({},ft),at.getDataAttributes(e));"object"==typeof n&&(r=o(o({},r),n));var s="string"==typeof n?n:r.slide;if(i||(i=new t(e,r)),"number"==typeof n)i.to(n);else if("string"==typeof s){if("undefined"==typeof i[s])throw new TypeError('No method named "'+s+'"');i[s]()}else r.interval&&r.ride&&(i.pause(),i.cycle())},t.jQueryInterface=function(e){return this.each((function(){t.carouselInterface(this,e)}))},t.dataApiClickHandler=function(e){var n=d(this);if(n&&n.classList.contains("carousel")){var i=o(o({},at.getDataAttributes(n)),at.getDataAttributes(this)),r=this.getAttribute("data-slide-to");r&&(i.interval=!1),t.carouselInterface(n,i),r&&k(n,ct).to(r),e.preventDefault()}},t.getInstance=function(t){return k(t,ct)},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return ft}}]),t}();q.on(document,"click.coreui.carousel.data-api","[data-slide], [data-slide-to]",gt.dataApiClickHandler),q.on(window,"load.coreui.carousel.data-api",(function(){for(var t=tt.find('[data-ride="carousel"]'),e=0,n=t.length;e<n;e++)gt.carouselInterface(t[e],k(t[e],ct))}));var mt=w();if(mt){var vt=mt.fn[lt];mt.fn[lt]=gt.jQueryInterface,mt.fn[lt].Constructor=gt,mt.fn[lt].noConflict=function(){return mt.fn[lt]=vt,gt.jQueryInterface}}var _t="class-toggler",bt="-sm,-md,-lg,-xl",yt="-show",wt=!1,Et="body",Lt=function(){function t(t){this._element=t}var n=t.prototype;return n.toggle=function(){var t=this;this._getElementDataAttributes(this._element).forEach((function(e){var n,i=e.target,o=e.toggle;n="_parent"===i||"parent"===i?t._element.parentNode:document.querySelector(i),o.forEach((function(e){var o=e.className,r=e.responsive,s=e.postfix,a="undefined"==typeof e.breakpoints||null===e.breakpoints?null:t._arrayFromString(e.breakpoints);if(r){var l;a.forEach((function(t){o.includes(t)&&(l=t)}));var c=[];"undefined"==typeof l?c.push(o):(c.push(o.replace(""+l+s,s)),a.splice(0,a.indexOf(l)+1).forEach((function(t){c.push(o.replace(""+l+s,""+t+s))})));var u=!1;if(c.forEach((function(t){n.classList.contains(t)&&(u=!0)})),u)c.forEach((function(t){n.classList.remove(t);var e=new CustomEvent("classtoggle",{detail:{target:i,add:!1,className:t}});n.dispatchEvent(e)}));else{n.classList.add(o);var f=new CustomEvent("classtoggle",{detail:{target:i,add:!0,className:o}});n.dispatchEvent(f)}}else{var d=n.classList.toggle(o),h=new CustomEvent("classtoggle",{detail:{target:i,add:d,className:o}});n.dispatchEvent(h)}}))}))},n._arrayFromString=function(t){return t.replace(/ /g,"").split(",")},n._isArray=function(t){try{return JSON.parse(t.replace(/'/g,'"')),!0}catch(t){return!1}},n._convertToArray=function(t){return JSON.parse(t.replace(/'/g,'"'))},n._getDataAttributes=function(t,e){var n=t[e];return this._isArray(n)?this._convertToArray(n):n},n._getToggleDetails=function(t,e,n,i){var o=function(t,e,n,i){void 0===e&&(e=wt),this.className=t,this.responsive=e,this.breakpoints=n,this.postfix=i},r=[];return Array.isArray(t)?t.forEach((function(t,s){e=Array.isArray(e)?e[s]:e,n=e?Array.isArray(n)?n[s]:n:null,i=e?Array.isArray(i)?i[s]:i:null,r.push(new o(t,e,n,i))})):(n=e?n:null,i=e?i:null,r.push(new o(t,e,n,i))),r},n._ifArray=function(t,e){return Array.isArray(t)?t[e]:t},n._getElementDataAttributes=function(t){var e=this,n=t.dataset,i="undefined"==typeof n.target?Et:this._getDataAttributes(n,"target"),o="undefined"==typeof n.class?"undefined":this._getDataAttributes(n,"class"),r="undefined"==typeof n.responsive?wt:this._getDataAttributes(n,"responsive"),s="undefined"==typeof n.breakpoints?bt:this._getDataAttributes(n,"breakpoints"),a="undefined"==typeof n.postfix?yt:this._getDataAttributes(n,"postfix"),l=[],c=function(t,e){this.target=t,this.toggle=e};return Array.isArray(i)?i.forEach((function(t,n){l.push(new c(t,e._getToggleDetails(e._ifArray(o,n),e._ifArray(r,n),e._ifArray(s,n),e._ifArray(a,n))))})):l.push(new c(i,this._getToggleDetails(o,r,s,a))),l},t._classTogglerInterface=function(e,n){var i=k(e,"coreui.class-toggler");if(i||(i=new t(e,"object"==typeof n&&n)),"string"==typeof n){if("undefined"==typeof i[n])throw new TypeError('No method named "'+n+'"');i[n]()}},t.jQueryInterface=function(e){return this.each((function(){t._classTogglerInterface(this,e)}))},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}}]),t}();q.on(document,"click.coreui.class-toggler.data-api",".c-class-toggler",(function(t){t.preventDefault();var e=t.target;e.classList.contains("c-class-toggler")||(e=e.closest(".c-class-toggler")),Lt._classTogglerInterface(e,"toggle")}));var kt=w();if(kt){var Tt=kt.fn[_t];kt.fn[_t]=Lt.jQueryInterface,kt.fn[_t].Constructor=Lt,kt.fn[_t].noConflict=function(){return kt.fn[_t]=Tt,Lt.jQueryInterface}}var At="collapse",Ot="coreui.collapse",St={toggle:!0,parent:""},Ct={toggle:"boolean",parent:"(string|element)"},Dt=function(){function t(t,e){this._isTransitioning=!1,this._element=t,this._config=this._getConfig(e),this._triggerArray=tt.find('[data-toggle="collapse"][href="#'+t.id+'"],[data-toggle="collapse"][data-target="#'+t.id+'"]');for(var n=tt.find('[data-toggle="collapse"]'),i=0,o=n.length;i<o;i++){var r=n[i],s=f(r),a=tt.find(s).filter((function(e){return e===t}));null!==s&&a.length&&(this._selector=s,this._triggerArray.push(r))}this._parent=this._config.parent?this._getParent():null,this._config.parent||this._addAriaAndCollapsedClass(this._element,this._triggerArray),this._config.toggle&&this.toggle(),L(t,Ot,this)}var n=t.prototype;return n.toggle=function(){this._element.classList.contains("show")?this.hide():this.show()},n.show=function(){var e=this;if(!this._isTransitioning&&!this._element.classList.contains("show")){var n,i;this._parent&&0===(n=tt.find(".show, .collapsing",this._parent).filter((function(t){return"string"==typeof e._config.parent?t.getAttribute("data-parent")===e._config.parent:t.classList.contains("collapse")}))).length&&(n=null);var o=tt.findOne(this._selector);if(n){var r=n.filter((function(t){return o!==t}));if((i=r[0]?k(r[0],Ot):null)&&i._isTransitioning)return}if(!q.trigger(this._element,"show.coreui.collapse").defaultPrevented){n&&n.forEach((function(e){o!==e&&t.collapseInterface(e,"hide"),i||L(e,Ot,null)}));var s=this._getDimension();this._element.classList.remove("collapse"),this._element.classList.add("collapsing"),this._element.style[s]=0,this._triggerArray.length&&this._triggerArray.forEach((function(t){t.classList.remove("collapsed"),t.setAttribute("aria-expanded",!0)})),this.setTransitioning(!0);var a="scroll"+(s[0].toUpperCase()+s.slice(1)),l=h(this._element);q.one(this._element,"transitionend",(function(){e._element.classList.remove("collapsing"),e._element.classList.add("collapse","show"),e._element.style[s]="",e.setTransitioning(!1),q.trigger(e._element,"shown.coreui.collapse")})),m(this._element,l),this._element.style[s]=this._element[a]+"px"}}},n.hide=function(){var t=this;if(!this._isTransitioning&&this._element.classList.contains("show")&&!q.trigger(this._element,"hide.coreui.collapse").defaultPrevented){var e=this._getDimension();this._element.style[e]=this._element.getBoundingClientRect()[e]+"px",y(this._element),this._element.classList.add("collapsing"),this._element.classList.remove("collapse","show");var n=this._triggerArray.length;if(n>0)for(var i=0;i<n;i++){var o=this._triggerArray[i],r=d(o);r&&!r.classList.contains("show")&&(o.classList.add("collapsed"),o.setAttribute("aria-expanded",!1))}this.setTransitioning(!0);this._element.style[e]="";var s=h(this._element);q.one(this._element,"transitionend",(function(){t.setTransitioning(!1),t._element.classList.remove("collapsing"),t._element.classList.add("collapse"),q.trigger(t._element,"hidden.coreui.collapse")})),m(this._element,s)}},n.setTransitioning=function(t){this._isTransitioning=t},n.dispose=function(){T(this._element,Ot),this._config=null,this._parent=null,this._element=null,this._triggerArray=null,this._isTransitioning=null},n._getConfig=function(t){return(t=o(o({},St),t)).toggle=Boolean(t.toggle),v(At,t,Ct),t},n._getDimension=function(){return this._element.classList.contains("width")?"width":"height"},n._getParent=function(){var t=this,e=this._config.parent;g(e)?"undefined"==typeof e.jquery&&"undefined"==typeof e[0]||(e=e[0]):e=tt.findOne(e);var n='[data-toggle="collapse"][data-parent="'+e+'"]';return tt.find(n,e).forEach((function(e){var n=d(e);t._addAriaAndCollapsedClass(n,[e])})),e},n._addAriaAndCollapsedClass=function(t,e){if(t){var n=t.classList.contains("show");e.length&&e.forEach((function(t){n?t.classList.remove("collapsed"):t.classList.add("collapsed"),t.setAttribute("aria-expanded",n)}))}},t.collapseInterface=function(e,n){var i=k(e,Ot),r=o(o(o({},St),at.getDataAttributes(e)),"object"==typeof n&&n?n:{});if(!i&&r.toggle&&"string"==typeof n&&/show|hide/.test(n)&&(r.toggle=!1),i||(i=new t(e,r)),"string"==typeof n){if("undefined"==typeof i[n])throw new TypeError('No method named "'+n+'"');i[n]()}},t.jQueryInterface=function(e){return this.each((function(){t.collapseInterface(this,e)}))},t.getInstance=function(t){return k(t,Ot)},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return St}}]),t}();q.on(document,"click.coreui.collapse.data-api",'[data-toggle="collapse"]',(function(t){"A"===t.target.tagName&&t.preventDefault();var e=at.getDataAttributes(this),n=f(this);tt.find(n).forEach((function(t){var n,i=k(t,Ot);i?(null===i._parent&&"string"==typeof e.parent&&(i._config.parent=e.parent,i._parent=i._getParent()),n="toggle"):n=e,Dt.collapseInterface(t,n)}))}));var xt=w();if(xt){var jt=xt.fn[At];xt.fn[At]=Dt.jQueryInterface,xt.fn[At].Constructor=Dt,xt.fn[At].noConflict=function(){return xt.fn[At]=jt,Dt.jQueryInterface}}function Nt(t){var e=t.getBoundingClientRect();return{width:e.width,height:e.height,top:e.top,right:e.right,bottom:e.bottom,left:e.left,x:e.left,y:e.top}}function It(t){if("[object Window]"!==t.toString()){var e=t.ownerDocument;return e?e.defaultView:window}return t}function Pt(t){var e=It(t);return{scrollLeft:e.pageXOffset,scrollTop:e.pageYOffset}}function Rt(t){return t instanceof It(t).Element||t instanceof Element}function Mt(t){return t instanceof It(t).HTMLElement||t instanceof HTMLElement}function Ht(t){return t?(t.nodeName||"").toLowerCase():null}function Wt(t){return(Rt(t)?t.ownerDocument:t.document).documentElement}function Yt(t){return Nt(Wt(t)).left+Pt(t).scrollLeft}function Xt(t){return It(t).getComputedStyle(t)}function Bt(t){var e=Xt(t),n=e.overflow,i=e.overflowX,o=e.overflowY;return/auto|scroll|overlay|hidden/.test(n+o+i)}function Ut(t,e,n){void 0===n&&(n=!1);var i,o=Wt(e),r=Nt(t),s={scrollLeft:0,scrollTop:0},a={x:0,y:0};return n||(("body"!==Ht(e)||Bt(o))&&(s=(i=e)!==It(i)&&Mt(i)?function(t){return{scrollLeft:t.scrollLeft,scrollTop:t.scrollTop}}(i):Pt(i)),Mt(e)?((a=Nt(e)).x+=e.clientLeft,a.y+=e.clientTop):o&&(a.x=Yt(o))),{x:r.left+s.scrollLeft-a.x,y:r.top+s.scrollTop-a.y,width:r.width,height:r.height}}function qt(t){return{x:t.offsetLeft,y:t.offsetTop,width:t.offsetWidth,height:t.offsetHeight}}function Ft(t){return"html"===Ht(t)?t:t.assignedSlot||t.parentNode||t.host||Wt(t)}function Qt(t,e){void 0===e&&(e=[]);var n=function t(e){return["html","body","#document"].indexOf(Ht(e))>=0?e.ownerDocument.body:Mt(e)&&Bt(e)?e:t(Ft(e))}(t),i="body"===Ht(n),o=It(n),r=i?[o].concat(o.visualViewport||[],Bt(n)?n:[]):n,s=e.concat(r);return i?s:s.concat(Qt(Ft(r)))}function zt(t){return["table","td","th"].indexOf(Ht(t))>=0}function Vt(t){return Mt(t)&&"fixed"!==Xt(t).position?t.offsetParent:null}function Kt(t){for(var e=It(t),n=Vt(t);n&&zt(n);)n=Vt(n);return n&&"body"===Ht(n)&&"static"===Xt(n).position?e:n||e}var $t="top",Jt="bottom",Gt="right",Zt="left",te=[$t,Jt,Gt,Zt],ee=te.reduce((function(t,e){return t.concat([e+"-start",e+"-end"])}),[]),ne=[].concat(te,["auto"]).reduce((function(t,e){return t.concat([e,e+"-start",e+"-end"])}),[]),ie=["beforeRead","read","afterRead","beforeMain","main","afterMain","beforeWrite","write","afterWrite"];function oe(t){var e=new Map,n=new Set,i=[];return t.forEach((function(t){e.set(t.name,t)})),t.forEach((function(t){n.has(t.name)||function t(o){n.add(o.name),[].concat(o.requires||[],o.requiresIfExists||[]).forEach((function(i){if(!n.has(i)){var o=e.get(i);o&&t(o)}})),i.push(o)}(t)})),i}function re(t){return t.split("-")[0]}var se={placement:"bottom",modifiers:[],strategy:"absolute"};function ae(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return!e.some((function(t){return!(t&&"function"==typeof t.getBoundingClientRect)}))}function le(t){void 0===t&&(t={});var e=t,n=e.defaultModifiers,i=void 0===n?[]:n,o=e.defaultOptions,r=void 0===o?se:o;return function(t,e,n){void 0===n&&(n=r);var o,s,a={placement:"bottom",orderedModifiers:[],options:Object.assign({},se,{},r),modifiersData:{},elements:{reference:t,popper:e},attributes:{},styles:{}},l=[],c=!1,u={state:a,setOptions:function(n){f(),a.options=Object.assign({},r,{},a.options,{},n),a.scrollParents={reference:Rt(t)?Qt(t):t.contextElement?Qt(t.contextElement):[],popper:Qt(e)};var o,s,c=function(t){var e=oe(t);return ie.reduce((function(t,n){return t.concat(e.filter((function(t){return t.phase===n})))}),[])}((o=[].concat(i,a.options.modifiers),s=o.reduce((function(t,e){var n=t[e.name];return t[e.name]=n?Object.assign({},n,{},e,{options:Object.assign({},n.options,{},e.options),data:Object.assign({},n.data,{},e.data)}):e,t}),{}),Object.keys(s).map((function(t){return s[t]}))));return a.orderedModifiers=c.filter((function(t){return t.enabled})),a.orderedModifiers.forEach((function(t){var e=t.name,n=t.options,i=void 0===n?{}:n,o=t.effect;if("function"==typeof o){var r=o({state:a,name:e,instance:u,options:i});l.push(r||function(){})}})),u.update()},forceUpdate:function(){if(!c){var t=a.elements,e=t.reference,n=t.popper;if(ae(e,n)){a.rects={reference:Ut(e,Kt(n),"fixed"===a.options.strategy),popper:qt(n)},a.reset=!1,a.placement=a.options.placement,a.orderedModifiers.forEach((function(t){return a.modifiersData[t.name]=Object.assign({},t.data)}));for(var i=0;i<a.orderedModifiers.length;i++)if(!0!==a.reset){var o=a.orderedModifiers[i],r=o.fn,s=o.options,l=void 0===s?{}:s,f=o.name;"function"==typeof r&&(a=r({state:a,options:l,name:f,instance:u})||a)}else a.reset=!1,i=-1}}},update:(o=function(){return new Promise((function(t){u.forceUpdate(),t(a)}))},function(){return s||(s=new Promise((function(t){Promise.resolve().then((function(){s=void 0,t(o())}))}))),s}),destroy:function(){f(),c=!0}};if(!ae(t,e))return u;function f(){l.forEach((function(t){return t()})),l=[]}return u.setOptions(n).then((function(t){!c&&n.onFirstUpdate&&n.onFirstUpdate(t)})),u}}var ce={passive:!0};function ue(t){return t.split("-")[1]}function fe(t){return["top","bottom"].indexOf(t)>=0?"x":"y"}function de(t){var e,n=t.reference,i=t.element,o=t.placement,r=o?re(o):null,s=o?ue(o):null,a=n.x+n.width/2-i.width/2,l=n.y+n.height/2-i.height/2;switch(r){case $t:e={x:a,y:n.y-i.height};break;case Jt:e={x:a,y:n.y+n.height};break;case Gt:e={x:n.x+n.width,y:l};break;case Zt:e={x:n.x-i.width,y:l};break;default:e={x:n.x,y:n.y}}var c=r?fe(r):null;if(null!=c){var u="y"===c?"height":"width";switch(s){case"start":e[c]=Math.floor(e[c])-Math.floor(n[u]/2-i[u]/2);break;case"end":e[c]=Math.floor(e[c])+Math.ceil(n[u]/2-i[u]/2)}}return e}var he={top:"auto",right:"auto",bottom:"auto",left:"auto"};function pe(t){var e,n=t.popper,i=t.popperRect,o=t.placement,r=t.offsets,s=t.position,a=t.gpuAcceleration,l=t.adaptive,c=function(t){var e=t.x,n=t.y,i=window.devicePixelRatio||1;return{x:Math.round(e*i)/i||0,y:Math.round(n*i)/i||0}}(r),u=c.x,f=c.y,d=r.hasOwnProperty("x"),h=r.hasOwnProperty("y"),p=Zt,g=$t,m=window;if(l){var v=Kt(n);v===It(n)&&(v=Wt(n)),o===$t&&(g=Jt,f-=v.clientHeight-i.height,f*=a?1:-1),o===Zt&&(p=Gt,u-=v.clientWidth-i.width,u*=a?1:-1)}var _,b=Object.assign({position:s},l&&he);return a?Object.assign({},b,((_={})[g]=h?"0":"",_[p]=d?"0":"",_.transform=(m.devicePixelRatio||1)<2?"translate("+u+"px, "+f+"px)":"translate3d("+u+"px, "+f+"px, 0)",_)):Object.assign({},b,((e={})[g]=h?f+"px":"",e[p]=d?u+"px":"",e.transform="",e))}var ge={left:"right",right:"left",bottom:"top",top:"bottom"};function me(t){return t.replace(/left|right|bottom|top/g,(function(t){return ge[t]}))}var ve={start:"end",end:"start"};function _e(t){return t.replace(/start|end/g,(function(t){return ve[t]}))}function be(t){return parseFloat(t)||0}function ye(t){var e=It(t),n=function(t){var e=Mt(t)?Xt(t):{};return{top:be(e.borderTopWidth),right:be(e.borderRightWidth),bottom:be(e.borderBottomWidth),left:be(e.borderLeftWidth)}}(t),i="html"===Ht(t),o=Yt(t),r=t.clientWidth+n.right,s=t.clientHeight+n.bottom;return i&&e.innerHeight-t.clientHeight>50&&(s=e.innerHeight-n.bottom),{top:i?0:t.clientTop,right:t.clientLeft>n.left?n.right:i?e.innerWidth-r-o:t.offsetWidth-r,bottom:i?e.innerHeight-s:t.offsetHeight-s,left:i?o:t.clientLeft}}function we(t,e){var n=Boolean(e.getRootNode&&e.getRootNode().host);if(t.contains(e))return!0;if(n){var i=e;do{if(i&&t.isSameNode(i))return!0;i=i.parentNode||i.host}while(i)}return!1}function Ee(t){return Object.assign({},t,{left:t.x,top:t.y,right:t.x+t.width,bottom:t.y+t.height})}function Le(t,e){return"viewport"===e?Ee(function(t){var e=It(t),n=e.visualViewport,i=e.innerWidth,o=e.innerHeight;return n&&/iPhone|iPod|iPad/.test(navigator.platform)&&(i=n.width,o=n.height),{width:i,height:o,x:0,y:0}}(t)):Mt(e)?Nt(e):Ee(function(t){var e=It(t),n=Pt(t),i=Ut(Wt(t),e);return i.height=Math.max(i.height,e.innerHeight),i.width=Math.max(i.width,e.innerWidth),i.x=-n.scrollLeft,i.y=-n.scrollTop,i}(Wt(t)))}function ke(t,e,n){var i="clippingParents"===e?function(t){var e=Qt(t),n=["absolute","fixed"].indexOf(Xt(t).position)>=0&&Mt(t)?Kt(t):t;return Rt(n)?e.filter((function(t){return Rt(t)&&we(t,n)})):[]}(t):[].concat(e),o=[].concat(i,[n]),r=o[0],s=o.reduce((function(e,n){var i=Le(t,n),o=ye(Mt(n)?n:Wt(t));return e.top=Math.max(i.top+o.top,e.top),e.right=Math.min(i.right-o.right,e.right),e.bottom=Math.min(i.bottom-o.bottom,e.bottom),e.left=Math.max(i.left+o.left,e.left),e}),Le(t,r));return s.width=s.right-s.left,s.height=s.bottom-s.top,s.x=s.left,s.y=s.top,s}function Te(t){return Object.assign({},{top:0,right:0,bottom:0,left:0},{},t)}function Ae(t,e){return e.reduce((function(e,n){return e[n]=t,e}),{})}function Oe(t,e){void 0===e&&(e={});var n=e,i=n.placement,o=void 0===i?t.placement:i,r=n.boundary,s=void 0===r?"clippingParents":r,a=n.rootBoundary,l=void 0===a?"viewport":a,c=n.elementContext,u=void 0===c?"popper":c,f=n.altBoundary,d=void 0!==f&&f,h=n.padding,p=void 0===h?0:h,g=Te("number"!=typeof p?p:Ae(p,te)),m="popper"===u?"reference":"popper",v=t.elements.reference,_=t.rects.popper,b=t.elements[d?m:u],y=ke(Rt(b)?b:b.contextElement||Wt(t.elements.popper),s,l),w=Nt(v),E=de({reference:w,element:_,strategy:"absolute",placement:o}),L=Ee(Object.assign({},_,{},E)),k="popper"===u?L:w,T={top:y.top-k.top+g.top,bottom:k.bottom-y.bottom+g.bottom,left:y.left-k.left+g.left,right:k.right-y.right+g.right},A=t.modifiersData.offset;if("popper"===u&&A){var O=A[o];Object.keys(T).forEach((function(t){var e=[Gt,Jt].indexOf(t)>=0?1:-1,n=[$t,Jt].indexOf(t)>=0?"y":"x";T[t]+=O[n]*e}))}return T}function Se(t,e){void 0===e&&(e={});var n=e,i=n.placement,o=n.boundary,r=n.rootBoundary,s=n.padding,a=n.flipVariations,l=n.allowedAutoPlacements,c=void 0===l?ne:l,u=ue(i),f=(u?a?ee:ee.filter((function(t){return ue(t)===u})):te).filter((function(t){return c.indexOf(t)>=0})).reduce((function(e,n){return e[n]=Oe(t,{placement:n,boundary:o,rootBoundary:r,padding:s})[re(n)],e}),{});return Object.keys(f).sort((function(t,e){return f[t]-f[e]}))}function Ce(t,e,n){return Math.max(t,Math.min(e,n))}function De(t,e,n){return void 0===n&&(n={x:0,y:0}),{top:t.top-e.height-n.y,right:t.right-e.width+n.x,bottom:t.bottom-e.height+n.y,left:t.left-e.width-n.x}}function xe(t){return[$t,Gt,Jt,Zt].some((function(e){return t[e]>=0}))}var je=le({defaultModifiers:[{name:"eventListeners",enabled:!0,phase:"write",fn:function(){},effect:function(t){var e=t.state,n=t.instance,i=t.options,o=i.scroll,r=void 0===o||o,s=i.resize,a=void 0===s||s,l=It(e.elements.popper),c=[].concat(e.scrollParents.reference,e.scrollParents.popper);return r&&c.forEach((function(t){t.addEventListener("scroll",n.update,ce)})),a&&l.addEventListener("resize",n.update,ce),function(){r&&c.forEach((function(t){t.removeEventListener("scroll",n.update,ce)})),a&&l.removeEventListener("resize",n.update,ce)}},data:{}},{name:"popperOffsets",enabled:!0,phase:"read",fn:function(t){var e=t.state,n=t.name;e.modifiersData[n]=de({reference:e.rects.reference,element:e.rects.popper,strategy:"absolute",placement:e.placement})},data:{}},{name:"computeStyles",enabled:!0,phase:"beforeWrite",fn:function(t){var e=t.state,n=t.options,i=n.gpuAcceleration,o=void 0===i||i,r=n.adaptive,s=void 0===r||r,a={placement:re(e.placement),popper:e.elements.popper,popperRect:e.rects.popper,gpuAcceleration:o};null!=e.modifiersData.popperOffsets&&(e.styles.popper=Object.assign({},e.styles.popper,{},pe(Object.assign({},a,{offsets:e.modifiersData.popperOffsets,position:e.options.strategy,adaptive:s})))),null!=e.modifiersData.arrow&&(e.styles.arrow=Object.assign({},e.styles.arrow,{},pe(Object.assign({},a,{offsets:e.modifiersData.arrow,position:"absolute",adaptive:!1})))),e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-placement":e.placement})},data:{}},{name:"applyStyles",enabled:!0,phase:"write",fn:function(t){var e=t.state;Object.keys(e.elements).forEach((function(t){var n=e.styles[t]||{},i=e.attributes[t]||{},o=e.elements[t];Mt(o)&&Ht(o)&&(Object.assign(o.style,n),Object.keys(i).forEach((function(t){var e=i[t];!1===e?o.removeAttribute(t):o.setAttribute(t,!0===e?"":e)})))}))},effect:function(t){var e=t.state,n={popper:{position:e.options.strategy,left:"0",top:"0",margin:"0"},arrow:{position:"absolute"},reference:{}};return Object.assign(e.elements.popper.style,n.popper),e.elements.arrow&&Object.assign(e.elements.arrow.style,n.arrow),function(){Object.keys(e.elements).forEach((function(t){var i=e.elements[t],o=e.attributes[t]||{},r=Object.keys(e.styles.hasOwnProperty(t)?e.styles[t]:n[t]).reduce((function(t,e){return t[e]="",t}),{});Mt(i)&&Ht(i)&&(Object.assign(i.style,r),Object.keys(o).forEach((function(t){i.removeAttribute(t)})))}))}},requires:["computeStyles"]},{name:"offset",enabled:!0,phase:"main",requires:["popperOffsets"],fn:function(t){var e=t.state,n=t.options,i=t.name,o=n.offset,r=void 0===o?[0,0]:o,s=ne.reduce((function(t,n){return t[n]=function(t,e,n){var i=re(t),o=[Zt,$t].indexOf(i)>=0?-1:1,r="function"==typeof n?n(Object.assign({},e,{placement:t})):n,s=r[0],a=r[1];return s=s||0,a=(a||0)*o,[Zt,Gt].indexOf(i)>=0?{x:a,y:s}:{x:s,y:a}}(n,e.rects,r),t}),{}),a=s[e.placement],l=a.x,c=a.y;null!=e.modifiersData.popperOffsets&&(e.modifiersData.popperOffsets.x+=l,e.modifiersData.popperOffsets.y+=c),e.modifiersData[i]=s}},{name:"flip",enabled:!0,phase:"main",fn:function(t){var e=t.state,n=t.options,i=t.name;if(!e.modifiersData[i]._skip){for(var o=n.mainAxis,r=void 0===o||o,s=n.altAxis,a=void 0===s||s,l=n.fallbackPlacements,c=n.padding,u=n.boundary,f=n.rootBoundary,d=n.altBoundary,h=n.flipVariations,p=void 0===h||h,g=n.allowedAutoPlacements,m=e.options.placement,v=re(m),_=l||(v===m||!p?[me(m)]:function(t){if("auto"===re(t))return[];var e=me(t);return[_e(t),e,_e(e)]}(m)),b=[m].concat(_).reduce((function(t,n){return t.concat("auto"===re(n)?Se(e,{placement:n,boundary:u,rootBoundary:f,padding:c,flipVariations:p,allowedAutoPlacements:g}):n)}),[]),y=e.rects.reference,w=e.rects.popper,E=new Map,L=!0,k=b[0],T=0;T<b.length;T++){var A=b[T],O=re(A),S="start"===ue(A),C=[$t,Jt].indexOf(O)>=0,D=C?"width":"height",x=Oe(e,{placement:A,boundary:u,rootBoundary:f,altBoundary:d,padding:c}),j=C?S?Gt:Zt:S?Jt:$t;y[D]>w[D]&&(j=me(j));var N=me(j),I=[];if(r&&I.push(x[O]<=0),a&&I.push(x[j]<=0,x[N]<=0),I.every((function(t){return t}))){k=A,L=!1;break}E.set(A,I)}if(L)for(var P=function(t){var e=b.find((function(e){var n=E.get(e);if(n)return n.slice(0,t).every((function(t){return t}))}));if(e)return k=e,"break"},R=p?3:1;R>0;R--){if("break"===P(R))break}e.placement!==k&&(e.modifiersData[i]._skip=!0,e.placement=k,e.reset=!0)}},requiresIfExists:["offset"],data:{_skip:!1}},{name:"preventOverflow",enabled:!0,phase:"main",fn:function(t){var e=t.state,n=t.options,i=t.name,o=n.mainAxis,r=void 0===o||o,s=n.altAxis,a=void 0!==s&&s,l=n.boundary,c=n.rootBoundary,u=n.altBoundary,f=n.padding,d=n.tether,h=void 0===d||d,p=n.tetherOffset,g=void 0===p?0:p,m=Oe(e,{boundary:l,rootBoundary:c,padding:f,altBoundary:u}),v=re(e.placement),_=ue(e.placement),b=!_,y=fe(v),w="x"===y?"y":"x",E=e.modifiersData.popperOffsets,L=e.rects.reference,k=e.rects.popper,T="function"==typeof g?g(Object.assign({},e.rects,{placement:e.placement})):g,A={x:0,y:0};if(E){if(r){var O="y"===y?$t:Zt,S="y"===y?Jt:Gt,C="y"===y?"height":"width",D=E[y],x=E[y]+m[O],j=E[y]-m[S],N=h?-k[C]/2:0,I="start"===_?L[C]:k[C],P="start"===_?-k[C]:-L[C],R=e.elements.arrow,M=h&&R?qt(R):{width:0,height:0},H=e.modifiersData["arrow#persistent"]?e.modifiersData["arrow#persistent"].padding:{top:0,right:0,bottom:0,left:0},W=H[O],Y=H[S],X=Ce(0,L[C],M[C]),B=b?L[C]/2-N-X-W-T:I-X-W-T,U=b?-L[C]/2+N+X+Y+T:P+X+Y+T,q=e.elements.arrow&&Kt(e.elements.arrow),F=q?"y"===y?q.clientTop||0:q.clientLeft||0:0,Q=e.modifiersData.offset?e.modifiersData.offset[e.placement][y]:0,z=E[y]+B-Q-F,V=E[y]+U-Q,K=Ce(h?Math.min(x,z):x,D,h?Math.max(j,V):j);E[y]=K,A[y]=K-D}if(a){var $="x"===y?$t:Zt,J="x"===y?Jt:Gt,G=E[w],Z=Ce(G+m[$],G,G-m[J]);E[w]=Z,A[w]=Z-G}e.modifiersData[i]=A}},requiresIfExists:["offset"]},{name:"arrow",enabled:!0,phase:"main",fn:function(t){var e,n=t.state,i=t.name,o=n.elements.arrow,r=n.modifiersData.popperOffsets,s=re(n.placement),a=fe(s),l=[Zt,Gt].indexOf(s)>=0?"height":"width";if(o&&r){var c=n.modifiersData[i+"#persistent"].padding,u=qt(o),f="y"===a?$t:Zt,d="y"===a?Jt:Gt,h=n.rects.reference[l]+n.rects.reference[a]-r[a]-n.rects.popper[l],p=r[a]-n.rects.reference[a],g=Kt(o),m=g?"y"===a?g.clientHeight||0:g.clientWidth||0:0,v=h/2-p/2,_=c[f],b=m-u[l]-c[d],y=m/2-u[l]/2+v,w=Ce(_,y,b),E=a;n.modifiersData[i]=((e={})[E]=w,e.centerOffset=w-y,e)}},effect:function(t){var e=t.state,n=t.options,i=t.name,o=n.element,r=void 0===o?"[data-popper-arrow]":o,s=n.padding,a=void 0===s?0:s;null!=r&&("string"!=typeof r||(r=e.elements.popper.querySelector(r)))&&we(e.elements.popper,r)&&(e.elements.arrow=r,e.modifiersData[i+"#persistent"]={padding:Te("number"!=typeof a?a:Ae(a,te))})},requires:["popperOffsets"],requiresIfExists:["preventOverflow"]},{name:"hide",enabled:!0,phase:"main",requiresIfExists:["preventOverflow"],fn:function(t){var e=t.state,n=t.name,i=e.rects.reference,o=e.rects.popper,r=e.modifiersData.preventOverflow,s=Oe(e,{elementContext:"reference"}),a=Oe(e,{altBoundary:!0}),l=De(s,i),c=De(a,o,r),u=xe(l),f=xe(c);e.modifiersData[n]={referenceClippingOffsets:l,popperEscapeOffsets:c,isReferenceHidden:u,hasPopperEscaped:f},e.attributes.popper=Object.assign({},e.attributes.popper,{"data-popper-reference-hidden":u,"data-popper-escaped":f})}}]}),Ne="dropdown",Ie="coreui.dropdown",Pe="."+Ie,Re=new RegExp("ArrowUp|ArrowDown|Escape"),Me={offset:[0,0],flip:!0,boundary:"scrollParent",reference:"toggle",display:"dynamic",popperConfig:null},He={offset:"(array|function)",flip:"boolean",boundary:"(string|element)",reference:"(string|element)",display:"string",popperConfig:"(null|object)"},We=function(){function t(t,e){this._element=t,this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._inHeader=this._detectHeader(),this._addEventListeners(),L(t,Ie,this)}var n=t.prototype;return n.toggle=function(){if(!this._element.disabled&&!this._element.classList.contains("disabled")){var e=this._menu.classList.contains("show");t.clearMenus(),e||this.show()}},n.show=function(){if(!(this._element.disabled||this._element.classList.contains("disabled")||this._menu.classList.contains("show"))){var e=t.getParentFromElement(this._element),n={relatedTarget:this._element};if(!q.trigger(e,"show.coreui.dropdown",n).defaultPrevented){if(!this._inNavbar&&!this._inHeader){if("undefined"==typeof je)throw new TypeError("CoreUI's dropdowns require Popper.js (https://popper.js.org)");var i=this._element;"parent"===this._config.reference?i=e:g(this._config.reference)&&(i=this._config.reference,"undefined"!=typeof this._config.reference.jquery&&(i=this._config.reference[0])),"scrollParent"!==this._config.boundary&&e.classList.add("position-static"),this._popper=je(i,this._menu,this._getPopperConfig())}var o,r;if("ontouchstart"in document.documentElement&&!e.closest(".navbar-nav"))(o=[]).concat.apply(o,document.body.children).forEach((function(t){return q.on(t,"mouseover",null,(function(){}))}));if("ontouchstart"in document.documentElement&&!e.closest(".c-header-nav"))(r=[]).concat.apply(r,document.body.children).forEach((function(t){return q.on(t,"mouseover",null,(function(){}))}));this._element.focus(),this._element.setAttribute("aria-expanded",!0),at.toggleClass(this._menu,"show"),at.toggleClass(e,"show"),q.trigger(e,"shown.coreui.dropdown",n)}}},n.hide=function(){if(!this._element.disabled&&!this._element.classList.contains("disabled")&&this._menu.classList.contains("show")){var e=t.getParentFromElement(this._element),n={relatedTarget:this._element};q.trigger(e,"hide.coreui.dropdown",n).defaultPrevented||(this._popper&&this._popper.destroy(),at.toggleClass(this._menu,"show"),at.toggleClass(e,"show"),q.trigger(e,"hidden.coreui.dropdown",n))}},n.dispose=function(){T(this._element,Ie),q.off(this._element,Pe),this._element=null,this._menu=null,this._popper&&(this._popper.destroy(),this._popper=null)},n.update=function(){this._inNavbar=this._detectNavbar(),this._inHeader=this._detectHeader(),this._popper&&this._popper.scheduleUpdate()},n._addEventListeners=function(){var t=this;q.on(this._element,"click.coreui.dropdown",(function(e){e.preventDefault(),e.stopPropagation(),t.toggle()}))},n._getConfig=function(t){return t=o(o(o({},this.constructor.Default),at.getDataAttributes(this._element)),t),v(Ne,t,this.constructor.DefaultType),t},n._getMenuElement=function(){var e=t.getParentFromElement(this._element);return tt.findOne(".dropdown-menu",e)},n._getPlacement=function(){var t=this._element.parentNode,e="bottom-start";return t.classList.contains("dropup")?(e="top-start",this._menu.classList.contains("dropdown-menu-right")&&(e="top-end")):t.classList.contains("dropright")?e="right-start":t.classList.contains("dropleft")?e="left-start":this._menu.classList.contains("dropdown-menu-right")&&(e="bottom-end"),e},n._detectNavbar=function(){return Boolean(this._element.closest(".navbar"))},n._detectHeader=function(){return Boolean(this._element.closest(".c-header"))},n._getOffset=function(){var t=this,e={};return"function"==typeof this._config.offset?e.fn=function(e){return e.offsets=o(o({},e.offsets),t._config.offset(e.offsets,t._element)||{}),e}:e.offset=this._config.offset,e},n._getPopperConfig=function(){var t={placement:this._getPlacement(),modifiers:[{name:"offset",options:{offset:this._getOffset()}},{name:"flip",enabled:this._config.flip},{name:"preventOverflow",options:{boundary:this._config.boundary}}]};return"static"===this._config.display&&(t.modifiers.applyStyle={enabled:!1}),o(o({},t),this._config.popperConfig)},t.dropdownInterface=function(e,n){var i=k(e,Ie);if(i||(i=new t(e,"object"==typeof n?n:null)),"string"==typeof n){if("undefined"==typeof i[n])throw new TypeError('No method named "'+n+'"');i[n]()}},t.jQueryInterface=function(e){return this.each((function(){t.dropdownInterface(this,e)}))},t.clearMenus=function(e){if(!e||2!==e.button&&("keyup"!==e.type||"Tab"===e.key))for(var n=tt.find('[data-toggle="dropdown"]'),i=0,o=n.length;i<o;i++){var r=t.getParentFromElement(n[i]),s=k(n[i],Ie),a={relatedTarget:n[i]};if(e&&"click"===e.type&&(a.clickEvent=e),s){var l=s._menu;if(r.classList.contains("show"))if(!(e&&("click"===e.type&&/input|textarea/i.test(e.target.tagName)||"keyup"===e.type&&"Tab"===e.key)&&r.contains(e.target)))if(!q.trigger(r,"hide.coreui.dropdown",a).defaultPrevented){var c;if("ontouchstart"in document.documentElement)(c=[]).concat.apply(c,document.body.children).forEach((function(t){return q.off(t,"mouseover",null,(function(){}))}));n[i].setAttribute("aria-expanded","false"),s._popper&&s._popper.destroy(),l.classList.remove("show"),r.classList.remove("show"),q.trigger(r,"hidden.coreui.dropdown",a)}}}},t.getParentFromElement=function(t){return d(t)||t.parentNode},t.dataApiKeydownHandler=function(e){if(!(/input|textarea/i.test(e.target.tagName)?"Space"===e.key||"Escape"!==e.key&&("ArrowDown"!==e.key&&"ArrowUp"!==e.key||e.target.closest(".dropdown-menu")):!Re.test(e.key))&&(e.preventDefault(),e.stopPropagation(),!this.disabled&&!this.classList.contains("disabled"))){var n=t.getParentFromElement(this),i=n.classList.contains("show");if("Escape"===e.key)return(this.matches('[data-toggle="dropdown"]')?this:tt.prev(this,'[data-toggle="dropdown"]')[0]).focus(),void t.clearMenus();if(i&&"Space"!==e.key){var o=tt.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",n).filter(_);if(o.length){var r=o.indexOf(e.target);"ArrowUp"===e.key&&r>0&&r--,"ArrowDown"===e.key&&r<o.length-1&&r++,o[r=-1===r?0:r].focus()}}else t.clearMenus()}},t.getInstance=function(t){return k(t,Ie)},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return Me}},{key:"DefaultType",get:function(){return He}}]),t}();q.on(document,"keydown.coreui.dropdown.data-api",'[data-toggle="dropdown"]',We.dataApiKeydownHandler),q.on(document,"keydown.coreui.dropdown.data-api",".dropdown-menu",We.dataApiKeydownHandler),q.on(document,"click.coreui.dropdown.data-api",We.clearMenus),q.on(document,"keyup.coreui.dropdown.data-api",We.clearMenus),q.on(document,"click.coreui.dropdown.data-api",'[data-toggle="dropdown"]',(function(t){t.preventDefault(),t.stopPropagation(),We.dropdownInterface(this,"toggle")})),q.on(document,"click.coreui.dropdown.data-api",".dropdown form",(function(t){return t.stopPropagation()}));var Ye=w();if(Ye){var Xe=Ye.fn[Ne];Ye.fn[Ne]=We.jQueryInterface,Ye.fn[Ne].Constructor=We,Ye.fn[Ne].noConflict=function(){return Ye.fn[Ne]=Xe,We.jQueryInterface}}var Be=".coreui.modal",Ue={backdrop:!0,keyboard:!0,focus:!0,show:!0},qe={backdrop:"(boolean|string)",keyboard:"boolean",focus:"boolean",show:"boolean"},Fe=function(){function t(t,e){this._config=this._getConfig(e),this._element=t,this._dialog=tt.findOne(".modal-dialog",t),this._backdrop=null,this._isShown=!1,this._isBodyOverflowing=!1,this._ignoreBackdropClick=!1,this._isTransitioning=!1,this._scrollbarWidth=0,L(t,"coreui.modal",this)}var n=t.prototype;return n.toggle=function(t){return this._isShown?this.hide():this.show(t)},n.show=function(t){var e=this;if(!this._isShown&&!this._isTransitioning){this._element.classList.contains("fade")&&(this._isTransitioning=!0);var n=q.trigger(this._element,"show.coreui.modal",{relatedTarget:t});this._isShown||n.defaultPrevented||(this._isShown=!0,this._checkScrollbar(),this._setScrollbar(),this._adjustDialog(),this._setEscapeEvent(),this._setResizeEvent(),q.on(this._element,"click.dismiss.coreui.modal",'[data-dismiss="modal"]',(function(t){return e.hide(t)})),q.on(this._dialog,"mousedown.dismiss.coreui.modal",(function(){q.one(e._element,"mouseup.dismiss.coreui.modal",(function(t){t.target===e._element&&(e._ignoreBackdropClick=!0)}))})),this._showBackdrop((function(){return e._showElement(t)})))}},n.hide=function(t){var e=this;if((t&&t.preventDefault(),this._isShown&&!this._isTransitioning)&&!q.trigger(this._element,"hide.coreui.modal").defaultPrevented){this._isShown=!1;var n=this._element.classList.contains("fade");if(n&&(this._isTransitioning=!0),this._setEscapeEvent(),this._setResizeEvent(),q.off(document,"focusin.coreui.modal"),this._element.classList.remove("show"),q.off(this._element,"click.dismiss.coreui.modal"),q.off(this._dialog,"mousedown.dismiss.coreui.modal"),n){var i=h(this._element);q.one(this._element,"transitionend",(function(t){return e._hideModal(t)})),m(this._element,i)}else this._hideModal()}},n.dispose=function(){[window,this._element,this._dialog].forEach((function(t){return q.off(t,Be)})),q.off(document,"focusin.coreui.modal"),T(this._element,"coreui.modal"),this._config=null,this._element=null,this._dialog=null,this._backdrop=null,this._isShown=null,this._isBodyOverflowing=null,this._ignoreBackdropClick=null,this._isTransitioning=null,this._scrollbarWidth=null},n.handleUpdate=function(){this._adjustDialog()},n._getConfig=function(t){return t=o(o({},Ue),t),v("modal",t,qe),t},n._showElement=function(t){var e=this,n=this._element.classList.contains("fade"),i=tt.findOne(".modal-body",this._dialog);this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE||document.body.appendChild(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.setAttribute("aria-modal",!0),this._element.scrollTop=0,i&&(i.scrollTop=0),n&&y(this._element),this._element.classList.add("show"),this._config.focus&&this._enforceFocus();var o=function(){e._config.focus&&e._element.focus(),e._isTransitioning=!1,q.trigger(e._element,"shown.coreui.modal",{relatedTarget:t})};if(n){var r=h(this._dialog);q.one(this._dialog,"transitionend",o),m(this._dialog,r)}else o()},n._enforceFocus=function(){var t=this;q.off(document,"focusin.coreui.modal"),q.on(document,"focusin.coreui.modal",(function(e){document===e.target||t._element===e.target||t._element.contains(e.target)||t._element.focus()}))},n._setEscapeEvent=function(){var t=this;this._isShown?q.on(this._element,"keydown.dismiss.coreui.modal",(function(e){t._config.keyboard&&"Escape"===e.key?(e.preventDefault(),t.hide()):t._config.keyboard||"Escape"!==e.key||t._triggerBackdropTransition()})):q.off(this._element,"keydown.dismiss.coreui.modal")},n._setResizeEvent=function(){var t=this;this._isShown?q.on(window,"resize.coreui.modal",(function(){return t._adjustDialog()})):q.off(window,"resize.coreui.modal")},n._hideModal=function(){var t=this;this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._element.removeAttribute("aria-modal"),this._isTransitioning=!1,this._showBackdrop((function(){document.body.classList.remove("modal-open"),t._resetAdjustments(),t._resetScrollbar(),q.trigger(t._element,"hidden.coreui.modal")}))},n._removeBackdrop=function(){this._backdrop.parentNode.removeChild(this._backdrop),this._backdrop=null},n._showBackdrop=function(t){var e=this,n=this._element.classList.contains("fade")?"fade":"";if(this._isShown&&this._config.backdrop){if(this._backdrop=document.createElement("div"),this._backdrop.className="modal-backdrop",n&&this._backdrop.classList.add(n),document.body.appendChild(this._backdrop),q.on(this._element,"click.dismiss.coreui.modal",(function(t){e._ignoreBackdropClick?e._ignoreBackdropClick=!1:t.target===t.currentTarget&&e._triggerBackdropTransition()})),n&&y(this._backdrop),this._backdrop.classList.add("show"),!n)return void t();var i=h(this._backdrop);q.one(this._backdrop,"transitionend",t),m(this._backdrop,i)}else if(!this._isShown&&this._backdrop){this._backdrop.classList.remove("show");var o=function(){e._removeBackdrop(),t()};if(this._element.classList.contains("fade")){var r=h(this._backdrop);q.one(this._backdrop,"transitionend",o),m(this._backdrop,r)}else o()}else t()},n._triggerBackdropTransition=function(){var t=this;if("static"===this._config.backdrop){if(q.trigger(this._element,"hidePrevented.coreui.modal").defaultPrevented)return;this._element.classList.add("modal-static");var e=h(this._element);q.one(this._element,"transitionend",(function(){t._element.classList.remove("modal-static")})),m(this._element,e),this._element.focus()}else this.hide()},n._adjustDialog=function(){var t=this._element.scrollHeight>document.documentElement.clientHeight;!this._isBodyOverflowing&&t&&(this._element.style.paddingLeft=this._scrollbarWidth+"px"),this._isBodyOverflowing&&!t&&(this._element.style.paddingRight=this._scrollbarWidth+"px")},n._resetAdjustments=function(){this._element.style.paddingLeft="",this._element.style.paddingRight=""},n._checkScrollbar=function(){var t=document.body.getBoundingClientRect();this._isBodyOverflowing=Math.round(t.left+t.right)<window.innerWidth,this._scrollbarWidth=this._getScrollbarWidth()},n._setScrollbar=function(){var t=this;if(this._isBodyOverflowing){tt.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function(e){var n=e.style.paddingRight,i=window.getComputedStyle(e)["padding-right"];at.setDataAttribute(e,"padding-right",n),e.style.paddingRight=parseFloat(i)+t._scrollbarWidth+"px"})),tt.find(".sticky-top").forEach((function(e){var n=e.style.marginRight,i=window.getComputedStyle(e)["margin-right"];at.setDataAttribute(e,"margin-right",n),e.style.marginRight=parseFloat(i)-t._scrollbarWidth+"px"}));var e=document.body.style.paddingRight,n=window.getComputedStyle(document.body)["padding-right"];at.setDataAttribute(document.body,"padding-right",e),document.body.style.paddingRight=parseFloat(n)+this._scrollbarWidth+"px"}document.body.classList.add("modal-open")},n._resetScrollbar=function(){tt.find(".fixed-top, .fixed-bottom, .is-fixed, .sticky-top").forEach((function(t){var e=at.getDataAttribute(t,"padding-right");"undefined"!=typeof e&&(at.removeDataAttribute(t,"padding-right"),t.style.paddingRight=e)})),tt.find(".sticky-top").forEach((function(t){var e=at.getDataAttribute(t,"margin-right");"undefined"!=typeof e&&(at.removeDataAttribute(t,"margin-right"),t.style.marginRight=e)}));var t=at.getDataAttribute(document.body,"padding-right");"undefined"==typeof t?document.body.style.paddingRight="":(at.removeDataAttribute(document.body,"padding-right"),document.body.style.paddingRight=t)},n._getScrollbarWidth=function(){var t=document.createElement("div");t.className="modal-scrollbar-measure",document.body.appendChild(t);var e=t.getBoundingClientRect().width-t.clientWidth;return document.body.removeChild(t),e},t.jQueryInterface=function(e,n){return this.each((function(){var i=k(this,"coreui.modal"),r=o(o(o({},Ue),at.getDataAttributes(this)),"object"==typeof e&&e?e:{});if(i||(i=new t(this,r)),"string"==typeof e){if("undefined"==typeof i[e])throw new TypeError('No method named "'+e+'"');i[e](n)}else r.show&&i.show(n)}))},t.getInstance=function(t){return k(t,"coreui.modal")},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return Ue}}]),t}();q.on(document,"click.coreui.modal.data-api",'[data-toggle="modal"]',(function(t){var e=this,n=d(this);"A"!==this.tagName&&"AREA"!==this.tagName||t.preventDefault(),q.one(n,"show.coreui.modal",(function(t){t.defaultPrevented||q.one(n,"hidden.coreui.modal",(function(){_(e)&&e.focus()}))}));var i=k(n,"coreui.modal");if(!i){var r=o(o({},at.getDataAttributes(n)),at.getDataAttributes(this));i=new Fe(n,r)}i.show(this)}));var Qe=w();if(Qe){var ze=Qe.fn.modal;Qe.fn.modal=Fe.jQueryInterface,Qe.fn.modal.Constructor=Fe,Qe.fn.modal.noConflict=function(){return Qe.fn.modal=ze,Fe.jQueryInterface}}var Ve=["background","cite","href","itemtype","longdesc","poster","src","xlink:href"],Ke=/^(?:(?:https?|mailto|ftp|tel|file):|[^#&/:?]*(?:[#/?]|$))/gi,$e=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,Je={"*":["class","dir","id","lang","role",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","srcset","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]};function Ge(t,e,n){var i;if(!t.length)return t;if(n&&"function"==typeof n)return n(t);for(var o=(new window.DOMParser).parseFromString(t,"text/html"),r=Object.keys(e),s=(i=[]).concat.apply(i,o.body.querySelectorAll("*")),a=function(t,n){var i,o=s[t],a=o.nodeName.toLowerCase();if(-1===r.indexOf(a))return o.parentNode.removeChild(o),"continue";var l=(i=[]).concat.apply(i,o.attributes),c=[].concat(e["*"]||[],e[a]||[]);l.forEach((function(t){(function(t,e){var n=t.nodeName.toLowerCase();if(-1!==e.indexOf(n))return-1===Ve.indexOf(n)||Boolean(t.nodeValue.match(Ke)||t.nodeValue.match($e));for(var i=e.filter((function(t){return t instanceof RegExp})),o=0,r=i.length;o<r;o++)if(n.match(i[o]))return!0;return!1})(t,c)||o.removeAttribute(t.nodeName)}))},l=0,c=s.length;l<c;l++)a(l);return o.body.innerHTML}var Ze="tooltip",tn=".coreui.tooltip",en=new RegExp("(^|\\s)bs-tooltip\\S+","g"),nn=["sanitize","whiteList","sanitizeFn"],on={animation:"boolean",template:"string",title:"(string|element|function)",trigger:"string",delay:"(number|object)",html:"boolean",selector:"(string|boolean)",placement:"(string|function)",offset:"(number|string|function)",container:"(string|element|boolean)",boundary:"(string|element)",sanitize:"boolean",sanitizeFn:"(null|function)",whiteList:"object",popperConfig:"(null|object)"},rn={AUTO:"auto",TOP:"top",RIGHT:"right",BOTTOM:"bottom",LEFT:"left"},sn={animation:!0,template:'<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,selector:!1,placement:"top",offset:0,container:!1,boundary:"scrollParent",sanitize:!0,sanitizeFn:null,whiteList:Je,popperConfig:null},an={HIDE:"hide"+tn,HIDDEN:"hidden"+tn,SHOW:"show"+tn,SHOWN:"shown"+tn,INSERTED:"inserted"+tn,CLICK:"click"+tn,FOCUSIN:"focusin"+tn,FOCUSOUT:"focusout"+tn,MOUSEENTER:"mouseenter"+tn,MOUSELEAVE:"mouseleave"+tn},ln=function(){function t(t,e){if("undefined"==typeof je)throw new TypeError("CoreUI's tooltips require Popper.js (https://popper.js.org)");this._isEnabled=!0,this._timeout=0,this._hoverState="",this._activeTrigger={},this._popper=null,this.element=t,this.config=this._getConfig(e),this.tip=null,this._setListeners(),L(t,this.constructor.DATA_KEY,this)}var n=t.prototype;return n.enable=function(){this._isEnabled=!0},n.disable=function(){this._isEnabled=!1},n.toggleEnabled=function(){this._isEnabled=!this._isEnabled},n.toggle=function(t){if(this._isEnabled)if(t){var e=this.constructor.DATA_KEY,n=k(t.target,e);n||(n=new this.constructor(t.target,this._getDelegateConfig()),L(t.target,e,n)),n._activeTrigger.click=!n._activeTrigger.click,n._isWithActiveTrigger()?n._enter(null,n):n._leave(null,n)}else{if(this.getTipElement().classList.contains("show"))return void this._leave(null,this);this._enter(null,this)}},n.dispose=function(){clearTimeout(this._timeout),T(this.element,this.constructor.DATA_KEY),q.off(this.element,this.constructor.EVENT_KEY),q.off(this.element.closest(".modal"),"hide.coreui.modal",this._hideModalHandler),this.tip&&this.tip.parentNode.removeChild(this.tip),this._isEnabled=null,this._timeout=null,this._hoverState=null,this._activeTrigger=null,this._popper&&this._popper.destroy(),this._popper=null,this.element=null,this.config=null,this.tip=null},n.show=function(){var t=this;if("none"===this.element.style.display)throw new Error("Please use show on visible elements");if(this.isWithContent()&&this._isEnabled){var e=q.trigger(this.element,this.constructor.Event.SHOW),n=function t(e){if(!document.documentElement.attachShadow)return null;if("function"==typeof e.getRootNode){var n=e.getRootNode();return n instanceof ShadowRoot?n:null}return e instanceof ShadowRoot?e:e.parentNode?t(e.parentNode):null}(this.element),i=null===n?this.element.ownerDocument.documentElement.contains(this.element):n.contains(this.element);if(e.defaultPrevented||!i)return;var o=this.getTipElement(),r=c(this.constructor.NAME);o.setAttribute("id",r),this.element.setAttribute("aria-describedby",r),this.setContent(),this.config.animation&&o.classList.add("fade");var s,a="function"==typeof this.config.placement?this.config.placement.call(this,o,this.element):this.config.placement,l=this._getAttachment(a),u=this._getContainer();if(L(o,this.constructor.DATA_KEY,this),this.element.ownerDocument.documentElement.contains(this.tip)||u.appendChild(o),q.trigger(this.element,this.constructor.Event.INSERTED),this._popper=je(this.element,o,this._getPopperConfig(l)),o.classList.add("show"),"ontouchstart"in document.documentElement)(s=[]).concat.apply(s,document.body.children).forEach((function(t){q.on(t,"mouseover",(function(){}))}));var f=function(){t.config.animation&&t._fixTransition();var e=t._hoverState;t._hoverState=null,q.trigger(t.element,t.constructor.Event.SHOWN),"out"===e&&t._leave(null,t)};if(this.tip.classList.contains("fade")){var d=h(this.tip);q.one(this.tip,"transitionend",f),m(this.tip,d)}else f()}},n.hide=function(){var t=this,e=this.getTipElement(),n=function(){"show"!==t._hoverState&&e.parentNode&&e.parentNode.removeChild(e),t._cleanTipClass(),t.element.removeAttribute("aria-describedby"),q.trigger(t.element,t.constructor.Event.HIDDEN),t._popper.destroy()};if(!q.trigger(this.element,this.constructor.Event.HIDE).defaultPrevented){var i;if(e.classList.remove("show"),"ontouchstart"in document.documentElement)(i=[]).concat.apply(i,document.body.children).forEach((function(t){return q.off(t,"mouseover",b)}));if(this._activeTrigger.click=!1,this._activeTrigger.focus=!1,this._activeTrigger.hover=!1,this.tip.classList.contains("fade")){var o=h(e);q.one(e,"transitionend",n),m(e,o)}else n();this._hoverState=""}},n.update=function(){null!==this._popper&&this._popper.scheduleUpdate()},n.isWithContent=function(){return Boolean(this.getTitle())},n.getTipElement=function(){if(this.tip)return this.tip;var t=document.createElement("div");return t.innerHTML=this.config.template,this.tip=t.children[0],this.tip},n.setContent=function(){var t=this.getTipElement();this.setElementContent(tt.findOne(".tooltip-inner",t),this.getTitle()),t.classList.remove("fade","show")},n.setElementContent=function(t,e){if(null!==t)return"object"==typeof e&&g(e)?(e.jquery&&(e=e[0]),void(this.config.html?e.parentNode!==t&&(t.innerHTML="",t.appendChild(e)):t.textContent=e.textContent)):void(this.config.html?(this.config.sanitize&&(e=Ge(e,this.config.whiteList,this.config.sanitizeFn)),t.innerHTML=e):t.textContent=e)},n.getTitle=function(){var t=this.element.getAttribute("data-original-title");return t||(t="function"==typeof this.config.title?this.config.title.call(this.element):this.config.title),t},n._getPopperConfig=function(t){var e=this;return o(o({},{placement:t,modifiers:[{name:"offset",options:{offset:this._getOffset()}},{name:"arrow",options:{element:"."+this.constructor.NAME+"-arrow"}},{name:"preventOverflow",options:{boundary:this.config.boundary}}],onFirstUpdate:function(t){t.originalPlacement!==t.placement&&e._popper.update()}}),this.config.popperConfig)},n._getOffset=function(){var t=this,e={};return"function"==typeof this.config.offset?e.fn=function(e){return e.offsets=o(o({},e.offsets),t.config.offset(e.offsets,t.element)||{}),e}:e.offset=this.config.offset,e},n._getContainer=function(){return!1===this.config.container?document.body:g(this.config.container)?this.config.container:tt.findOne(this.config.container)},n._getAttachment=function(t){return rn[t.toUpperCase()]},n._setListeners=function(){var t=this;this.config.trigger.split(" ").forEach((function(e){if("click"===e)q.on(t.element,t.constructor.Event.CLICK,t.config.selector,(function(e){return t.toggle(e)}));else if("manual"!==e){var n="hover"===e?t.constructor.Event.MOUSEENTER:t.constructor.Event.FOCUSIN,i="hover"===e?t.constructor.Event.MOUSELEAVE:t.constructor.Event.FOCUSOUT;q.on(t.element,n,t.config.selector,(function(e){return t._enter(e)})),q.on(t.element,i,t.config.selector,(function(e){return t._leave(e)}))}})),this._hideModalHandler=function(){t.element&&t.hide()},q.on(this.element.closest(".modal"),"hide.coreui.modal",this._hideModalHandler),this.config.selector?this.config=o(o({},this.config),{},{trigger:"manual",selector:""}):this._fixTitle()},n._fixTitle=function(){var t=typeof this.element.getAttribute("data-original-title");(this.element.getAttribute("title")||"string"!==t)&&(this.element.setAttribute("data-original-title",this.element.getAttribute("title")||""),this.element.setAttribute("title",""))},n._enter=function(t,e){var n=this.constructor.DATA_KEY;(e=e||k(t.target,n))||(e=new this.constructor(t.target,this._getDelegateConfig()),L(t.target,n,e)),t&&(e._activeTrigger["focusin"===t.type?"focus":"hover"]=!0),e.getTipElement().classList.contains("show")||"show"===e._hoverState?e._hoverState="show":(clearTimeout(e._timeout),e._hoverState="show",e.config.delay&&e.config.delay.show?e._timeout=setTimeout((function(){"show"===e._hoverState&&e.show()}),e.config.delay.show):e.show())},n._leave=function(t,e){var n=this.constructor.DATA_KEY;(e=e||k(t.target,n))||(e=new this.constructor(t.target,this._getDelegateConfig()),L(t.target,n,e)),t&&(e._activeTrigger["focusout"===t.type?"focus":"hover"]=!1),e._isWithActiveTrigger()||(clearTimeout(e._timeout),e._hoverState="out",e.config.delay&&e.config.delay.hide?e._timeout=setTimeout((function(){"out"===e._hoverState&&e.hide()}),e.config.delay.hide):e.hide())},n._isWithActiveTrigger=function(){for(var t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1},n._getConfig=function(t){var e=at.getDataAttributes(this.element);return Object.keys(e).forEach((function(t){-1!==nn.indexOf(t)&&delete e[t]})),t&&"object"==typeof t.container&&t.container.jquery&&(t.container=t.container[0]),"number"==typeof(t=o(o(o({},this.constructor.Default),e),"object"==typeof t&&t?t:{})).delay&&(t.delay={show:t.delay,hide:t.delay}),"number"==typeof t.title&&(t.title=t.title.toString()),"number"==typeof t.content&&(t.content=t.content.toString()),v(Ze,t,this.constructor.DefaultType),t.sanitize&&(t.template=Ge(t.template,t.whiteList,t.sanitizeFn)),t},n._getDelegateConfig=function(){var t={};if(this.config)for(var e in this.config)this.constructor.Default[e]!==this.config[e]&&(t[e]=this.config[e]);return t},n._cleanTipClass=function(){var t=this.getTipElement();console.log(this.tip);var e=t.getAttribute("class").match(en);null!==e&&e.length>0&&e.map((function(t){return t.trim()})).forEach((function(e){return t.classList.remove(e)}))},n._fixTransition=function(){var t=this.getTipElement(),e=this.config.animation;null===t.getAttribute("data-popper-placement")&&(t.classList.remove("fade"),this.config.animation=!1,this.hide(),this.show(),this.config.animation=e)},t.jQueryInterface=function(e){return this.each((function(){var n=k(this,"coreui.tooltip"),i="object"==typeof e&&e;if((n||!/dispose|hide/.test(e))&&(n||(n=new t(this,i)),"string"==typeof e)){if("undefined"==typeof n[e])throw new TypeError('No method named "'+e+'"');n[e]()}}))},t.getInstance=function(t){return k(t,"coreui.tooltip")},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return sn}},{key:"NAME",get:function(){return Ze}},{key:"DATA_KEY",get:function(){return"coreui.tooltip"}},{key:"Event",get:function(){return an}},{key:"EVENT_KEY",get:function(){return tn}},{key:"DefaultType",get:function(){return on}}]),t}(),cn=w();if(cn){var un=cn.fn[Ze];cn.fn[Ze]=ln.jQueryInterface,cn.fn[Ze].Constructor=ln,cn.fn[Ze].noConflict=function(){return cn.fn[Ze]=un,ln.jQueryInterface}}var fn="popover",dn="coreui.popover",hn="."+dn,pn=new RegExp("(^|\\s)bs-popover\\S+","g"),gn=o(o({},ln.Default),{},{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'}),mn=o(o({},ln.DefaultType),{},{content:"(string|element|function)"}),vn={HIDE:"hide"+hn,HIDDEN:"hidden"+hn,SHOW:"show"+hn,SHOWN:"shown"+hn,INSERTED:"inserted"+hn,CLICK:"click"+hn,FOCUSIN:"focusin"+hn,FOCUSOUT:"focusout"+hn,MOUSEENTER:"mouseenter"+hn,MOUSELEAVE:"mouseleave"+hn},_n=function(t){var n,i;function o(){return t.apply(this,arguments)||this}i=t,(n=o).prototype=Object.create(i.prototype),n.prototype.constructor=n,n.__proto__=i;var r=o.prototype;return r.isWithContent=function(){return this.getTitle()||this._getContent()},r.setContent=function(){var t=this.getTipElement();this.setElementContent(tt.findOne(".popover-header",t),this.getTitle());var e=this._getContent();"function"==typeof e&&(e=e.call(this.element)),this.setElementContent(tt.findOne(".popover-body",t),e),t.classList.remove("fade","show")},r._addAttachmentClass=function(t){this.getTipElement().classList.add("bs-popover-"+t)},r._getContent=function(){return this.element.getAttribute("data-content")||this.config.content},r._cleanTipClass=function(){var t=this.getTipElement(),e=t.getAttribute("class").match(pn);null!==e&&e.length>0&&e.map((function(t){return t.trim()})).forEach((function(e){return t.classList.remove(e)}))},o.jQueryInterface=function(t){return this.each((function(){var e=k(this,dn),n="object"==typeof t?t:null;if((e||!/dispose|hide/.test(t))&&(e||(e=new o(this,n),L(this,dn,e)),"string"==typeof t)){if("undefined"==typeof e[t])throw new TypeError('No method named "'+t+'"');e[t]()}}))},o.getInstance=function(t){return k(t,dn)},e(o,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return gn}},{key:"NAME",get:function(){return fn}},{key:"DATA_KEY",get:function(){return dn}},{key:"Event",get:function(){return vn}},{key:"EVENT_KEY",get:function(){return hn}},{key:"DefaultType",get:function(){return mn}}]),o}(ln),bn=w();if(bn){var yn=bn.fn[fn];bn.fn[fn]=_n.jQueryInterface,bn.fn[fn].Constructor=_n,bn.fn[fn].noConflict=function(){return bn.fn[fn]=yn,_n.jQueryInterface}}var wn="scrollspy",En="coreui.scrollspy",Ln={offset:10,method:"auto",target:""},kn={offset:"number",method:"string",target:"(string|element)"},Tn=function(){function t(t,e){var n=this;this._element=t,this._scrollElement="BODY"===t.tagName?window:t,this._config=this._getConfig(e),this._selector=this._config.target+" .nav-link,"+this._config.target+" .list-group-item,"+this._config.target+" .dropdown-item",this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,q.on(this._scrollElement,"scroll.coreui.scrollspy",(function(t){return n._process(t)})),this.refresh(),this._process(),L(t,En,this)}var n=t.prototype;return n.refresh=function(){var t=this,e=this._scrollElement===this._scrollElement.window?"offset":"position",n="auto"===this._config.method?e:this._config.method,i="position"===n?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight(),tt.find(this._selector).map((function(t){var e,o=f(t);if(o&&(e=tt.findOne(o)),e){var r=e.getBoundingClientRect();if(r.width||r.height)return[at[n](e).top+i,o]}return null})).filter((function(t){return t})).sort((function(t,e){return t[0]-e[0]})).forEach((function(e){t._offsets.push(e[0]),t._targets.push(e[1])}))},n.dispose=function(){T(this._element,En),q.off(this._scrollElement,".coreui.scrollspy"),this._element=null,this._scrollElement=null,this._config=null,this._selector=null,this._offsets=null,this._targets=null,this._activeTarget=null,this._scrollHeight=null},n._getConfig=function(t){if("string"!=typeof(t=o(o({},Ln),"object"==typeof t&&t?t:{})).target&&g(t.target)){var e=t.target.id;e||(e=c(wn),t.target.id=e),t.target="#"+e}return v(wn,t,kn),t},n._getScrollTop=function(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop},n._getScrollHeight=function(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)},n._getOffsetHeight=function(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height},n._process=function(){var t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),n=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),t>=n){var i=this._targets[this._targets.length-1];this._activeTarget!==i&&this._activate(i)}else{if(this._activeTarget&&t<this._offsets[0]&&this._offsets[0]>0)return this._activeTarget=null,void this._clear();for(var o=this._offsets.length;o--;){this._activeTarget!==this._targets[o]&&t>=this._offsets[o]&&("undefined"==typeof this._offsets[o+1]||t<this._offsets[o+1])&&this._activate(this._targets[o])}}},n._activate=function(t){this._activeTarget=t,this._clear();var e=this._selector.split(",").map((function(e){return e+'[data-target="'+t+'"],'+e+'[href="'+t+'"]'})),n=tt.findOne(e.join(","));n.classList.contains("dropdown-item")?(tt.findOne(".dropdown-toggle",n.closest(".dropdown")).classList.add("active"),n.classList.add("active")):(n.classList.add("active"),tt.parents(n,".nav, .list-group").forEach((function(t){tt.prev(t,".nav-link, .list-group-item").forEach((function(t){return t.classList.add("active")})),tt.prev(t,".nav-item").forEach((function(t){tt.children(t,".nav-link").forEach((function(t){return t.classList.add("active")}))}))}))),q.trigger(this._scrollElement,"activate.coreui.scrollspy",{relatedTarget:t})},n._clear=function(){tt.find(this._selector).filter((function(t){return t.classList.contains("active")})).forEach((function(t){return t.classList.remove("active")}))},t.jQueryInterface=function(e){return this.each((function(){var n=k(this,En);if(n||(n=new t(this,"object"==typeof e&&e)),"string"==typeof e){if("undefined"==typeof n[e])throw new TypeError('No method named "'+e+'"');n[e]()}}))},t.getInstance=function(t){return k(t,En)},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return Ln}}]),t}();q.on(window,"load.coreui.scrollspy.data-api",(function(){tt.find('[data-spy="scroll"]').forEach((function(t){return new Tn(t,at.getDataAttributes(t))}))}));var An=w();if(An){var On=An.fn[wn];An.fn[wn]=Tn.jQueryInterface,An.fn[wn].Constructor=Tn,An.fn[wn].noConflict=function(){return An.fn[wn]=On,Tn.jQueryInterface}}
        /*!
       * perfect-scrollbar v1.5.0
       * Copyright 2020 Hyunje Jun, MDBootstrap and Contributors
       * Licensed under MIT
       */function Sn(t){return getComputedStyle(t)}function Cn(t,e){for(var n in e){var i=e[n];"number"==typeof i&&(i+="px"),t.style[n]=i}return t}function Dn(t){var e=document.createElement("div");return e.className=t,e}var xn="undefined"!=typeof Element&&(Element.prototype.matches||Element.prototype.webkitMatchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector);function jn(t,e){if(!xn)throw new Error("No element matching method supported");return xn.call(t,e)}function Nn(t){t.remove?t.remove():t.parentNode&&t.parentNode.removeChild(t)}function In(t,e){return Array.prototype.filter.call(t.children,(function(t){return jn(t,e)}))}var Pn="ps",Rn="ps__rtl",Mn={thumb:function(t){return"ps__thumb-"+t},rail:function(t){return"ps__rail-"+t},consuming:"ps__child--consume"},Hn={focus:"ps--focus",clicking:"ps--clicking",active:function(t){return"ps--active-"+t},scrolling:function(t){return"ps--scrolling-"+t}},Wn={x:null,y:null};function Yn(t,e){var n=t.element.classList,i=Hn.scrolling(e);n.contains(i)?clearTimeout(Wn[e]):n.add(i)}function Xn(t,e){Wn[e]=setTimeout((function(){return t.isAlive&&t.element.classList.remove(Hn.scrolling(e))}),t.settings.scrollingThreshold)}var Bn=function(t){this.element=t,this.handlers={}},Un={isEmpty:{configurable:!0}};Bn.prototype.bind=function(t,e){"undefined"==typeof this.handlers[t]&&(this.handlers[t]=[]),this.handlers[t].push(e),this.element.addEventListener(t,e,!1)},Bn.prototype.unbind=function(t,e){var n=this;this.handlers[t]=this.handlers[t].filter((function(i){return!(!e||i===e)||(n.element.removeEventListener(t,i,!1),!1)}))},Bn.prototype.unbindAll=function(){for(var t in this.handlers)this.unbind(t)},Un.isEmpty.get=function(){var t=this;return Object.keys(this.handlers).every((function(e){return 0===t.handlers[e].length}))},Object.defineProperties(Bn.prototype,Un);var qn=function(){this.eventElements=[]};function Fn(t){if("function"==typeof window.CustomEvent)return new CustomEvent(t);var e=document.createEvent("CustomEvent");return e.initCustomEvent(t,!1,!1,void 0),e}function Qn(t,e,n,i,o){var r;if(void 0===i&&(i=!0),void 0===o&&(o=!1),"top"===e)r=["contentHeight","containerHeight","scrollTop","y","up","down"];else{if("left"!==e)throw new Error("A proper axis should be provided");r=["contentWidth","containerWidth","scrollLeft","x","left","right"]}!function(t,e,n,i,o){var r=n[0],s=n[1],a=n[2],l=n[3],c=n[4],u=n[5];void 0===i&&(i=!0);void 0===o&&(o=!1);var f=t.element;t.reach[l]=null,f[a]<1&&(t.reach[l]="start");f[a]>t[r]-t[s]-1&&(t.reach[l]="end");e&&(f.dispatchEvent(Fn("ps-scroll-"+l)),e<0?f.dispatchEvent(Fn("ps-scroll-"+c)):e>0&&f.dispatchEvent(Fn("ps-scroll-"+u)),i&&function(t,e){Yn(t,e),Xn(t,e)}(t,l));t.reach[l]&&(e||o)&&f.dispatchEvent(Fn("ps-"+l+"-reach-"+t.reach[l]))}(t,n,r,i,o)}function zn(t){return parseInt(t,10)||0}qn.prototype.eventElement=function(t){var e=this.eventElements.filter((function(e){return e.element===t}))[0];return e||(e=new Bn(t),this.eventElements.push(e)),e},qn.prototype.bind=function(t,e,n){this.eventElement(t).bind(e,n)},qn.prototype.unbind=function(t,e,n){var i=this.eventElement(t);i.unbind(e,n),i.isEmpty&&this.eventElements.splice(this.eventElements.indexOf(i),1)},qn.prototype.unbindAll=function(){this.eventElements.forEach((function(t){return t.unbindAll()})),this.eventElements=[]},qn.prototype.once=function(t,e,n){var i=this.eventElement(t),o=function(t){i.unbind(e,o),n(t)};i.bind(e,o)};var Vn={isWebKit:"undefined"!=typeof document&&"WebkitAppearance"in document.documentElement.style,supportsTouch:"undefined"!=typeof window&&("ontouchstart"in window||"maxTouchPoints"in window.navigator&&window.navigator.maxTouchPoints>0||window.DocumentTouch&&document instanceof window.DocumentTouch),supportsIePointer:"undefined"!=typeof navigator&&navigator.msMaxTouchPoints,isChrome:"undefined"!=typeof navigator&&/Chrome/i.test(navigator&&navigator.userAgent)};function Kn(t){var e=t.element,n=Math.floor(e.scrollTop),i=e.getBoundingClientRect();t.containerWidth=Math.ceil(i.width),t.containerHeight=Math.ceil(i.height),t.contentWidth=e.scrollWidth,t.contentHeight=e.scrollHeight,e.contains(t.scrollbarXRail)||(In(e,Mn.rail("x")).forEach((function(t){return Nn(t)})),e.appendChild(t.scrollbarXRail)),e.contains(t.scrollbarYRail)||(In(e,Mn.rail("y")).forEach((function(t){return Nn(t)})),e.appendChild(t.scrollbarYRail)),!t.settings.suppressScrollX&&t.containerWidth+t.settings.scrollXMarginOffset<t.contentWidth?(t.scrollbarXActive=!0,t.railXWidth=t.containerWidth-t.railXMarginWidth,t.railXRatio=t.containerWidth/t.railXWidth,t.scrollbarXWidth=$n(t,zn(t.railXWidth*t.containerWidth/t.contentWidth)),t.scrollbarXLeft=zn((t.negativeScrollAdjustment+e.scrollLeft)*(t.railXWidth-t.scrollbarXWidth)/(t.contentWidth-t.containerWidth))):t.scrollbarXActive=!1,!t.settings.suppressScrollY&&t.containerHeight+t.settings.scrollYMarginOffset<t.contentHeight?(t.scrollbarYActive=!0,t.railYHeight=t.containerHeight-t.railYMarginHeight,t.railYRatio=t.containerHeight/t.railYHeight,t.scrollbarYHeight=$n(t,zn(t.railYHeight*t.containerHeight/t.contentHeight)),t.scrollbarYTop=zn(n*(t.railYHeight-t.scrollbarYHeight)/(t.contentHeight-t.containerHeight))):t.scrollbarYActive=!1,t.scrollbarXLeft>=t.railXWidth-t.scrollbarXWidth&&(t.scrollbarXLeft=t.railXWidth-t.scrollbarXWidth),t.scrollbarYTop>=t.railYHeight-t.scrollbarYHeight&&(t.scrollbarYTop=t.railYHeight-t.scrollbarYHeight),function(t,e){var n={width:e.railXWidth},i=Math.floor(t.scrollTop);e.isRtl?n.left=e.negativeScrollAdjustment+t.scrollLeft+e.containerWidth-e.contentWidth:n.left=t.scrollLeft;e.isScrollbarXUsingBottom?n.bottom=e.scrollbarXBottom-i:n.top=e.scrollbarXTop+i;Cn(e.scrollbarXRail,n);var o={top:i,height:e.railYHeight};e.isScrollbarYUsingRight?e.isRtl?o.right=e.contentWidth-(e.negativeScrollAdjustment+t.scrollLeft)-e.scrollbarYRight-e.scrollbarYOuterWidth-9:o.right=e.scrollbarYRight-t.scrollLeft:e.isRtl?o.left=e.negativeScrollAdjustment+t.scrollLeft+2*e.containerWidth-e.contentWidth-e.scrollbarYLeft-e.scrollbarYOuterWidth:o.left=e.scrollbarYLeft+t.scrollLeft;Cn(e.scrollbarYRail,o),Cn(e.scrollbarX,{left:e.scrollbarXLeft,width:e.scrollbarXWidth-e.railBorderXWidth}),Cn(e.scrollbarY,{top:e.scrollbarYTop,height:e.scrollbarYHeight-e.railBorderYWidth})}(e,t),t.scrollbarXActive?e.classList.add(Hn.active("x")):(e.classList.remove(Hn.active("x")),t.scrollbarXWidth=0,t.scrollbarXLeft=0,e.scrollLeft=!0===t.isRtl?t.contentWidth:0),t.scrollbarYActive?e.classList.add(Hn.active("y")):(e.classList.remove(Hn.active("y")),t.scrollbarYHeight=0,t.scrollbarYTop=0,e.scrollTop=0)}function $n(t,e){return t.settings.minScrollbarLength&&(e=Math.max(e,t.settings.minScrollbarLength)),t.settings.maxScrollbarLength&&(e=Math.min(e,t.settings.maxScrollbarLength)),e}function Jn(t,e){var n=e[0],i=e[1],o=e[2],r=e[3],s=e[4],a=e[5],l=e[6],c=e[7],u=e[8],f=t.element,d=null,h=null,p=null;function g(e){e.touches&&e.touches[0]&&(e[o]=e.touches[0].pageY),f[l]=d+p*(e[o]-h),Yn(t,c),Kn(t),e.stopPropagation(),e.preventDefault()}function m(){Xn(t,c),t[u].classList.remove(Hn.clicking),t.event.unbind(t.ownerDocument,"mousemove",g)}function v(e,s){d=f[l],s&&e.touches&&(e[o]=e.touches[0].pageY),h=e[o],p=(t[i]-t[n])/(t[r]-t[a]),s?t.event.bind(t.ownerDocument,"touchmove",g):(t.event.bind(t.ownerDocument,"mousemove",g),t.event.once(t.ownerDocument,"mouseup",m),e.preventDefault()),t[u].classList.add(Hn.clicking),e.stopPropagation()}t.event.bind(t[s],"mousedown",(function(t){v(t)})),t.event.bind(t[s],"touchstart",(function(t){v(t,!0)}))}var Gn={"click-rail":function(t){t.element,t.event.bind(t.scrollbarY,"mousedown",(function(t){return t.stopPropagation()})),t.event.bind(t.scrollbarYRail,"mousedown",(function(e){var n=e.pageY-window.pageYOffset-t.scrollbarYRail.getBoundingClientRect().top>t.scrollbarYTop?1:-1;t.element.scrollTop+=n*t.containerHeight,Kn(t),e.stopPropagation()})),t.event.bind(t.scrollbarX,"mousedown",(function(t){return t.stopPropagation()})),t.event.bind(t.scrollbarXRail,"mousedown",(function(e){var n=e.pageX-window.pageXOffset-t.scrollbarXRail.getBoundingClientRect().left>t.scrollbarXLeft?1:-1;t.element.scrollLeft+=n*t.containerWidth,Kn(t),e.stopPropagation()}))},"drag-thumb":function(t){Jn(t,["containerWidth","contentWidth","pageX","railXWidth","scrollbarX","scrollbarXWidth","scrollLeft","x","scrollbarXRail"]),Jn(t,["containerHeight","contentHeight","pageY","railYHeight","scrollbarY","scrollbarYHeight","scrollTop","y","scrollbarYRail"])},keyboard:function(t){var e=t.element;t.event.bind(t.ownerDocument,"keydown",(function(n){if(!(n.isDefaultPrevented&&n.isDefaultPrevented()||n.defaultPrevented)&&(jn(e,":hover")||jn(t.scrollbarX,":focus")||jn(t.scrollbarY,":focus"))){var i,o=document.activeElement?document.activeElement:t.ownerDocument.activeElement;if(o){if("IFRAME"===o.tagName)o=o.contentDocument.activeElement;else for(;o.shadowRoot;)o=o.shadowRoot.activeElement;if(jn(i=o,"input,[contenteditable]")||jn(i,"select,[contenteditable]")||jn(i,"textarea,[contenteditable]")||jn(i,"button,[contenteditable]"))return}var r=0,s=0;switch(n.which){case 37:r=n.metaKey?-t.contentWidth:n.altKey?-t.containerWidth:-30;break;case 38:s=n.metaKey?t.contentHeight:n.altKey?t.containerHeight:30;break;case 39:r=n.metaKey?t.contentWidth:n.altKey?t.containerWidth:30;break;case 40:s=n.metaKey?-t.contentHeight:n.altKey?-t.containerHeight:-30;break;case 32:s=n.shiftKey?t.containerHeight:-t.containerHeight;break;case 33:s=t.containerHeight;break;case 34:s=-t.containerHeight;break;case 36:s=t.contentHeight;break;case 35:s=-t.contentHeight;break;default:return}t.settings.suppressScrollX&&0!==r||t.settings.suppressScrollY&&0!==s||(e.scrollTop-=s,e.scrollLeft+=r,Kn(t),function(n,i){var o=Math.floor(e.scrollTop);if(0===n){if(!t.scrollbarYActive)return!1;if(0===o&&i>0||o>=t.contentHeight-t.containerHeight&&i<0)return!t.settings.wheelPropagation}var r=e.scrollLeft;if(0===i){if(!t.scrollbarXActive)return!1;if(0===r&&n<0||r>=t.contentWidth-t.containerWidth&&n>0)return!t.settings.wheelPropagation}return!0}(r,s)&&n.preventDefault())}}))},wheel:function(t){var e=t.element;function n(n){var i=function(t){var e=t.deltaX,n=-1*t.deltaY;return"undefined"!=typeof e&&"undefined"!=typeof n||(e=-1*t.wheelDeltaX/6,n=t.wheelDeltaY/6),t.deltaMode&&1===t.deltaMode&&(e*=10,n*=10),e!=e&&n!=n&&(e=0,n=t.wheelDelta),t.shiftKey?[-n,-e]:[e,n]}(n),o=i[0],r=i[1];if(!function(t,n,i){if(!Vn.isWebKit&&e.querySelector("select:focus"))return!0;if(!e.contains(t))return!1;for(var o=t;o&&o!==e;){if(o.classList.contains(Mn.consuming))return!0;var r=Sn(o);if(i&&r.overflowY.match(/(scroll|auto)/)){var s=o.scrollHeight-o.clientHeight;if(s>0&&(o.scrollTop>0&&i<0||o.scrollTop<s&&i>0))return!0}if(n&&r.overflowX.match(/(scroll|auto)/)){var a=o.scrollWidth-o.clientWidth;if(a>0&&(o.scrollLeft>0&&n<0||o.scrollLeft<a&&n>0))return!0}o=o.parentNode}return!1}(n.target,o,r)){var s=!1;t.settings.useBothWheelAxes?t.scrollbarYActive&&!t.scrollbarXActive?(r?e.scrollTop-=r*t.settings.wheelSpeed:e.scrollTop+=o*t.settings.wheelSpeed,s=!0):t.scrollbarXActive&&!t.scrollbarYActive&&(o?e.scrollLeft+=o*t.settings.wheelSpeed:e.scrollLeft-=r*t.settings.wheelSpeed,s=!0):(e.scrollTop-=r*t.settings.wheelSpeed,e.scrollLeft+=o*t.settings.wheelSpeed),Kn(t),(s=s||function(n,i){var o=Math.floor(e.scrollTop),r=0===e.scrollTop,s=o+e.offsetHeight===e.scrollHeight,a=0===e.scrollLeft,l=e.scrollLeft+e.offsetWidth===e.scrollWidth;return!(Math.abs(i)>Math.abs(n)?r||s:a||l)||!t.settings.wheelPropagation}(o,r))&&!n.ctrlKey&&(n.stopPropagation(),n.preventDefault())}}"undefined"!=typeof window.onwheel?t.event.bind(e,"wheel",n):"undefined"!=typeof window.onmousewheel&&t.event.bind(e,"mousewheel",n)},touch:function(t){if(Vn.supportsTouch||Vn.supportsIePointer){var e=t.element,n={},i=0,o={},r=null;Vn.supportsTouch?(t.event.bind(e,"touchstart",c),t.event.bind(e,"touchmove",u),t.event.bind(e,"touchend",f)):Vn.supportsIePointer&&(window.PointerEvent?(t.event.bind(e,"pointerdown",c),t.event.bind(e,"pointermove",u),t.event.bind(e,"pointerup",f)):window.MSPointerEvent&&(t.event.bind(e,"MSPointerDown",c),t.event.bind(e,"MSPointerMove",u),t.event.bind(e,"MSPointerUp",f)))}function s(n,i){e.scrollTop-=i,e.scrollLeft-=n,Kn(t)}function a(t){return t.targetTouches?t.targetTouches[0]:t}function l(t){return(!t.pointerType||"pen"!==t.pointerType||0!==t.buttons)&&(!(!t.targetTouches||1!==t.targetTouches.length)||!(!t.pointerType||"mouse"===t.pointerType||t.pointerType===t.MSPOINTER_TYPE_MOUSE))}function c(t){if(l(t)){var e=a(t);n.pageX=e.pageX,n.pageY=e.pageY,i=(new Date).getTime(),null!==r&&clearInterval(r)}}function u(r){if(l(r)){var c=a(r),u={pageX:c.pageX,pageY:c.pageY},f=u.pageX-n.pageX,d=u.pageY-n.pageY;if(function(t,n,i){if(!e.contains(t))return!1;for(var o=t;o&&o!==e;){if(o.classList.contains(Mn.consuming))return!0;var r=Sn(o);if(i&&r.overflowY.match(/(scroll|auto)/)){var s=o.scrollHeight-o.clientHeight;if(s>0&&(o.scrollTop>0&&i<0||o.scrollTop<s&&i>0))return!0}if(n&&r.overflowX.match(/(scroll|auto)/)){var a=o.scrollWidth-o.clientWidth;if(a>0&&(o.scrollLeft>0&&n<0||o.scrollLeft<a&&n>0))return!0}o=o.parentNode}return!1}(r.target,f,d))return;s(f,d),n=u;var h=(new Date).getTime(),p=h-i;p>0&&(o.x=f/p,o.y=d/p,i=h),function(n,i){var o=Math.floor(e.scrollTop),r=e.scrollLeft,s=Math.abs(n),a=Math.abs(i);if(a>s){if(i<0&&o===t.contentHeight-t.containerHeight||i>0&&0===o)return 0===window.scrollY&&i>0&&Vn.isChrome}else if(s>a&&(n<0&&r===t.contentWidth-t.containerWidth||n>0&&0===r))return!0;return!0}(f,d)&&r.preventDefault()}}function f(){t.settings.swipeEasing&&(clearInterval(r),r=setInterval((function(){t.isInitialized?clearInterval(r):o.x||o.y?Math.abs(o.x)<.01&&Math.abs(o.y)<.01?clearInterval(r):(s(30*o.x,30*o.y),o.x*=.8,o.y*=.8):clearInterval(r)}),10))}}},Zn=function(t,e){var n=this;if(void 0===e&&(e={}),"string"==typeof t&&(t=document.querySelector(t)),!t||!t.nodeName)throw new Error("no element is specified to initialize PerfectScrollbar");for(var i in this.element=t,t.classList.add(Pn),this.settings={handlers:["click-rail","drag-thumb","keyboard","wheel","touch"],maxScrollbarLength:null,minScrollbarLength:null,scrollingThreshold:1e3,scrollXMarginOffset:0,scrollYMarginOffset:0,suppressScrollX:!1,suppressScrollY:!1,swipeEasing:!0,useBothWheelAxes:!1,wheelPropagation:!0,wheelSpeed:1},e)this.settings[i]=e[i];this.containerWidth=null,this.containerHeight=null,this.contentWidth=null,this.contentHeight=null;var o,r,s=function(){return t.classList.add(Hn.focus)},a=function(){return t.classList.remove(Hn.focus)};this.isRtl="rtl"===Sn(t).direction,!0===this.isRtl&&t.classList.add(Rn),this.isNegativeScroll=(r=t.scrollLeft,t.scrollLeft=-1,o=t.scrollLeft<0,t.scrollLeft=r,o),this.negativeScrollAdjustment=this.isNegativeScroll?t.scrollWidth-t.clientWidth:0,this.event=new qn,this.ownerDocument=t.ownerDocument||document,this.scrollbarXRail=Dn(Mn.rail("x")),t.appendChild(this.scrollbarXRail),this.scrollbarX=Dn(Mn.thumb("x")),this.scrollbarXRail.appendChild(this.scrollbarX),this.scrollbarX.setAttribute("tabindex",0),this.event.bind(this.scrollbarX,"focus",s),this.event.bind(this.scrollbarX,"blur",a),this.scrollbarXActive=null,this.scrollbarXWidth=null,this.scrollbarXLeft=null;var l=Sn(this.scrollbarXRail);this.scrollbarXBottom=parseInt(l.bottom,10),isNaN(this.scrollbarXBottom)?(this.isScrollbarXUsingBottom=!1,this.scrollbarXTop=zn(l.top)):this.isScrollbarXUsingBottom=!0,this.railBorderXWidth=zn(l.borderLeftWidth)+zn(l.borderRightWidth),Cn(this.scrollbarXRail,{display:"block"}),this.railXMarginWidth=zn(l.marginLeft)+zn(l.marginRight),Cn(this.scrollbarXRail,{display:""}),this.railXWidth=null,this.railXRatio=null,this.scrollbarYRail=Dn(Mn.rail("y")),t.appendChild(this.scrollbarYRail),this.scrollbarY=Dn(Mn.thumb("y")),this.scrollbarYRail.appendChild(this.scrollbarY),this.scrollbarY.setAttribute("tabindex",0),this.event.bind(this.scrollbarY,"focus",s),this.event.bind(this.scrollbarY,"blur",a),this.scrollbarYActive=null,this.scrollbarYHeight=null,this.scrollbarYTop=null;var c=Sn(this.scrollbarYRail);this.scrollbarYRight=parseInt(c.right,10),isNaN(this.scrollbarYRight)?(this.isScrollbarYUsingRight=!1,this.scrollbarYLeft=zn(c.left)):this.isScrollbarYUsingRight=!0,this.scrollbarYOuterWidth=this.isRtl?function(t){var e=Sn(t);return zn(e.width)+zn(e.paddingLeft)+zn(e.paddingRight)+zn(e.borderLeftWidth)+zn(e.borderRightWidth)}(this.scrollbarY):null,this.railBorderYWidth=zn(c.borderTopWidth)+zn(c.borderBottomWidth),Cn(this.scrollbarYRail,{display:"block"}),this.railYMarginHeight=zn(c.marginTop)+zn(c.marginBottom),Cn(this.scrollbarYRail,{display:""}),this.railYHeight=null,this.railYRatio=null,this.reach={x:t.scrollLeft<=0?"start":t.scrollLeft>=this.contentWidth-this.containerWidth?"end":null,y:t.scrollTop<=0?"start":t.scrollTop>=this.contentHeight-this.containerHeight?"end":null},this.isAlive=!0,this.settings.handlers.forEach((function(t){return Gn[t](n)})),this.lastScrollTop=Math.floor(t.scrollTop),this.lastScrollLeft=t.scrollLeft,this.event.bind(this.element,"scroll",(function(t){return n.onScroll(t)})),Kn(this)};Zn.prototype.update=function(){this.isAlive&&(this.negativeScrollAdjustment=this.isNegativeScroll?this.element.scrollWidth-this.element.clientWidth:0,Cn(this.scrollbarXRail,{display:"block"}),Cn(this.scrollbarYRail,{display:"block"}),this.railXMarginWidth=zn(Sn(this.scrollbarXRail).marginLeft)+zn(Sn(this.scrollbarXRail).marginRight),this.railYMarginHeight=zn(Sn(this.scrollbarYRail).marginTop)+zn(Sn(this.scrollbarYRail).marginBottom),Cn(this.scrollbarXRail,{display:"none"}),Cn(this.scrollbarYRail,{display:"none"}),Kn(this),Qn(this,"top",0,!1,!0),Qn(this,"left",0,!1,!0),Cn(this.scrollbarXRail,{display:""}),Cn(this.scrollbarYRail,{display:""}))},Zn.prototype.onScroll=function(t){this.isAlive&&(Kn(this),Qn(this,"top",this.element.scrollTop-this.lastScrollTop),Qn(this,"left",this.element.scrollLeft-this.lastScrollLeft),this.lastScrollTop=Math.floor(this.element.scrollTop),this.lastScrollLeft=this.element.scrollLeft)},Zn.prototype.destroy=function(){this.isAlive&&(this.event.unbindAll(),Nn(this.scrollbarX),Nn(this.scrollbarY),Nn(this.scrollbarXRail),Nn(this.scrollbarYRail),this.removePsClasses(),this.element=null,this.scrollbarX=null,this.scrollbarY=null,this.scrollbarXRail=null,this.scrollbarYRail=null,this.isAlive=!1)},Zn.prototype.removePsClasses=function(){this.element.className=this.element.className.split(" ").filter((function(t){return!t.match(/^ps([-_].+|)$/)})).join(" ")};var ti="sidebar",ei={breakpoints:{xs:"c-sidebar-show",sm:"c-sidebar-sm-show",md:"c-sidebar-md-show",lg:"c-sidebar-lg-show",xl:"c-sidebar-xl-show"},dropdownAccordion:!0},ni={breakpoints:"object",dropdownAccordion:"(string|boolean)"},ii=function(){function t(t,e){if("undefined"==typeof Zn)throw new TypeError("CoreUI's sidebar require Perfect Scrollbar");this._element=t,this._config=this._getConfig(e),this._open=this._isVisible(),this._mobile=this._isMobile(),this._overlaid=this._isOverlaid(),this._minimize=this._isMinimized(),this._unfoldable=this._isUnfoldable(),this._setActiveLink(),this._ps=null,this._backdrop=null,this._psInit(),this._addEventListeners(),L(t,"coreui.sidebar",this)}var n=t.prototype;return n.open=function(t){var e=this;q.trigger(this._element,"open.coreui.sidebar"),this._isMobile()?(this._addClassName(this._firstBreakpointClassName()),this._showBackdrop(),q.one(this._element,"transitionend",(function(){e._addClickOutListener()}))):t?(this._addClassName(this._getBreakpointClassName(t)),this._isOverlaid()&&q.one(this._element,"transitionend",(function(){e._addClickOutListener()}))):(this._addClassName(this._firstBreakpointClassName()),this._isOverlaid()&&q.one(this._element,"transitionend",(function(){e._addClickOutListener()})));q.one(this._element,"transitionend",(function(){!0===e._isVisible()&&(e._open=!0,q.trigger(e._element,"opened.coreui.sidebar"))}))},n.close=function(t){var e=this;q.trigger(this._element,"close.coreui.sidebar"),this._isMobile()?(this._element.classList.remove(this._firstBreakpointClassName()),this._removeBackdrop(),this._removeClickOutListener()):t?(this._element.classList.remove(this._getBreakpointClassName(t)),this._isOverlaid()&&this._removeClickOutListener()):(this._element.classList.remove(this._firstBreakpointClassName()),this._isOverlaid()&&this._removeClickOutListener());q.one(this._element,"transitionend",(function(){!1===e._isVisible()&&(e._open=!1,q.trigger(e._element,"closed.coreui.sidebar"))}))},n.toggle=function(t){this._open?this.close(t):this.open(t)},n.minimize=function(){this._isMobile()||(this._addClassName("c-sidebar-minimized"),this._minimize=!0,this._psDestroy())},n.unfoldable=function(){this._isMobile()||(this._addClassName("c-sidebar-unfoldable"),this._unfoldable=!0)},n.reset=function(){this._element.classList.contains("c-sidebar-minimized")&&(this._element.classList.remove("c-sidebar-minimized"),this._minimize=!1,q.one(this._element,"transitionend",this._psInit())),this._element.classList.contains("c-sidebar-unfoldable")&&(this._element.classList.remove("c-sidebar-unfoldable"),this._unfoldable=!1)},n._getConfig=function(t){return t=o(o(o({},this.constructor.Default),at.getDataAttributes(this._element)),t),v(ti,t,this.constructor.DefaultType),t},n._isMobile=function(){return Boolean(window.getComputedStyle(this._element,null).getPropertyValue("--is-mobile"))},n._isIOS=function(){var t=["iPad Simulator","iPhone Simulator","iPod Simulator","iPad","iPhone","iPod"];if(Boolean(navigator.platform))for(;t.length;)if(navigator.platform===t.pop())return!0;return!1},n._isMinimized=function(){return this._element.classList.contains("c-sidebar-minimized")},n._isOverlaid=function(){return this._element.classList.contains("c-sidebar-overlaid")},n._isUnfoldable=function(){return this._element.classList.contains("c-sidebar-unfoldable")},n._isVisible=function(){var t=this._element.getBoundingClientRect();return t.top>=0&&t.left>=0&&t.bottom<=(window.innerHeight||document.documentElement.clientHeight)&&t.right<=(window.innerWidth||document.documentElement.clientWidth)},n._addClassName=function(t){this._element.classList.add(t)},n._firstBreakpointClassName=function(){return Object.keys(ei.breakpoints).map((function(t){return ei.breakpoints[t]}))[0]},n._getBreakpointClassName=function(t){return ei.breakpoints[t]},n._removeBackdrop=function(){this._backdrop&&(this._backdrop.parentNode.removeChild(this._backdrop),this._backdrop=null)},n._showBackdrop=function(){this._backdrop||(this._backdrop=document.createElement("div"),this._backdrop.className="c-sidebar-backdrop",this._backdrop.classList.add("c-fade"),document.body.appendChild(this._backdrop),y(this._backdrop),this._backdrop.classList.add("c-show"))},n._clickOutListener=function(t,e){null===t.target.closest(".c-sidebar")&&(t.preventDefault(),t.stopPropagation(),e.close())},n._addClickOutListener=function(){var t=this;q.on(document,"click.coreui.sidebar.data-api",(function(e){t._clickOutListener(e,t)}))},n._removeClickOutListener=function(){q.off(document,"click.coreui.sidebar.data-api")},n._getAllSiblings=function(t,e){var n=[];t=t.parentNode.firstChild;do{3!==t.nodeType&&(e&&!e(t)||n.push(t))}while(t=t.nextSibling);return n},n._toggleDropdown=function(t,e){var n=t.target;n.classList.contains("c-sidebar-nav-dropdown-toggle")||(n=n.closest(".c-sidebar-nav-dropdown-toggle"));var i=n.closest(".c-sidebar-nav").dataset;"undefined"!=typeof i.dropdownAccordion&&(ei.dropdownAccordion=JSON.parse(i.dropdownAccordion)),!0===ei.dropdownAccordion&&this._getAllSiblings(n.parentElement).forEach((function(t){t!==n.parentNode&&t.classList.contains("c-sidebar-nav-dropdown")&&t.classList.remove("c-show")})),n.parentNode.classList.toggle("c-show"),e._psUpdate()},n._psInit=function(){this._element.querySelector(".c-sidebar-nav")&&!this._isIOS()&&(this._ps=new Zn(this._element.querySelector(".c-sidebar-nav"),{suppressScrollX:!0,wheelPropagation:!1}))},n._psUpdate=function(){this._ps&&this._ps.update()},n._psDestroy=function(){this._ps&&(this._ps.destroy(),this._ps=null)},n._getParents=function(t,e){for(var n=[];t&&t!==document;t=t.parentNode)e?t.matches(e)&&n.push(t):n.push(t);return n},n._setActiveLink=function(){var t=this;Array.from(this._element.querySelectorAll(".c-sidebar-nav-link")).forEach((function(e){var n;"#"===(n=/\\?.*=/.test(String(window.location))||/\\?./.test(String(window.location))?String(window.location).split("?")[0]:/#./.test(String(window.location))?String(window.location).split("#")[0]:String(window.location)).slice(-1)&&(n=n.slice(0,-1)),e.href===n&&(e.classList.add("c-active"),Array.from(t._getParents(e,".c-sidebar-nav-dropdown")).forEach((function(t){t.classList.add("c-show")})))}))},n._addEventListeners=function(){var t=this;this._mobile&&this._open&&this._addClickOutListener(),this._overlaid&&this._open&&this._addClickOutListener(),q.on(this._element,"classtoggle",(function(e){if("c-sidebar-minimized"===e.detail.className&&(t._element.classList.contains("c-sidebar-minimized")?t.minimize():t.reset()),"c-sidebar-unfoldable"===e.detail.className&&(t._element.classList.contains("c-sidebar-unfoldable")?t.unfoldable():t.reset()),"undefined"!=typeof Object.keys(ei.breakpoints).find((function(t){return ei.breakpoints[t]===e.detail.className}))){var n=e.detail.className,i=Object.keys(ei.breakpoints).find((function(t){return ei.breakpoints[t]===n}));e.detail.add?t.open(i):t.close(i)}})),q.on(this._element,"click.coreui.sidebar.data-api",".c-sidebar-nav-dropdown-toggle",(function(e){e.preventDefault(),t._toggleDropdown(e,t)})),q.on(this._element,"click.coreui.sidebar.data-api",".c-sidebar-nav-link",(function(){t._isMobile()&&t.close()}))},t._sidebarInterface=function(e,n){var i=k(e,"coreui.sidebar");if(i||(i=new t(e,"object"==typeof n&&n)),"string"==typeof n){if("undefined"==typeof i[n])throw new TypeError('No method named "'+n+'"');i[n]()}},t.jQueryInterface=function(e){return this.each((function(){t._sidebarInterface(this,e)}))},t.getInstance=function(t){return k(t,"coreui.sidebar")},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"Default",get:function(){return ei}},{key:"DefaultType",get:function(){return ni}}]),t}();q.on(window,"load.coreui.sidebar.data-api",(function(){Array.from(document.querySelectorAll(".c-sidebar")).forEach((function(t){ii._sidebarInterface(t)}))}));var oi=w();if(oi){var ri=oi.fn[ti];oi.fn[ti]=ii.jQueryInterface,oi.fn[ti].Constructor=ii,oi.fn[ti].noConflict=function(){return oi.fn[ti]=ri,ii.jQueryInterface}}var si=function(){function t(t){this._element=t,L(this._element,"coreui.tab",this)}var n=t.prototype;return n.show=function(){var t=this;if(!(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&this._element.classList.contains("active")||this._element.classList.contains("disabled"))){var e,n=d(this._element),i=this._element.closest(".nav, .list-group");if(i){var o="UL"===i.nodeName||"OL"===i.nodeName?":scope > li > .active":".active";e=(e=tt.find(o,i))[e.length-1]}var r=null;if(e&&(r=q.trigger(e,"hide.coreui.tab",{relatedTarget:this._element})),!(q.trigger(this._element,"show.coreui.tab",{relatedTarget:e}).defaultPrevented||null!==r&&r.defaultPrevented)){this._activate(this._element,i);var s=function(){q.trigger(e,"hidden.coreui.tab",{relatedTarget:t._element}),q.trigger(t._element,"shown.coreui.tab",{relatedTarget:e})};n?this._activate(n,n.parentNode,s):s()}}},n.dispose=function(){T(this._element,"coreui.tab"),this._element=null},n._activate=function(t,e,n){var i=this,o=(!e||"UL"!==e.nodeName&&"OL"!==e.nodeName?tt.children(e,".active"):tt.find(":scope > li > .active",e))[0],r=n&&o&&o.classList.contains("fade"),s=function(){return i._transitionComplete(t,o,n)};if(o&&r){var a=h(o);o.classList.remove("show"),q.one(o,"transitionend",s),m(o,a)}else s()},n._transitionComplete=function(t,e,n){if(e){e.classList.remove("active");var i=tt.findOne(":scope > .dropdown-menu .active",e.parentNode);i&&i.classList.remove("active"),"tab"===e.getAttribute("role")&&e.setAttribute("aria-selected",!1)}(t.classList.add("active"),"tab"===t.getAttribute("role")&&t.setAttribute("aria-selected",!0),y(t),t.classList.contains("fade")&&t.classList.add("show"),t.parentNode&&t.parentNode.classList.contains("dropdown-menu"))&&(t.closest(".dropdown")&&tt.find(".dropdown-toggle").forEach((function(t){return t.classList.add("active")})),t.setAttribute("aria-expanded",!0));n&&n()},t.jQueryInterface=function(e){return this.each((function(){var n=k(this,"coreui.tab")||new t(this);if("string"==typeof e){if("undefined"==typeof n[e])throw new TypeError('No method named "'+e+'"');n[e]()}}))},t.getInstance=function(t){return k(t,"coreui.tab")},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}}]),t}();q.on(document,"click.coreui.tab.data-api",'[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',(function(t){t.preventDefault(),(k(this,"coreui.tab")||new si(this)).show()}));var ai=w();if(ai){var li=ai.fn.tab;ai.fn.tab=si.jQueryInterface,ai.fn.tab.Constructor=si,ai.fn.tab.noConflict=function(){return ai.fn.tab=li,si.jQueryInterface}}var ci,ui,fi,di,hi,pi={animation:"boolean",autohide:"boolean",delay:"number"},gi={animation:!0,autohide:!0,delay:500},mi=function(){function t(t,e){this._element=t,this._config=this._getConfig(e),this._timeout=null,this._setListeners(),L(t,"coreui.toast",this)}var n=t.prototype;return n.show=function(){var t=this;if(!q.trigger(this._element,"show.coreui.toast").defaultPrevented){this._config.animation&&this._element.classList.add("fade");var e=function(){t._element.classList.remove("showing"),t._element.classList.add("show"),q.trigger(t._element,"shown.coreui.toast"),t._config.autohide&&(t._timeout=setTimeout((function(){t.hide()}),t._config.delay))};if(this._element.classList.remove("hide"),y(this._element),this._element.classList.add("showing"),this._config.animation){var n=h(this._element);q.one(this._element,"transitionend",e),m(this._element,n)}else e()}},n.hide=function(){var t=this;if(this._element.classList.contains("show")&&!q.trigger(this._element,"hide.coreui.toast").defaultPrevented){var e=function(){t._element.classList.add("hide"),q.trigger(t._element,"hidden.coreui.toast")};if(this._element.classList.remove("show"),this._config.animation){var n=h(this._element);q.one(this._element,"transitionend",e),m(this._element,n)}else e()}},n.dispose=function(){clearTimeout(this._timeout),this._timeout=null,this._element.classList.contains("show")&&this._element.classList.remove("show"),q.off(this._element,"click.dismiss.coreui.toast"),T(this._element,"coreui.toast"),this._element=null,this._config=null},n._getConfig=function(t){return t=o(o(o({},gi),at.getDataAttributes(this._element)),"object"==typeof t&&t?t:{}),v("toast",t,this.constructor.DefaultType),t},n._setListeners=function(){var t=this;q.on(this._element,"click.dismiss.coreui.toast",'[data-dismiss="toast"]',(function(){return t.hide()}))},t.jQueryInterface=function(e){return this.each((function(){var n=k(this,"coreui.toast");if(n||(n=new t(this,"object"==typeof e&&e)),"string"==typeof e){if("undefined"==typeof n[e])throw new TypeError('No method named "'+e+'"');n[e](this)}}))},t.getInstance=function(t){return k(t,"coreui.toast")},e(t,null,[{key:"VERSION",get:function(){return"3.2.0"}},{key:"DefaultType",get:function(){return pi}},{key:"Default",get:function(){return gi}}]),t}(),vi=w();if(vi){var _i=vi.fn.toast;vi.fn.toast=mi.jQueryInterface,vi.fn.toast.Constructor=mi,vi.fn.toast.noConflict=function(){return vi.fn.toast=_i,mi.jQueryInterface}}return Array.from||(Array.from=(ci=Object.prototype.toString,ui=function(t){return"function"==typeof t||"[object Function]"===ci.call(t)},fi=Math.pow(2,53)-1,di=function(t){var e=function(t){var e=Number(t);return isNaN(e)?0:0!==e&&isFinite(e)?(e>0?1:-1)*Math.floor(Math.abs(e)):e}(t);return Math.min(Math.max(e,0),fi)},function(t){var e=this,n=Object(t);if(null==t)throw new TypeError("Array.from requires an array-like object - not null or undefined");var i,o=arguments.length>1?arguments[1]:void 0;if("undefined"!=typeof o){if(!ui(o))throw new TypeError("Array.from: when provided, the second argument must be a function");arguments.length>2&&(i=arguments[2])}for(var r,s=di(n.length),a=ui(e)?Object(new e(s)):new Array(s),l=0;l<s;)r=n[l],a[l]=o?"undefined"==typeof i?o(r,l):o.call(i,r,l):r,l+=1;return a.length=s,a})),Element.prototype.matches||(Element.prototype.matches=Element.prototype.msMatchesSelector||Element.prototype.webkitMatchesSelector),Element.prototype.closest||(Element.prototype.closest=function(t){var e=this;do{if(e.matches(t))return e;e=e.parentElement||e.parentNode}while(null!==e&&1===e.nodeType);return null}),function(){if("function"==typeof window.CustomEvent)return!1;window.CustomEvent=function(t,e){e=e||{bubbles:!1,cancelable:!1,detail:null};var n=document.createEvent("CustomEvent");return n.initCustomEvent(t,e.bubbles,e.cancelable,e.detail),n}}(),Element.prototype.matches||(Element.prototype.matches=Element.prototype.matchesSelector||Element.prototype.mozMatchesSelector||Element.prototype.msMatchesSelector||Element.prototype.oMatchesSelector||Element.prototype.webkitMatchesSelector||function(t){for(var e=(this.document||this.ownerDocument).querySelectorAll(t),n=e.length;--n>=0&&e.item(n)!==this;);return n>-1}),Array.prototype.find||Object.defineProperty(Array.prototype,"find",{value:function(t){if(null==this)throw new TypeError('"this" is null or not defined');var e=Object(this),n=e.length>>>0;if("function"!=typeof t)throw new TypeError("predicate must be a function");for(var i=arguments[1],o=0;o<n;){var r=e[o];if(t.call(i,r,o,e))return r;o++}}}),"function"!=typeof Object.assign&&(Object.assign=function(t,e){if(null==t)throw new TypeError("Cannot convert undefined or null to object");for(var n=Object(t),i=1;i<arguments.length;i++){var o=arguments[i];if(null!=o)for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(n[r]=o[r])}return n}),hi=function(){function t(t){var e=this.constructor;return this.then((function(n){return e.resolve(t()).then((function(){return n}))}),(function(n){return e.resolve(t()).then((function(){return e.reject(n)}))}))}var e=setTimeout;function n(t){return Boolean(t&&"undefined"!=typeof t.length)}function i(){}function o(t){if(!(this instanceof o))throw new TypeError("Promises must be constructed via new");if("function"!=typeof t)throw new TypeError("not a function");this._state=0,this._handled=!1,this._value=void 0,this._deferreds=[],u(t,this)}function r(t,e){for(;3===t._state;)t=t._value;0!==t._state?(t._handled=!0,o._immediateFn((function(){var n=1===t._state?e.onFulfilled:e.onRejected;if(null!==n){var i;try{i=n(t._value)}catch(t){return void a(e.promise,t)}s(e.promise,i)}else(1===t._state?s:a)(e.promise,t._value)}))):t._deferreds.push(e)}function s(t,e){try{if(e===t)throw new TypeError("A promise cannot be resolved with itself.");if(e&&("object"==typeof e||"function"==typeof e)){var n=e.then;if(e instanceof o)return t._state=3,t._value=e,void l(t);if("function"==typeof n)return void u((i=n,r=e,function(){i.apply(r,arguments)}),t)}t._state=1,t._value=e,l(t)}catch(e){a(t,e)}var i,r}function a(t,e){t._state=2,t._value=e,l(t)}function l(t){2===t._state&&0===t._deferreds.length&&o._immediateFn((function(){t._handled||o._unhandledRejectionFn(t._value)}));for(var e=0,n=t._deferreds.length;e<n;e++)r(t,t._deferreds[e]);t._deferreds=null}function c(t,e,n){this.onFulfilled="function"==typeof t?t:null,this.onRejected="function"==typeof e?e:null,this.promise=n}function u(t,e){var n=!1;try{t((function(t){n||(n=!0,s(e,t))}),(function(t){n||(n=!0,a(e,t))}))}catch(t){if(n)return;n=!0,a(e,t)}}o.prototype.catch=function(t){return this.then(null,t)},o.prototype.then=function(t,e){var n=new this.constructor(i);return r(this,new c(t,e,n)),n},o.prototype.finally=t,o.all=function(t){return new o((function(e,i){if(!n(t))return i(new TypeError("Promise.all accepts an array"));var o=Array.prototype.slice.call(t);if(0===o.length)return e([]);var r=o.length;function s(t,n){try{if(n&&("object"==typeof n||"function"==typeof n)){var a=n.then;if("function"==typeof a)return void a.call(n,(function(e){s(t,e)}),i)}o[t]=n,0==--r&&e(o)}catch(t){i(t)}}for(var a=0;a<o.length;a++)s(a,o[a])}))},o.resolve=function(t){return t&&"object"==typeof t&&t.constructor===o?t:new o((function(e){e(t)}))},o.reject=function(t){return new o((function(e,n){n(t)}))},o.race=function(t){return new o((function(e,i){if(!n(t))return i(new TypeError("Promise.race accepts an array"));for(var r=0,s=t.length;r<s;r++)o.resolve(t[r]).then(e,i)}))},o._immediateFn="function"==typeof setImmediate&&function(t){setImmediate(t)}||function(t){e(t,0)},o._unhandledRejectionFn=function(t){"undefined"!=typeof console&&console&&console.warn("Possible Unhandled Promise Rejection:",t)};var f=function(){if("undefined"!=typeof self)return self;if("undefined"!=typeof window)return window;if("undefined"!=typeof global)return global;throw new Error("unable to locate global object")}();"Promise"in f?f.Promise.prototype.finally||(f.Promise.prototype.finally=t):f.Promise=o},"object"==typeof exports&&"undefined"!=typeof module?hi():"function"==typeof define&&define.amd?define(hi):hi(),{AsyncLoad:V,Alert:J,Button:nt,Carousel:gt,ClassToggler:Lt,Collapse:Dt,Dropdown:We,Modal:Fe,Popover:_n,Scrollspy:Tn,Sidebar:ii,Tab:si,Toast:mi,Tooltip:ln}}));
    //# sourceMappingURL=coreui.bundle.min.js.map

    /*!
* @copyright Copyright (c) 2017 IcoMoon.io
* @license   Licensed under MIT license
*            See https://github.com/Keyamoon/svgxuse
* @version   1.2.6
*/
    (function(){if("undefined"!==typeof window&&window.addEventListener){var e=Object.create(null),l,d=function(){clearTimeout(l);l=setTimeout(n,100)},m=function(){},t=function(){window.addEventListener("resize",d,!1);window.addEventListener("orientationchange",d,!1);if(window.MutationObserver){var k=new MutationObserver(d);k.observe(document.documentElement,{childList:!0,subtree:!0,attributes:!0});m=function(){try{k.disconnect(),window.removeEventListener("resize",d,!1),window.removeEventListener("orientationchange",
        d,!1)}catch(v){}}}else document.documentElement.addEventListener("DOMSubtreeModified",d,!1),m=function(){document.documentElement.removeEventListener("DOMSubtreeModified",d,!1);window.removeEventListener("resize",d,!1);window.removeEventListener("orientationchange",d,!1)}},u=function(k){function e(a){if(void 0!==a.protocol)var b=a;else b=document.createElement("a"),b.href=a;return b.protocol.replace(/:/g,"")+b.host}if(window.XMLHttpRequest){var d=new XMLHttpRequest;var m=e(location);k=e(k);d=void 0===
    d.withCredentials&&""!==k&&k!==m?XDomainRequest||void 0:XMLHttpRequest}return d};var n=function(){function d(){--q;0===q&&(m(),t())}function l(a){return function(){!0!==e[a.base]&&(a.useEl.setAttributeNS("http://www.w3.org/1999/xlink","xlink:href","#"+a.hash),a.useEl.hasAttribute("href")&&a.useEl.setAttribute("href","#"+a.hash))}}function p(a){return function(){var c=document.body,b=document.createElement("x");a.onload=null;b.innerHTML=a.responseText;if(b=b.getElementsByTagName("svg")[0])b.setAttribute("aria-hidden",
        "true"),b.style.position="absolute",b.style.width=0,b.style.height=0,b.style.overflow="hidden",c.insertBefore(b,c.firstChild);d()}}function n(a){return function(){a.onerror=null;a.ontimeout=null;d()}}var a,b,q=0;m();var f=document.getElementsByTagName("use");for(b=0;b<f.length;b+=1){try{var h=f[b].getBoundingClientRect()}catch(w){h=!1}var g=(a=f[b].getAttribute("href")||f[b].getAttributeNS("http://www.w3.org/1999/xlink","href")||f[b].getAttribute("xlink:href"))&&a.split?a.split("#"):["",""];var c=
        g[0];g=g[1];var r=h&&0===h.left&&0===h.right&&0===h.top&&0===h.bottom;h&&0===h.width&&0===h.height&&!r?(c.length||!g||document.getElementById(g)||(c=""),f[b].hasAttribute("href")&&f[b].setAttributeNS("http://www.w3.org/1999/xlink","xlink:href",a),c.length&&(a=e[c],!0!==a&&setTimeout(l({useEl:f[b],base:c,hash:g}),0),void 0===a&&(g=u(c),void 0!==g&&(a=new g,e[c]=a,a.onload=p(a),a.onerror=n(a),a.ontimeout=n(a),a.open("GET",c),a.send(),q+=1)))):r?c.length&&e[c]&&setTimeout(l({useEl:f[b],base:c,
        hash:g}),0):void 0===e[c]?e[c]=!0:e[c].onload&&(e[c].abort(),delete e[c].onload,e[c]=!0)}f="";q+=1;d()};var p=function(){window.removeEventListener("load",p,!1);l=setTimeout(n,0)};"complete"!==document.readyState?window.addEventListener("load",p,!1):p()}})();

    /*!
  * CoreUI Plugins - Chart.js for CoreUI 3 v2.0.0 (https://coreui.io)
  * Copyright 2020 creativeLabs ≈Åukasz Holeczek
  * Licensed under MIT (https://coreui.io/license/)
  */
    (function (global, factory) {
        typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
            typeof define === 'function' && define.amd ? define(factory) :
                (global = global || self, (global.coreui = global.coreui || {}, global.coreui.ChartJS = factory()));
    }(this, (function () { 'use strict';

        /*!
	 * Chart.js v2.9.2
	 * https://www.chartjs.org
	 * (c) 2019 Chart.js Contributors
	 * Released under the MIT License
	 */
        (function (global, factory) {
            typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(function() { try { return require('moment'); } catch(e) { } }()) :
                typeof define === 'function' && define.amd ? define(['require'], function(require) { return factory(function() { try { return require('moment'); } catch(e) { } }()); }) :
                    (global = global || self, global.Chart = factory(global.moment));
        }(undefined, (function (moment) {
            moment = moment && moment.hasOwnProperty('default') ? moment['default'] : moment;

            function createCommonjsModule(fn, module) {
                return module = { exports: {} }, fn(module, module.exports), module.exports;
            }

            function getCjsExportFromNamespace (n) {
                return n && n['default'] || n;
            }

            var colorName = {
                "aliceblue": [240, 248, 255],
                "antiquewhite": [250, 235, 215],
                "aqua": [0, 255, 255],
                "aquamarine": [127, 255, 212],
                "azure": [240, 255, 255],
                "beige": [245, 245, 220],
                "bisque": [255, 228, 196],
                "black": [0, 0, 0],
                "blanchedalmond": [255, 235, 205],
                "blue": [0, 0, 255],
                "blueviolet": [138, 43, 226],
                "brown": [165, 42, 42],
                "burlywood": [222, 184, 135],
                "cadetblue": [95, 158, 160],
                "chartreuse": [127, 255, 0],
                "chocolate": [210, 105, 30],
                "coral": [255, 127, 80],
                "cornflowerblue": [100, 149, 237],
                "cornsilk": [255, 248, 220],
                "crimson": [220, 20, 60],
                "cyan": [0, 255, 255],
                "darkblue": [0, 0, 139],
                "darkcyan": [0, 139, 139],
                "darkgoldenrod": [184, 134, 11],
                "darkgray": [169, 169, 169],
                "darkgreen": [0, 100, 0],
                "darkgrey": [169, 169, 169],
                "darkkhaki": [189, 183, 107],
                "darkmagenta": [139, 0, 139],
                "darkolivegreen": [85, 107, 47],
                "darkorange": [255, 140, 0],
                "darkorchid": [153, 50, 204],
                "darkred": [139, 0, 0],
                "darksalmon": [233, 150, 122],
                "darkseagreen": [143, 188, 143],
                "darkslateblue": [72, 61, 139],
                "darkslategray": [47, 79, 79],
                "darkslategrey": [47, 79, 79],
                "darkturquoise": [0, 206, 209],
                "darkviolet": [148, 0, 211],
                "deeppink": [255, 20, 147],
                "deepskyblue": [0, 191, 255],
                "dimgray": [105, 105, 105],
                "dimgrey": [105, 105, 105],
                "dodgerblue": [30, 144, 255],
                "firebrick": [178, 34, 34],
                "floralwhite": [255, 250, 240],
                "forestgreen": [34, 139, 34],
                "fuchsia": [255, 0, 255],
                "gainsboro": [220, 220, 220],
                "ghostwhite": [248, 248, 255],
                "gold": [255, 215, 0],
                "goldenrod": [218, 165, 32],
                "gray": [128, 128, 128],
                "green": [0, 128, 0],
                "greenyellow": [173, 255, 47],
                "grey": [128, 128, 128],
                "honeydew": [240, 255, 240],
                "hotpink": [255, 105, 180],
                "indianred": [205, 92, 92],
                "indigo": [75, 0, 130],
                "ivory": [255, 255, 240],
                "khaki": [240, 230, 140],
                "lavender": [230, 230, 250],
                "lavenderblush": [255, 240, 245],
                "lawngreen": [124, 252, 0],
                "lemonchiffon": [255, 250, 205],
                "lightblue": [173, 216, 230],
                "lightcoral": [240, 128, 128],
                "lightcyan": [224, 255, 255],
                "lightgoldenrodyellow": [250, 250, 210],
                "lightgray": [211, 211, 211],
                "lightgreen": [144, 238, 144],
                "lightgrey": [211, 211, 211],
                "lightpink": [255, 182, 193],
                "lightsalmon": [255, 160, 122],
                "lightseagreen": [32, 178, 170],
                "lightskyblue": [135, 206, 250],
                "lightslategray": [119, 136, 153],
                "lightslategrey": [119, 136, 153],
                "lightsteelblue": [176, 196, 222],
                "lightyellow": [255, 255, 224],
                "lime": [0, 255, 0],
                "limegreen": [50, 205, 50],
                "linen": [250, 240, 230],
                "magenta": [255, 0, 255],
                "maroon": [128, 0, 0],
                "mediumaquamarine": [102, 205, 170],
                "mediumblue": [0, 0, 205],
                "mediumorchid": [186, 85, 211],
                "mediumpurple": [147, 112, 219],
                "mediumseagreen": [60, 179, 113],
                "mediumslateblue": [123, 104, 238],
                "mediumspringgreen": [0, 250, 154],
                "mediumturquoise": [72, 209, 204],
                "mediumvioletred": [199, 21, 133],
                "midnightblue": [25, 25, 112],
                "mintcream": [245, 255, 250],
                "mistyrose": [255, 228, 225],
                "moccasin": [255, 228, 181],
                "navajowhite": [255, 222, 173],
                "navy": [0, 0, 128],
                "oldlace": [253, 245, 230],
                "olive": [128, 128, 0],
                "olivedrab": [107, 142, 35],
                "orange": [255, 165, 0],
                "orangered": [255, 69, 0],
                "orchid": [218, 112, 214],
                "palegoldenrod": [238, 232, 170],
                "palegreen": [152, 251, 152],
                "paleturquoise": [175, 238, 238],
                "palevioletred": [219, 112, 147],
                "papayawhip": [255, 239, 213],
                "peachpuff": [255, 218, 185],
                "peru": [205, 133, 63],
                "pink": [255, 192, 203],
                "plum": [221, 160, 221],
                "powderblue": [176, 224, 230],
                "purple": [128, 0, 128],
                "rebeccapurple": [102, 51, 153],
                "red": [255, 0, 0],
                "rosybrown": [188, 143, 143],
                "royalblue": [65, 105, 225],
                "saddlebrown": [139, 69, 19],
                "salmon": [250, 128, 114],
                "sandybrown": [244, 164, 96],
                "seagreen": [46, 139, 87],
                "seashell": [255, 245, 238],
                "sienna": [160, 82, 45],
                "silver": [192, 192, 192],
                "skyblue": [135, 206, 235],
                "slateblue": [106, 90, 205],
                "slategray": [112, 128, 144],
                "slategrey": [112, 128, 144],
                "snow": [255, 250, 250],
                "springgreen": [0, 255, 127],
                "steelblue": [70, 130, 180],
                "tan": [210, 180, 140],
                "teal": [0, 128, 128],
                "thistle": [216, 191, 216],
                "tomato": [255, 99, 71],
                "turquoise": [64, 224, 208],
                "violet": [238, 130, 238],
                "wheat": [245, 222, 179],
                "white": [255, 255, 255],
                "whitesmoke": [245, 245, 245],
                "yellow": [255, 255, 0],
                "yellowgreen": [154, 205, 50]
            };

            var conversions = createCommonjsModule(function (module) {
                /* MIT license */


                // NOTE: conversions should only return primitive values (i.e. arrays, or
                //       values that give correct `typeof` results).
                //       do not use box values types (i.e. Number(), String(), etc.)

                var reverseKeywords = {};
                for (var key in colorName) {
                    if (colorName.hasOwnProperty(key)) {
                        reverseKeywords[colorName[key]] = key;
                    }
                }

                var convert = module.exports = {
                    rgb: {channels: 3, labels: 'rgb'},
                    hsl: {channels: 3, labels: 'hsl'},
                    hsv: {channels: 3, labels: 'hsv'},
                    hwb: {channels: 3, labels: 'hwb'},
                    cmyk: {channels: 4, labels: 'cmyk'},
                    xyz: {channels: 3, labels: 'xyz'},
                    lab: {channels: 3, labels: 'lab'},
                    lch: {channels: 3, labels: 'lch'},
                    hex: {channels: 1, labels: ['hex']},
                    keyword: {channels: 1, labels: ['keyword']},
                    ansi16: {channels: 1, labels: ['ansi16']},
                    ansi256: {channels: 1, labels: ['ansi256']},
                    hcg: {channels: 3, labels: ['h', 'c', 'g']},
                    apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
                    gray: {channels: 1, labels: ['gray']}
                };

                // hide .channels and .labels properties
                for (var model in convert) {
                    if (convert.hasOwnProperty(model)) {
                        if (!('channels' in convert[model])) {
                            throw new Error('missing channels property: ' + model);
                        }

                        if (!('labels' in convert[model])) {
                            throw new Error('missing channel labels property: ' + model);
                        }

                        if (convert[model].labels.length !== convert[model].channels) {
                            throw new Error('channel and label counts mismatch: ' + model);
                        }

                        var channels = convert[model].channels;
                        var labels = convert[model].labels;
                        delete convert[model].channels;
                        delete convert[model].labels;
                        Object.defineProperty(convert[model], 'channels', {value: channels});
                        Object.defineProperty(convert[model], 'labels', {value: labels});
                    }
                }

                convert.rgb.hsl = function (rgb) {
                    var r = rgb[0] / 255;
                    var g = rgb[1] / 255;
                    var b = rgb[2] / 255;
                    var min = Math.min(r, g, b);
                    var max = Math.max(r, g, b);
                    var delta = max - min;
                    var h;
                    var s;
                    var l;

                    if (max === min) {
                        h = 0;
                    } else if (r === max) {
                        h = (g - b) / delta;
                    } else if (g === max) {
                        h = 2 + (b - r) / delta;
                    } else if (b === max) {
                        h = 4 + (r - g) / delta;
                    }

                    h = Math.min(h * 60, 360);

                    if (h < 0) {
                        h += 360;
                    }

                    l = (min + max) / 2;

                    if (max === min) {
                        s = 0;
                    } else if (l <= 0.5) {
                        s = delta / (max + min);
                    } else {
                        s = delta / (2 - max - min);
                    }

                    return [h, s * 100, l * 100];
                };

                convert.rgb.hsv = function (rgb) {
                    var rdif;
                    var gdif;
                    var bdif;
                    var h;
                    var s;

                    var r = rgb[0] / 255;
                    var g = rgb[1] / 255;
                    var b = rgb[2] / 255;
                    var v = Math.max(r, g, b);
                    var diff = v - Math.min(r, g, b);
                    var diffc = function (c) {
                        return (v - c) / 6 / diff + 1 / 2;
                    };

                    if (diff === 0) {
                        h = s = 0;
                    } else {
                        s = diff / v;
                        rdif = diffc(r);
                        gdif = diffc(g);
                        bdif = diffc(b);

                        if (r === v) {
                            h = bdif - gdif;
                        } else if (g === v) {
                            h = (1 / 3) + rdif - bdif;
                        } else if (b === v) {
                            h = (2 / 3) + gdif - rdif;
                        }
                        if (h < 0) {
                            h += 1;
                        } else if (h > 1) {
                            h -= 1;
                        }
                    }

                    return [
                        h * 360,
                        s * 100,
                        v * 100
                    ];
                };

                convert.rgb.hwb = function (rgb) {
                    var r = rgb[0];
                    var g = rgb[1];
                    var b = rgb[2];
                    var h = convert.rgb.hsl(rgb)[0];
                    var w = 1 / 255 * Math.min(r, Math.min(g, b));

                    b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

                    return [h, w * 100, b * 100];
                };

                convert.rgb.cmyk = function (rgb) {
                    var r = rgb[0] / 255;
                    var g = rgb[1] / 255;
                    var b = rgb[2] / 255;
                    var c;
                    var m;
                    var y;
                    var k;

                    k = Math.min(1 - r, 1 - g, 1 - b);
                    c = (1 - r - k) / (1 - k) || 0;
                    m = (1 - g - k) / (1 - k) || 0;
                    y = (1 - b - k) / (1 - k) || 0;

                    return [c * 100, m * 100, y * 100, k * 100];
                };

                /**
                 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
                 * */
                function comparativeDistance(x, y) {
                    return (
                        Math.pow(x[0] - y[0], 2) +
                        Math.pow(x[1] - y[1], 2) +
                        Math.pow(x[2] - y[2], 2)
                    );
                }

                convert.rgb.keyword = function (rgb) {
                    var reversed = reverseKeywords[rgb];
                    if (reversed) {
                        return reversed;
                    }

                    var currentClosestDistance = Infinity;
                    var currentClosestKeyword;

                    for (var keyword in colorName) {
                        if (colorName.hasOwnProperty(keyword)) {
                            var value = colorName[keyword];

                            // Compute comparative distance
                            var distance = comparativeDistance(rgb, value);

                            // Check if its less, if so set as closest
                            if (distance < currentClosestDistance) {
                                currentClosestDistance = distance;
                                currentClosestKeyword = keyword;
                            }
                        }
                    }

                    return currentClosestKeyword;
                };

                convert.keyword.rgb = function (keyword) {
                    return colorName[keyword];
                };

                convert.rgb.xyz = function (rgb) {
                    var r = rgb[0] / 255;
                    var g = rgb[1] / 255;
                    var b = rgb[2] / 255;

                    // assume sRGB
                    r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
                    g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
                    b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

                    var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
                    var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
                    var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

                    return [x * 100, y * 100, z * 100];
                };

                convert.rgb.lab = function (rgb) {
                    var xyz = convert.rgb.xyz(rgb);
                    var x = xyz[0];
                    var y = xyz[1];
                    var z = xyz[2];
                    var l;
                    var a;
                    var b;

                    x /= 95.047;
                    y /= 100;
                    z /= 108.883;

                    x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
                    y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
                    z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

                    l = (116 * y) - 16;
                    a = 500 * (x - y);
                    b = 200 * (y - z);

                    return [l, a, b];
                };

                convert.hsl.rgb = function (hsl) {
                    var h = hsl[0] / 360;
                    var s = hsl[1] / 100;
                    var l = hsl[2] / 100;
                    var t1;
                    var t2;
                    var t3;
                    var rgb;
                    var val;

                    if (s === 0) {
                        val = l * 255;
                        return [val, val, val];
                    }

                    if (l < 0.5) {
                        t2 = l * (1 + s);
                    } else {
                        t2 = l + s - l * s;
                    }

                    t1 = 2 * l - t2;

                    rgb = [0, 0, 0];
                    for (var i = 0; i < 3; i++) {
                        t3 = h + 1 / 3 * -(i - 1);
                        if (t3 < 0) {
                            t3++;
                        }
                        if (t3 > 1) {
                            t3--;
                        }

                        if (6 * t3 < 1) {
                            val = t1 + (t2 - t1) * 6 * t3;
                        } else if (2 * t3 < 1) {
                            val = t2;
                        } else if (3 * t3 < 2) {
                            val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
                        } else {
                            val = t1;
                        }

                        rgb[i] = val * 255;
                    }

                    return rgb;
                };

                convert.hsl.hsv = function (hsl) {
                    var h = hsl[0];
                    var s = hsl[1] / 100;
                    var l = hsl[2] / 100;
                    var smin = s;
                    var lmin = Math.max(l, 0.01);
                    var sv;
                    var v;

                    l *= 2;
                    s *= (l <= 1) ? l : 2 - l;
                    smin *= lmin <= 1 ? lmin : 2 - lmin;
                    v = (l + s) / 2;
                    sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

                    return [h, sv * 100, v * 100];
                };

                convert.hsv.rgb = function (hsv) {
                    var h = hsv[0] / 60;
                    var s = hsv[1] / 100;
                    var v = hsv[2] / 100;
                    var hi = Math.floor(h) % 6;

                    var f = h - Math.floor(h);
                    var p = 255 * v * (1 - s);
                    var q = 255 * v * (1 - (s * f));
                    var t = 255 * v * (1 - (s * (1 - f)));
                    v *= 255;

                    switch (hi) {
                        case 0:
                            return [v, t, p];
                        case 1:
                            return [q, v, p];
                        case 2:
                            return [p, v, t];
                        case 3:
                            return [p, q, v];
                        case 4:
                            return [t, p, v];
                        case 5:
                            return [v, p, q];
                    }
                };

                convert.hsv.hsl = function (hsv) {
                    var h = hsv[0];
                    var s = hsv[1] / 100;
                    var v = hsv[2] / 100;
                    var vmin = Math.max(v, 0.01);
                    var lmin;
                    var sl;
                    var l;

                    l = (2 - s) * v;
                    lmin = (2 - s) * vmin;
                    sl = s * vmin;
                    sl /= (lmin <= 1) ? lmin : 2 - lmin;
                    sl = sl || 0;
                    l /= 2;

                    return [h, sl * 100, l * 100];
                };

                // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
                convert.hwb.rgb = function (hwb) {
                    var h = hwb[0] / 360;
                    var wh = hwb[1] / 100;
                    var bl = hwb[2] / 100;
                    var ratio = wh + bl;
                    var i;
                    var v;
                    var f;
                    var n;

                    // wh + bl cant be > 1
                    if (ratio > 1) {
                        wh /= ratio;
                        bl /= ratio;
                    }

                    i = Math.floor(6 * h);
                    v = 1 - bl;
                    f = 6 * h - i;

                    if ((i & 0x01) !== 0) {
                        f = 1 - f;
                    }

                    n = wh + f * (v - wh); // linear interpolation

                    var r;
                    var g;
                    var b;
                    switch (i) {
                        default:
                        case 6:
                        case 0: r = v; g = n; b = wh; break;
                        case 1: r = n; g = v; b = wh; break;
                        case 2: r = wh; g = v; b = n; break;
                        case 3: r = wh; g = n; b = v; break;
                        case 4: r = n; g = wh; b = v; break;
                        case 5: r = v; g = wh; b = n; break;
                    }

                    return [r * 255, g * 255, b * 255];
                };

                convert.cmyk.rgb = function (cmyk) {
                    var c = cmyk[0] / 100;
                    var m = cmyk[1] / 100;
                    var y = cmyk[2] / 100;
                    var k = cmyk[3] / 100;
                    var r;
                    var g;
                    var b;

                    r = 1 - Math.min(1, c * (1 - k) + k);
                    g = 1 - Math.min(1, m * (1 - k) + k);
                    b = 1 - Math.min(1, y * (1 - k) + k);

                    return [r * 255, g * 255, b * 255];
                };

                convert.xyz.rgb = function (xyz) {
                    var x = xyz[0] / 100;
                    var y = xyz[1] / 100;
                    var z = xyz[2] / 100;
                    var r;
                    var g;
                    var b;

                    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
                    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
                    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

                    // assume sRGB
                    r = r > 0.0031308
                        ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
                        : r * 12.92;

                    g = g > 0.0031308
                        ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
                        : g * 12.92;

                    b = b > 0.0031308
                        ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
                        : b * 12.92;

                    r = Math.min(Math.max(0, r), 1);
                    g = Math.min(Math.max(0, g), 1);
                    b = Math.min(Math.max(0, b), 1);

                    return [r * 255, g * 255, b * 255];
                };

                convert.xyz.lab = function (xyz) {
                    var x = xyz[0];
                    var y = xyz[1];
                    var z = xyz[2];
                    var l;
                    var a;
                    var b;

                    x /= 95.047;
                    y /= 100;
                    z /= 108.883;

                    x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
                    y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
                    z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

                    l = (116 * y) - 16;
                    a = 500 * (x - y);
                    b = 200 * (y - z);

                    return [l, a, b];
                };

                convert.lab.xyz = function (lab) {
                    var l = lab[0];
                    var a = lab[1];
                    var b = lab[2];
                    var x;
                    var y;
                    var z;

                    y = (l + 16) / 116;
                    x = a / 500 + y;
                    z = y - b / 200;

                    var y2 = Math.pow(y, 3);
                    var x2 = Math.pow(x, 3);
                    var z2 = Math.pow(z, 3);
                    y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
                    x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
                    z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

                    x *= 95.047;
                    y *= 100;
                    z *= 108.883;

                    return [x, y, z];
                };

                convert.lab.lch = function (lab) {
                    var l = lab[0];
                    var a = lab[1];
                    var b = lab[2];
                    var hr;
                    var h;
                    var c;

                    hr = Math.atan2(b, a);
                    h = hr * 360 / 2 / Math.PI;

                    if (h < 0) {
                        h += 360;
                    }

                    c = Math.sqrt(a * a + b * b);

                    return [l, c, h];
                };

                convert.lch.lab = function (lch) {
                    var l = lch[0];
                    var c = lch[1];
                    var h = lch[2];
                    var a;
                    var b;
                    var hr;

                    hr = h / 360 * 2 * Math.PI;
                    a = c * Math.cos(hr);
                    b = c * Math.sin(hr);

                    return [l, a, b];
                };

                convert.rgb.ansi16 = function (args) {
                    var r = args[0];
                    var g = args[1];
                    var b = args[2];
                    var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

                    value = Math.round(value / 50);

                    if (value === 0) {
                        return 30;
                    }

                    var ansi = 30
                        + ((Math.round(b / 255) << 2)
                            | (Math.round(g / 255) << 1)
                            | Math.round(r / 255));

                    if (value === 2) {
                        ansi += 60;
                    }

                    return ansi;
                };

                convert.hsv.ansi16 = function (args) {
                    // optimization here; we already know the value and don't need to get
                    // it converted for us.
                    return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
                };

                convert.rgb.ansi256 = function (args) {
                    var r = args[0];
                    var g = args[1];
                    var b = args[2];

                    // we use the extended greyscale palette here, with the exception of
                    // black and white. normal palette only has 4 greyscale shades.
                    if (r === g && g === b) {
                        if (r < 8) {
                            return 16;
                        }

                        if (r > 248) {
                            return 231;
                        }

                        return Math.round(((r - 8) / 247) * 24) + 232;
                    }

                    var ansi = 16
                        + (36 * Math.round(r / 255 * 5))
                        + (6 * Math.round(g / 255 * 5))
                        + Math.round(b / 255 * 5);

                    return ansi;
                };

                convert.ansi16.rgb = function (args) {
                    var color = args % 10;

                    // handle greyscale
                    if (color === 0 || color === 7) {
                        if (args > 50) {
                            color += 3.5;
                        }

                        color = color / 10.5 * 255;

                        return [color, color, color];
                    }

                    var mult = (~~(args > 50) + 1) * 0.5;
                    var r = ((color & 1) * mult) * 255;
                    var g = (((color >> 1) & 1) * mult) * 255;
                    var b = (((color >> 2) & 1) * mult) * 255;

                    return [r, g, b];
                };

                convert.ansi256.rgb = function (args) {
                    // handle greyscale
                    if (args >= 232) {
                        var c = (args - 232) * 10 + 8;
                        return [c, c, c];
                    }

                    args -= 16;

                    var rem;
                    var r = Math.floor(args / 36) / 5 * 255;
                    var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
                    var b = (rem % 6) / 5 * 255;

                    return [r, g, b];
                };

                convert.rgb.hex = function (args) {
                    var integer = ((Math.round(args[0]) & 0xFF) << 16)
                        + ((Math.round(args[1]) & 0xFF) << 8)
                        + (Math.round(args[2]) & 0xFF);

                    var string = integer.toString(16).toUpperCase();
                    return '000000'.substring(string.length) + string;
                };

                convert.hex.rgb = function (args) {
                    var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
                    if (!match) {
                        return [0, 0, 0];
                    }

                    var colorString = match[0];

                    if (match[0].length === 3) {
                        colorString = colorString.split('').map(function (char) {
                            return char + char;
                        }).join('');
                    }

                    var integer = parseInt(colorString, 16);
                    var r = (integer >> 16) & 0xFF;
                    var g = (integer >> 8) & 0xFF;
                    var b = integer & 0xFF;

                    return [r, g, b];
                };

                convert.rgb.hcg = function (rgb) {
                    var r = rgb[0] / 255;
                    var g = rgb[1] / 255;
                    var b = rgb[2] / 255;
                    var max = Math.max(Math.max(r, g), b);
                    var min = Math.min(Math.min(r, g), b);
                    var chroma = (max - min);
                    var grayscale;
                    var hue;

                    if (chroma < 1) {
                        grayscale = min / (1 - chroma);
                    } else {
                        grayscale = 0;
                    }

                    if (chroma <= 0) {
                        hue = 0;
                    } else
                    if (max === r) {
                        hue = ((g - b) / chroma) % 6;
                    } else
                    if (max === g) {
                        hue = 2 + (b - r) / chroma;
                    } else {
                        hue = 4 + (r - g) / chroma + 4;
                    }

                    hue /= 6;
                    hue %= 1;

                    return [hue * 360, chroma * 100, grayscale * 100];
                };

                convert.hsl.hcg = function (hsl) {
                    var s = hsl[1] / 100;
                    var l = hsl[2] / 100;
                    var c = 1;
                    var f = 0;

                    if (l < 0.5) {
                        c = 2.0 * s * l;
                    } else {
                        c = 2.0 * s * (1.0 - l);
                    }

                    if (c < 1.0) {
                        f = (l - 0.5 * c) / (1.0 - c);
                    }

                    return [hsl[0], c * 100, f * 100];
                };

                convert.hsv.hcg = function (hsv) {
                    var s = hsv[1] / 100;
                    var v = hsv[2] / 100;

                    var c = s * v;
                    var f = 0;

                    if (c < 1.0) {
                        f = (v - c) / (1 - c);
                    }

                    return [hsv[0], c * 100, f * 100];
                };

                convert.hcg.rgb = function (hcg) {
                    var h = hcg[0] / 360;
                    var c = hcg[1] / 100;
                    var g = hcg[2] / 100;

                    if (c === 0.0) {
                        return [g * 255, g * 255, g * 255];
                    }

                    var pure = [0, 0, 0];
                    var hi = (h % 1) * 6;
                    var v = hi % 1;
                    var w = 1 - v;
                    var mg = 0;

                    switch (Math.floor(hi)) {
                        case 0:
                            pure[0] = 1; pure[1] = v; pure[2] = 0; break;
                        case 1:
                            pure[0] = w; pure[1] = 1; pure[2] = 0; break;
                        case 2:
                            pure[0] = 0; pure[1] = 1; pure[2] = v; break;
                        case 3:
                            pure[0] = 0; pure[1] = w; pure[2] = 1; break;
                        case 4:
                            pure[0] = v; pure[1] = 0; pure[2] = 1; break;
                        default:
                            pure[0] = 1; pure[1] = 0; pure[2] = w;
                    }

                    mg = (1.0 - c) * g;

                    return [
                        (c * pure[0] + mg) * 255,
                        (c * pure[1] + mg) * 255,
                        (c * pure[2] + mg) * 255
                    ];
                };

                convert.hcg.hsv = function (hcg) {
                    var c = hcg[1] / 100;
                    var g = hcg[2] / 100;

                    var v = c + g * (1.0 - c);
                    var f = 0;

                    if (v > 0.0) {
                        f = c / v;
                    }

                    return [hcg[0], f * 100, v * 100];
                };

                convert.hcg.hsl = function (hcg) {
                    var c = hcg[1] / 100;
                    var g = hcg[2] / 100;

                    var l = g * (1.0 - c) + 0.5 * c;
                    var s = 0;

                    if (l > 0.0 && l < 0.5) {
                        s = c / (2 * l);
                    } else
                    if (l >= 0.5 && l < 1.0) {
                        s = c / (2 * (1 - l));
                    }

                    return [hcg[0], s * 100, l * 100];
                };

                convert.hcg.hwb = function (hcg) {
                    var c = hcg[1] / 100;
                    var g = hcg[2] / 100;
                    var v = c + g * (1.0 - c);
                    return [hcg[0], (v - c) * 100, (1 - v) * 100];
                };

                convert.hwb.hcg = function (hwb) {
                    var w = hwb[1] / 100;
                    var b = hwb[2] / 100;
                    var v = 1 - b;
                    var c = v - w;
                    var g = 0;

                    if (c < 1) {
                        g = (v - c) / (1 - c);
                    }

                    return [hwb[0], c * 100, g * 100];
                };

                convert.apple.rgb = function (apple) {
                    return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
                };

                convert.rgb.apple = function (rgb) {
                    return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
                };

                convert.gray.rgb = function (args) {
                    return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
                };

                convert.gray.hsl = convert.gray.hsv = function (args) {
                    return [0, 0, args[0]];
                };

                convert.gray.hwb = function (gray) {
                    return [0, 100, gray[0]];
                };

                convert.gray.cmyk = function (gray) {
                    return [0, 0, 0, gray[0]];
                };

                convert.gray.lab = function (gray) {
                    return [gray[0], 0, 0];
                };

                convert.gray.hex = function (gray) {
                    var val = Math.round(gray[0] / 100 * 255) & 0xFF;
                    var integer = (val << 16) + (val << 8) + val;

                    var string = integer.toString(16).toUpperCase();
                    return '000000'.substring(string.length) + string;
                };

                convert.rgb.gray = function (rgb) {
                    var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
                    return [val / 255 * 100];
                };
            });
            var conversions_1 = conversions.rgb;
            var conversions_2 = conversions.hsl;
            var conversions_3 = conversions.hsv;
            var conversions_4 = conversions.hwb;
            var conversions_5 = conversions.cmyk;
            var conversions_6 = conversions.xyz;
            var conversions_7 = conversions.lab;
            var conversions_8 = conversions.lch;
            var conversions_9 = conversions.hex;
            var conversions_10 = conversions.keyword;
            var conversions_11 = conversions.ansi16;
            var conversions_12 = conversions.ansi256;
            var conversions_13 = conversions.hcg;
            var conversions_14 = conversions.apple;
            var conversions_15 = conversions.gray;

            /*
		this function routes a model to all other models.

		all functions that are routed have a property `.conversion` attached
		to the returned synthetic function. This property is an array
		of strings, each with the steps in between the 'from' and 'to'
		color models (inclusive).

		conversions that are not possible simply are not included.
	*/

            function buildGraph() {
                var graph = {};
                // https://jsperf.com/object-keys-vs-for-in-with-closure/3
                var models = Object.keys(conversions);

                for (var len = models.length, i = 0; i < len; i++) {
                    graph[models[i]] = {
                        // http://jsperf.com/1-vs-infinity
                        // micro-opt, but this is simple.
                        distance: -1,
                        parent: null
                    };
                }

                return graph;
            }

            // https://en.wikipedia.org/wiki/Breadth-first_search
            function deriveBFS(fromModel) {
                var graph = buildGraph();
                var queue = [fromModel]; // unshift -> queue -> pop

                graph[fromModel].distance = 0;

                while (queue.length) {
                    var current = queue.pop();
                    var adjacents = Object.keys(conversions[current]);

                    for (var len = adjacents.length, i = 0; i < len; i++) {
                        var adjacent = adjacents[i];
                        var node = graph[adjacent];

                        if (node.distance === -1) {
                            node.distance = graph[current].distance + 1;
                            node.parent = current;
                            queue.unshift(adjacent);
                        }
                    }
                }

                return graph;
            }

            function link(from, to) {
                return function (args) {
                    return to(from(args));
                };
            }

            function wrapConversion(toModel, graph) {
                var path = [graph[toModel].parent, toModel];
                var fn = conversions[graph[toModel].parent][toModel];

                var cur = graph[toModel].parent;
                while (graph[cur].parent) {
                    path.unshift(graph[cur].parent);
                    fn = link(conversions[graph[cur].parent][cur], fn);
                    cur = graph[cur].parent;
                }

                fn.conversion = path;
                return fn;
            }

            var route = function (fromModel) {
                var graph = deriveBFS(fromModel);
                var conversion = {};

                var models = Object.keys(graph);
                for (var len = models.length, i = 0; i < len; i++) {
                    var toModel = models[i];
                    var node = graph[toModel];

                    if (node.parent === null) {
                        // no possible conversion, or this node is the source model.
                        continue;
                    }

                    conversion[toModel] = wrapConversion(toModel, graph);
                }

                return conversion;
            };

            var convert = {};

            var models = Object.keys(conversions);

            function wrapRaw(fn) {
                var wrappedFn = function (args) {
                    if (args === undefined || args === null) {
                        return args;
                    }

                    if (arguments.length > 1) {
                        args = Array.prototype.slice.call(arguments);
                    }

                    return fn(args);
                };

                // preserve .conversion property if there is one
                if ('conversion' in fn) {
                    wrappedFn.conversion = fn.conversion;
                }

                return wrappedFn;
            }

            function wrapRounded(fn) {
                var wrappedFn = function (args) {
                    if (args === undefined || args === null) {
                        return args;
                    }

                    if (arguments.length > 1) {
                        args = Array.prototype.slice.call(arguments);
                    }

                    var result = fn(args);

                    // we're assuming the result is an array here.
                    // see notice in conversions.js; don't use box types
                    // in conversion functions.
                    if (typeof result === 'object') {
                        for (var len = result.length, i = 0; i < len; i++) {
                            result[i] = Math.round(result[i]);
                        }
                    }

                    return result;
                };

                // preserve .conversion property if there is one
                if ('conversion' in fn) {
                    wrappedFn.conversion = fn.conversion;
                }

                return wrappedFn;
            }

            models.forEach(function (fromModel) {
                convert[fromModel] = {};

                Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
                Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

                var routes = route(fromModel);
                var routeModels = Object.keys(routes);

                routeModels.forEach(function (toModel) {
                    var fn = routes[toModel];

                    convert[fromModel][toModel] = wrapRounded(fn);
                    convert[fromModel][toModel].raw = wrapRaw(fn);
                });
            });

            var colorConvert = convert;

            var colorName$1 = {
                "aliceblue": [240, 248, 255],
                "antiquewhite": [250, 235, 215],
                "aqua": [0, 255, 255],
                "aquamarine": [127, 255, 212],
                "azure": [240, 255, 255],
                "beige": [245, 245, 220],
                "bisque": [255, 228, 196],
                "black": [0, 0, 0],
                "blanchedalmond": [255, 235, 205],
                "blue": [0, 0, 255],
                "blueviolet": [138, 43, 226],
                "brown": [165, 42, 42],
                "burlywood": [222, 184, 135],
                "cadetblue": [95, 158, 160],
                "chartreuse": [127, 255, 0],
                "chocolate": [210, 105, 30],
                "coral": [255, 127, 80],
                "cornflowerblue": [100, 149, 237],
                "cornsilk": [255, 248, 220],
                "crimson": [220, 20, 60],
                "cyan": [0, 255, 255],
                "darkblue": [0, 0, 139],
                "darkcyan": [0, 139, 139],
                "darkgoldenrod": [184, 134, 11],
                "darkgray": [169, 169, 169],
                "darkgreen": [0, 100, 0],
                "darkgrey": [169, 169, 169],
                "darkkhaki": [189, 183, 107],
                "darkmagenta": [139, 0, 139],
                "darkolivegreen": [85, 107, 47],
                "darkorange": [255, 140, 0],
                "darkorchid": [153, 50, 204],
                "darkred": [139, 0, 0],
                "darksalmon": [233, 150, 122],
                "darkseagreen": [143, 188, 143],
                "darkslateblue": [72, 61, 139],
                "darkslategray": [47, 79, 79],
                "darkslategrey": [47, 79, 79],
                "darkturquoise": [0, 206, 209],
                "darkviolet": [148, 0, 211],
                "deeppink": [255, 20, 147],
                "deepskyblue": [0, 191, 255],
                "dimgray": [105, 105, 105],
                "dimgrey": [105, 105, 105],
                "dodgerblue": [30, 144, 255],
                "firebrick": [178, 34, 34],
                "floralwhite": [255, 250, 240],
                "forestgreen": [34, 139, 34],
                "fuchsia": [255, 0, 255],
                "gainsboro": [220, 220, 220],
                "ghostwhite": [248, 248, 255],
                "gold": [255, 215, 0],
                "goldenrod": [218, 165, 32],
                "gray": [128, 128, 128],
                "green": [0, 128, 0],
                "greenyellow": [173, 255, 47],
                "grey": [128, 128, 128],
                "honeydew": [240, 255, 240],
                "hotpink": [255, 105, 180],
                "indianred": [205, 92, 92],
                "indigo": [75, 0, 130],
                "ivory": [255, 255, 240],
                "khaki": [240, 230, 140],
                "lavender": [230, 230, 250],
                "lavenderblush": [255, 240, 245],
                "lawngreen": [124, 252, 0],
                "lemonchiffon": [255, 250, 205],
                "lightblue": [173, 216, 230],
                "lightcoral": [240, 128, 128],
                "lightcyan": [224, 255, 255],
                "lightgoldenrodyellow": [250, 250, 210],
                "lightgray": [211, 211, 211],
                "lightgreen": [144, 238, 144],
                "lightgrey": [211, 211, 211],
                "lightpink": [255, 182, 193],
                "lightsalmon": [255, 160, 122],
                "lightseagreen": [32, 178, 170],
                "lightskyblue": [135, 206, 250],
                "lightslategray": [119, 136, 153],
                "lightslategrey": [119, 136, 153],
                "lightsteelblue": [176, 196, 222],
                "lightyellow": [255, 255, 224],
                "lime": [0, 255, 0],
                "limegreen": [50, 205, 50],
                "linen": [250, 240, 230],
                "magenta": [255, 0, 255],
                "maroon": [128, 0, 0],
                "mediumaquamarine": [102, 205, 170],
                "mediumblue": [0, 0, 205],
                "mediumorchid": [186, 85, 211],
                "mediumpurple": [147, 112, 219],
                "mediumseagreen": [60, 179, 113],
                "mediumslateblue": [123, 104, 238],
                "mediumspringgreen": [0, 250, 154],
                "mediumturquoise": [72, 209, 204],
                "mediumvioletred": [199, 21, 133],
                "midnightblue": [25, 25, 112],
                "mintcream": [245, 255, 250],
                "mistyrose": [255, 228, 225],
                "moccasin": [255, 228, 181],
                "navajowhite": [255, 222, 173],
                "navy": [0, 0, 128],
                "oldlace": [253, 245, 230],
                "olive": [128, 128, 0],
                "olivedrab": [107, 142, 35],
                "orange": [255, 165, 0],
                "orangered": [255, 69, 0],
                "orchid": [218, 112, 214],
                "palegoldenrod": [238, 232, 170],
                "palegreen": [152, 251, 152],
                "paleturquoise": [175, 238, 238],
                "palevioletred": [219, 112, 147],
                "papayawhip": [255, 239, 213],
                "peachpuff": [255, 218, 185],
                "peru": [205, 133, 63],
                "pink": [255, 192, 203],
                "plum": [221, 160, 221],
                "powderblue": [176, 224, 230],
                "purple": [128, 0, 128],
                "rebeccapurple": [102, 51, 153],
                "red": [255, 0, 0],
                "rosybrown": [188, 143, 143],
                "royalblue": [65, 105, 225],
                "saddlebrown": [139, 69, 19],
                "salmon": [250, 128, 114],
                "sandybrown": [244, 164, 96],
                "seagreen": [46, 139, 87],
                "seashell": [255, 245, 238],
                "sienna": [160, 82, 45],
                "silver": [192, 192, 192],
                "skyblue": [135, 206, 235],
                "slateblue": [106, 90, 205],
                "slategray": [112, 128, 144],
                "slategrey": [112, 128, 144],
                "snow": [255, 250, 250],
                "springgreen": [0, 255, 127],
                "steelblue": [70, 130, 180],
                "tan": [210, 180, 140],
                "teal": [0, 128, 128],
                "thistle": [216, 191, 216],
                "tomato": [255, 99, 71],
                "turquoise": [64, 224, 208],
                "violet": [238, 130, 238],
                "wheat": [245, 222, 179],
                "white": [255, 255, 255],
                "whitesmoke": [245, 245, 245],
                "yellow": [255, 255, 0],
                "yellowgreen": [154, 205, 50]
            };

            /* MIT license */


            var colorString = {
                getRgba: getRgba,
                getHsla: getHsla,
                getRgb: getRgb,
                getHsl: getHsl,
                getHwb: getHwb,
                getAlpha: getAlpha,

                hexString: hexString,
                rgbString: rgbString,
                rgbaString: rgbaString,
                percentString: percentString,
                percentaString: percentaString,
                hslString: hslString,
                hslaString: hslaString,
                hwbString: hwbString,
                keyword: keyword
            };

            function getRgba(string) {
                if (!string) {
                    return;
                }
                var abbr =  /^#([a-fA-F0-9]{3,4})$/i,
                    hex =  /^#([a-fA-F0-9]{6}([a-fA-F0-9]{2})?)$/i,
                    rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
                    per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/i,
                    keyword = /(\w+)/;

                var rgb = [0, 0, 0],
                    a = 1,
                    match = string.match(abbr),
                    hexAlpha = "";
                if (match) {
                    match = match[1];
                    hexAlpha = match[3];
                    for (var i = 0; i < rgb.length; i++) {
                        rgb[i] = parseInt(match[i] + match[i], 16);
                    }
                    if (hexAlpha) {
                        a = Math.round((parseInt(hexAlpha + hexAlpha, 16) / 255) * 100) / 100;
                    }
                }
                else if (match = string.match(hex)) {
                    hexAlpha = match[2];
                    match = match[1];
                    for (var i = 0; i < rgb.length; i++) {
                        rgb[i] = parseInt(match.slice(i * 2, i * 2 + 2), 16);
                    }
                    if (hexAlpha) {
                        a = Math.round((parseInt(hexAlpha, 16) / 255) * 100) / 100;
                    }
                }
                else if (match = string.match(rgba)) {
                    for (var i = 0; i < rgb.length; i++) {
                        rgb[i] = parseInt(match[i + 1]);
                    }
                    a = parseFloat(match[4]);
                }
                else if (match = string.match(per)) {
                    for (var i = 0; i < rgb.length; i++) {
                        rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
                    }
                    a = parseFloat(match[4]);
                }
                else if (match = string.match(keyword)) {
                    if (match[1] == "transparent") {
                        return [0, 0, 0, 0];
                    }
                    rgb = colorName$1[match[1]];
                    if (!rgb) {
                        return;
                    }
                }

                for (var i = 0; i < rgb.length; i++) {
                    rgb[i] = scale(rgb[i], 0, 255);
                }
                if (!a && a != 0) {
                    a = 1;
                }
                else {
                    a = scale(a, 0, 1);
                }
                rgb[3] = a;
                return rgb;
            }

            function getHsla(string) {
                if (!string) {
                    return;
                }
                var hsl = /^hsla?\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
                var match = string.match(hsl);
                if (match) {
                    var alpha = parseFloat(match[4]);
                    var h = scale(parseInt(match[1]), 0, 360),
                        s = scale(parseFloat(match[2]), 0, 100),
                        l = scale(parseFloat(match[3]), 0, 100),
                        a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
                    return [h, s, l, a];
                }
            }

            function getHwb(string) {
                if (!string) {
                    return;
                }
                var hwb = /^hwb\(\s*([+-]?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)/;
                var match = string.match(hwb);
                if (match) {
                    var alpha = parseFloat(match[4]);
                    var h = scale(parseInt(match[1]), 0, 360),
                        w = scale(parseFloat(match[2]), 0, 100),
                        b = scale(parseFloat(match[3]), 0, 100),
                        a = scale(isNaN(alpha) ? 1 : alpha, 0, 1);
                    return [h, w, b, a];
                }
            }

            function getRgb(string) {
                var rgba = getRgba(string);
                return rgba && rgba.slice(0, 3);
            }

            function getHsl(string) {
                var hsla = getHsla(string);
                return hsla && hsla.slice(0, 3);
            }

            function getAlpha(string) {
                var vals = getRgba(string);
                if (vals) {
                    return vals[3];
                }
                else if (vals = getHsla(string)) {
                    return vals[3];
                }
                else if (vals = getHwb(string)) {
                    return vals[3];
                }
            }

            // generators
            function hexString(rgba, a) {
                var a = (a !== undefined && rgba.length === 3) ? a : rgba[3];
                return "#" + hexDouble(rgba[0])
                    + hexDouble(rgba[1])
                    + hexDouble(rgba[2])
                    + (
                        (a >= 0 && a < 1)
                            ? hexDouble(Math.round(a * 255))
                            : ""
                    );
            }

            function rgbString(rgba, alpha) {
                if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
                    return rgbaString(rgba, alpha);
                }
                return "rgb(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2] + ")";
            }

            function rgbaString(rgba, alpha) {
                if (alpha === undefined) {
                    alpha = (rgba[3] !== undefined ? rgba[3] : 1);
                }
                return "rgba(" + rgba[0] + ", " + rgba[1] + ", " + rgba[2]
                    + ", " + alpha + ")";
            }

            function percentString(rgba, alpha) {
                if (alpha < 1 || (rgba[3] && rgba[3] < 1)) {
                    return percentaString(rgba, alpha);
                }
                var r = Math.round(rgba[0]/255 * 100),
                    g = Math.round(rgba[1]/255 * 100),
                    b = Math.round(rgba[2]/255 * 100);

                return "rgb(" + r + "%, " + g + "%, " + b + "%)";
            }

            function percentaString(rgba, alpha) {
                var r = Math.round(rgba[0]/255 * 100),
                    g = Math.round(rgba[1]/255 * 100),
                    b = Math.round(rgba[2]/255 * 100);
                return "rgba(" + r + "%, " + g + "%, " + b + "%, " + (alpha || rgba[3] || 1) + ")";
            }

            function hslString(hsla, alpha) {
                if (alpha < 1 || (hsla[3] && hsla[3] < 1)) {
                    return hslaString(hsla, alpha);
                }
                return "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)";
            }

            function hslaString(hsla, alpha) {
                if (alpha === undefined) {
                    alpha = (hsla[3] !== undefined ? hsla[3] : 1);
                }
                return "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, "
                    + alpha + ")";
            }

            // hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
            // (hwb have alpha optional & 1 is default value)
            function hwbString(hwb, alpha) {
                if (alpha === undefined) {
                    alpha = (hwb[3] !== undefined ? hwb[3] : 1);
                }
                return "hwb(" + hwb[0] + ", " + hwb[1] + "%, " + hwb[2] + "%"
                    + (alpha !== undefined && alpha !== 1 ? ", " + alpha : "") + ")";
            }

            function keyword(rgb) {
                return reverseNames[rgb.slice(0, 3)];
            }

            // helpers
            function scale(num, min, max) {
                return Math.min(Math.max(min, num), max);
            }

            function hexDouble(num) {
                var str = num.toString(16).toUpperCase();
                return (str.length < 2) ? "0" + str : str;
            }


            //create a list of reverse color names
            var reverseNames = {};
            for (var name in colorName$1) {
                reverseNames[colorName$1[name]] = name;
            }

            /* MIT license */



            var Color = function (obj) {
                if (obj instanceof Color) {
                    return obj;
                }
                if (!(this instanceof Color)) {
                    return new Color(obj);
                }

                this.valid = false;
                this.values = {
                    rgb: [0, 0, 0],
                    hsl: [0, 0, 0],
                    hsv: [0, 0, 0],
                    hwb: [0, 0, 0],
                    cmyk: [0, 0, 0, 0],
                    alpha: 1
                };

                // parse Color() argument
                var vals;
                if (typeof obj === 'string') {
                    vals = colorString.getRgba(obj);
                    if (vals) {
                        this.setValues('rgb', vals);
                    } else if (vals = colorString.getHsla(obj)) {
                        this.setValues('hsl', vals);
                    } else if (vals = colorString.getHwb(obj)) {
                        this.setValues('hwb', vals);
                    }
                } else if (typeof obj === 'object') {
                    vals = obj;
                    if (vals.r !== undefined || vals.red !== undefined) {
                        this.setValues('rgb', vals);
                    } else if (vals.l !== undefined || vals.lightness !== undefined) {
                        this.setValues('hsl', vals);
                    } else if (vals.v !== undefined || vals.value !== undefined) {
                        this.setValues('hsv', vals);
                    } else if (vals.w !== undefined || vals.whiteness !== undefined) {
                        this.setValues('hwb', vals);
                    } else if (vals.c !== undefined || vals.cyan !== undefined) {
                        this.setValues('cmyk', vals);
                    }
                }
            };

            Color.prototype = {
                isValid: function () {
                    return this.valid;
                },
                rgb: function () {
                    return this.setSpace('rgb', arguments);
                },
                hsl: function () {
                    return this.setSpace('hsl', arguments);
                },
                hsv: function () {
                    return this.setSpace('hsv', arguments);
                },
                hwb: function () {
                    return this.setSpace('hwb', arguments);
                },
                cmyk: function () {
                    return this.setSpace('cmyk', arguments);
                },

                rgbArray: function () {
                    return this.values.rgb;
                },
                hslArray: function () {
                    return this.values.hsl;
                },
                hsvArray: function () {
                    return this.values.hsv;
                },
                hwbArray: function () {
                    var values = this.values;
                    if (values.alpha !== 1) {
                        return values.hwb.concat([values.alpha]);
                    }
                    return values.hwb;
                },
                cmykArray: function () {
                    return this.values.cmyk;
                },
                rgbaArray: function () {
                    var values = this.values;
                    return values.rgb.concat([values.alpha]);
                },
                hslaArray: function () {
                    var values = this.values;
                    return values.hsl.concat([values.alpha]);
                },
                alpha: function (val) {
                    if (val === undefined) {
                        return this.values.alpha;
                    }
                    this.setValues('alpha', val);
                    return this;
                },

                red: function (val) {
                    return this.setChannel('rgb', 0, val);
                },
                green: function (val) {
                    return this.setChannel('rgb', 1, val);
                },
                blue: function (val) {
                    return this.setChannel('rgb', 2, val);
                },
                hue: function (val) {
                    if (val) {
                        val %= 360;
                        val = val < 0 ? 360 + val : val;
                    }
                    return this.setChannel('hsl', 0, val);
                },
                saturation: function (val) {
                    return this.setChannel('hsl', 1, val);
                },
                lightness: function (val) {
                    return this.setChannel('hsl', 2, val);
                },
                saturationv: function (val) {
                    return this.setChannel('hsv', 1, val);
                },
                whiteness: function (val) {
                    return this.setChannel('hwb', 1, val);
                },
                blackness: function (val) {
                    return this.setChannel('hwb', 2, val);
                },
                value: function (val) {
                    return this.setChannel('hsv', 2, val);
                },
                cyan: function (val) {
                    return this.setChannel('cmyk', 0, val);
                },
                magenta: function (val) {
                    return this.setChannel('cmyk', 1, val);
                },
                yellow: function (val) {
                    return this.setChannel('cmyk', 2, val);
                },
                black: function (val) {
                    return this.setChannel('cmyk', 3, val);
                },

                hexString: function () {
                    return colorString.hexString(this.values.rgb);
                },
                rgbString: function () {
                    return colorString.rgbString(this.values.rgb, this.values.alpha);
                },
                rgbaString: function () {
                    return colorString.rgbaString(this.values.rgb, this.values.alpha);
                },
                percentString: function () {
                    return colorString.percentString(this.values.rgb, this.values.alpha);
                },
                hslString: function () {
                    return colorString.hslString(this.values.hsl, this.values.alpha);
                },
                hslaString: function () {
                    return colorString.hslaString(this.values.hsl, this.values.alpha);
                },
                hwbString: function () {
                    return colorString.hwbString(this.values.hwb, this.values.alpha);
                },
                keyword: function () {
                    return colorString.keyword(this.values.rgb, this.values.alpha);
                },

                rgbNumber: function () {
                    var rgb = this.values.rgb;
                    return (rgb[0] << 16) | (rgb[1] << 8) | rgb[2];
                },

                luminosity: function () {
                    // http://www.w3.org/TR/WCAG20/#relativeluminancedef
                    var rgb = this.values.rgb;
                    var lum = [];
                    for (var i = 0; i < rgb.length; i++) {
                        var chan = rgb[i] / 255;
                        lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
                    }
                    return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
                },

                contrast: function (color2) {
                    // http://www.w3.org/TR/WCAG20/#contrast-ratiodef
                    var lum1 = this.luminosity();
                    var lum2 = color2.luminosity();
                    if (lum1 > lum2) {
                        return (lum1 + 0.05) / (lum2 + 0.05);
                    }
                    return (lum2 + 0.05) / (lum1 + 0.05);
                },

                level: function (color2) {
                    var contrastRatio = this.contrast(color2);
                    if (contrastRatio >= 7.1) {
                        return 'AAA';
                    }

                    return (contrastRatio >= 4.5) ? 'AA' : '';
                },

                dark: function () {
                    // YIQ equation from http://24ways.org/2010/calculating-color-contrast
                    var rgb = this.values.rgb;
                    var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
                    return yiq < 128;
                },

                light: function () {
                    return !this.dark();
                },

                negate: function () {
                    var rgb = [];
                    for (var i = 0; i < 3; i++) {
                        rgb[i] = 255 - this.values.rgb[i];
                    }
                    this.setValues('rgb', rgb);
                    return this;
                },

                lighten: function (ratio) {
                    var hsl = this.values.hsl;
                    hsl[2] += hsl[2] * ratio;
                    this.setValues('hsl', hsl);
                    return this;
                },

                darken: function (ratio) {
                    var hsl = this.values.hsl;
                    hsl[2] -= hsl[2] * ratio;
                    this.setValues('hsl', hsl);
                    return this;
                },

                saturate: function (ratio) {
                    var hsl = this.values.hsl;
                    hsl[1] += hsl[1] * ratio;
                    this.setValues('hsl', hsl);
                    return this;
                },

                desaturate: function (ratio) {
                    var hsl = this.values.hsl;
                    hsl[1] -= hsl[1] * ratio;
                    this.setValues('hsl', hsl);
                    return this;
                },

                whiten: function (ratio) {
                    var hwb = this.values.hwb;
                    hwb[1] += hwb[1] * ratio;
                    this.setValues('hwb', hwb);
                    return this;
                },

                blacken: function (ratio) {
                    var hwb = this.values.hwb;
                    hwb[2] += hwb[2] * ratio;
                    this.setValues('hwb', hwb);
                    return this;
                },

                greyscale: function () {
                    var rgb = this.values.rgb;
                    // http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
                    var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
                    this.setValues('rgb', [val, val, val]);
                    return this;
                },

                clearer: function (ratio) {
                    var alpha = this.values.alpha;
                    this.setValues('alpha', alpha - (alpha * ratio));
                    return this;
                },

                opaquer: function (ratio) {
                    var alpha = this.values.alpha;
                    this.setValues('alpha', alpha + (alpha * ratio));
                    return this;
                },

                rotate: function (degrees) {
                    var hsl = this.values.hsl;
                    var hue = (hsl[0] + degrees) % 360;
                    hsl[0] = hue < 0 ? 360 + hue : hue;
                    this.setValues('hsl', hsl);
                    return this;
                },

                /**
                 * Ported from sass implementation in C
                 * https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
                 */
                mix: function (mixinColor, weight) {
                    var color1 = this;
                    var color2 = mixinColor;
                    var p = weight === undefined ? 0.5 : weight;

                    var w = 2 * p - 1;
                    var a = color1.alpha() - color2.alpha();

                    var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
                    var w2 = 1 - w1;

                    return this
                        .rgb(
                            w1 * color1.red() + w2 * color2.red(),
                            w1 * color1.green() + w2 * color2.green(),
                            w1 * color1.blue() + w2 * color2.blue()
                        )
                        .alpha(color1.alpha() * p + color2.alpha() * (1 - p));
                },

                toJSON: function () {
                    return this.rgb();
                },

                clone: function () {
                    // NOTE(SB): using node-clone creates a dependency to Buffer when using browserify,
                    // making the final build way to big to embed in Chart.js. So let's do it manually,
                    // assuming that values to clone are 1 dimension arrays containing only numbers,
                    // except 'alpha' which is a number.
                    var result = new Color();
                    var source = this.values;
                    var target = result.values;
                    var value, type;

                    for (var prop in source) {
                        if (source.hasOwnProperty(prop)) {
                            value = source[prop];
                            type = ({}).toString.call(value);
                            if (type === '[object Array]') {
                                target[prop] = value.slice(0);
                            } else if (type === '[object Number]') {
                                target[prop] = value;
                            } else {
                                console.error('unexpected color value:', value);
                            }
                        }
                    }

                    return result;
                }
            };

            Color.prototype.spaces = {
                rgb: ['red', 'green', 'blue'],
                hsl: ['hue', 'saturation', 'lightness'],
                hsv: ['hue', 'saturation', 'value'],
                hwb: ['hue', 'whiteness', 'blackness'],
                cmyk: ['cyan', 'magenta', 'yellow', 'black']
            };

            Color.prototype.maxes = {
                rgb: [255, 255, 255],
                hsl: [360, 100, 100],
                hsv: [360, 100, 100],
                hwb: [360, 100, 100],
                cmyk: [100, 100, 100, 100]
            };

            Color.prototype.getValues = function (space) {
                var values = this.values;
                var vals = {};

                for (var i = 0; i < space.length; i++) {
                    vals[space.charAt(i)] = values[space][i];
                }

                if (values.alpha !== 1) {
                    vals.a = values.alpha;
                }

                // {r: 255, g: 255, b: 255, a: 0.4}
                return vals;
            };

            Color.prototype.setValues = function (space, vals) {
                var values = this.values;
                var spaces = this.spaces;
                var maxes = this.maxes;
                var alpha = 1;
                var i;

                this.valid = true;

                if (space === 'alpha') {
                    alpha = vals;
                } else if (vals.length) {
                    // [10, 10, 10]
                    values[space] = vals.slice(0, space.length);
                    alpha = vals[space.length];
                } else if (vals[space.charAt(0)] !== undefined) {
                    // {r: 10, g: 10, b: 10}
                    for (i = 0; i < space.length; i++) {
                        values[space][i] = vals[space.charAt(i)];
                    }

                    alpha = vals.a;
                } else if (vals[spaces[space][0]] !== undefined) {
                    // {red: 10, green: 10, blue: 10}
                    var chans = spaces[space];

                    for (i = 0; i < space.length; i++) {
                        values[space][i] = vals[chans[i]];
                    }

                    alpha = vals.alpha;
                }

                values.alpha = Math.max(0, Math.min(1, (alpha === undefined ? values.alpha : alpha)));

                if (space === 'alpha') {
                    return false;
                }

                var capped;

                // cap values of the space prior converting all values
                for (i = 0; i < space.length; i++) {
                    capped = Math.max(0, Math.min(maxes[space][i], values[space][i]));
                    values[space][i] = Math.round(capped);
                }

                // convert to all the other color spaces
                for (var sname in spaces) {
                    if (sname !== space) {
                        values[sname] = colorConvert[space][sname](values[space]);
                    }
                }

                return true;
            };

            Color.prototype.setSpace = function (space, args) {
                var vals = args[0];

                if (vals === undefined) {
                    // color.rgb()
                    return this.getValues(space);
                }

                // color.rgb(10, 10, 10)
                if (typeof vals === 'number') {
                    vals = Array.prototype.slice.call(args);
                }

                this.setValues(space, vals);
                return this;
            };

            Color.prototype.setChannel = function (space, index, val) {
                var svalues = this.values[space];
                if (val === undefined) {
                    // color.red()
                    return svalues[index];
                } else if (val === svalues[index]) {
                    // color.red(color.red())
                    return this;
                }

                // color.red(100)
                svalues[index] = val;
                this.setValues(space, svalues);

                return this;
            };

            if (typeof window !== 'undefined') {
                window.Color = Color;
            }

            var chartjsColor = Color;

            /**
             * @namespace Chart.helpers
             */
            var helpers = {
                /**
                 * An empty function that can be used, for example, for optional callback.
                 */
                noop: function() {},

                /**
                 * Returns a unique id, sequentially generated from a global variable.
                 * @returns {number}
                 * @function
                 */
                uid: (function() {
                    var id = 0;
                    return function() {
                        return id++;
                    };
                }()),

                /**
                 * Returns true if `value` is neither null nor undefined, else returns false.
                 * @param {*} value - The value to test.
                 * @returns {boolean}
                 * @since 2.7.0
                 */
                isNullOrUndef: function(value) {
                    return value === null || typeof value === 'undefined';
                },

                /**
                 * Returns true if `value` is an array (including typed arrays), else returns false.
                 * @param {*} value - The value to test.
                 * @returns {boolean}
                 * @function
                 */
                isArray: function(value) {
                    if (Array.isArray && Array.isArray(value)) {
                        return true;
                    }
                    var type = Object.prototype.toString.call(value);
                    if (type.substr(0, 7) === '[object' && type.substr(-6) === 'Array]') {
                        return true;
                    }
                    return false;
                },

                /**
                 * Returns true if `value` is an object (excluding null), else returns false.
                 * @param {*} value - The value to test.
                 * @returns {boolean}
                 * @since 2.7.0
                 */
                isObject: function(value) {
                    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
                },

                /**
                 * Returns true if `value` is a finite number, else returns false
                 * @param {*} value  - The value to test.
                 * @returns {boolean}
                 */
                isFinite: function(value) {
                    return (typeof value === 'number' || value instanceof Number) && isFinite(value);
                },

                /**
                 * Returns `value` if defined, else returns `defaultValue`.
                 * @param {*} value - The value to return if defined.
                 * @param {*} defaultValue - The value to return if `value` is undefined.
                 * @returns {*}
                 */
                valueOrDefault: function(value, defaultValue) {
                    return typeof value === 'undefined' ? defaultValue : value;
                },

                /**
                 * Returns value at the given `index` in array if defined, else returns `defaultValue`.
                 * @param {Array} value - The array to lookup for value at `index`.
                 * @param {number} index - The index in `value` to lookup for value.
                 * @param {*} defaultValue - The value to return if `value[index]` is undefined.
                 * @returns {*}
                 */
                valueAtIndexOrDefault: function(value, index, defaultValue) {
                    return helpers.valueOrDefault(helpers.isArray(value) ? value[index] : value, defaultValue);
                },

                /**
                 * Calls `fn` with the given `args` in the scope defined by `thisArg` and returns the
                 * value returned by `fn`. If `fn` is not a function, this method returns undefined.
                 * @param {function} fn - The function to call.
                 * @param {Array|undefined|null} args - The arguments with which `fn` should be called.
                 * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
                 * @returns {*}
                 */
                callback: function(fn, args, thisArg) {
                    if (fn && typeof fn.call === 'function') {
                        return fn.apply(thisArg, args);
                    }
                },

                /**
                 * Note(SB) for performance sake, this method should only be used when loopable type
                 * is unknown or in none intensive code (not called often and small loopable). Else
                 * it's preferable to use a regular for() loop and save extra function calls.
                 * @param {object|Array} loopable - The object or array to be iterated.
                 * @param {function} fn - The function to call for each item.
                 * @param {object} [thisArg] - The value of `this` provided for the call to `fn`.
                 * @param {boolean} [reverse] - If true, iterates backward on the loopable.
                 */
                each: function(loopable, fn, thisArg, reverse) {
                    var i, len, keys;
                    if (helpers.isArray(loopable)) {
                        len = loopable.length;
                        if (reverse) {
                            for (i = len - 1; i >= 0; i--) {
                                fn.call(thisArg, loopable[i], i);
                            }
                        } else {
                            for (i = 0; i < len; i++) {
                                fn.call(thisArg, loopable[i], i);
                            }
                        }
                    } else if (helpers.isObject(loopable)) {
                        keys = Object.keys(loopable);
                        len = keys.length;
                        for (i = 0; i < len; i++) {
                            fn.call(thisArg, loopable[keys[i]], keys[i]);
                        }
                    }
                },

                /**
                 * Returns true if the `a0` and `a1` arrays have the same content, else returns false.
                 * @see https://stackoverflow.com/a/14853974
                 * @param {Array} a0 - The array to compare
                 * @param {Array} a1 - The array to compare
                 * @returns {boolean}
                 */
                arrayEquals: function(a0, a1) {
                    var i, ilen, v0, v1;

                    if (!a0 || !a1 || a0.length !== a1.length) {
                        return false;
                    }

                    for (i = 0, ilen = a0.length; i < ilen; ++i) {
                        v0 = a0[i];
                        v1 = a1[i];

                        if (v0 instanceof Array && v1 instanceof Array) {
                            if (!helpers.arrayEquals(v0, v1)) {
                                return false;
                            }
                        } else if (v0 !== v1) {
                            // NOTE: two different object instances will never be equal: {x:20} != {x:20}
                            return false;
                        }
                    }

                    return true;
                },

                /**
                 * Returns a deep copy of `source` without keeping references on objects and arrays.
                 * @param {*} source - The value to clone.
                 * @returns {*}
                 */
                clone: function(source) {
                    if (helpers.isArray(source)) {
                        return source.map(helpers.clone);
                    }

                    if (helpers.isObject(source)) {
                        var target = {};
                        var keys = Object.keys(source);
                        var klen = keys.length;
                        var k = 0;

                        for (; k < klen; ++k) {
                            target[keys[k]] = helpers.clone(source[keys[k]]);
                        }

                        return target;
                    }

                    return source;
                },

                /**
                 * The default merger when Chart.helpers.merge is called without merger option.
                 * Note(SB): also used by mergeConfig and mergeScaleConfig as fallback.
                 * @private
                 */
                _merger: function(key, target, source, options) {
                    var tval = target[key];
                    var sval = source[key];

                    if (helpers.isObject(tval) && helpers.isObject(sval)) {
                        helpers.merge(tval, sval, options);
                    } else {
                        target[key] = helpers.clone(sval);
                    }
                },

                /**
                 * Merges source[key] in target[key] only if target[key] is undefined.
                 * @private
                 */
                _mergerIf: function(key, target, source) {
                    var tval = target[key];
                    var sval = source[key];

                    if (helpers.isObject(tval) && helpers.isObject(sval)) {
                        helpers.mergeIf(tval, sval);
                    } else if (!target.hasOwnProperty(key)) {
                        target[key] = helpers.clone(sval);
                    }
                },

                /**
                 * Recursively deep copies `source` properties into `target` with the given `options`.
                 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
                 * @param {object} target - The target object in which all sources are merged into.
                 * @param {object|object[]} source - Object(s) to merge into `target`.
                 * @param {object} [options] - Merging options:
                 * @param {function} [options.merger] - The merge method (key, target, source, options)
                 * @returns {object} The `target` object.
                 */
                merge: function(target, source, options) {
                    var sources = helpers.isArray(source) ? source : [source];
                    var ilen = sources.length;
                    var merge, i, keys, klen, k;

                    if (!helpers.isObject(target)) {
                        return target;
                    }

                    options = options || {};
                    merge = options.merger || helpers._merger;

                    for (i = 0; i < ilen; ++i) {
                        source = sources[i];
                        if (!helpers.isObject(source)) {
                            continue;
                        }

                        keys = Object.keys(source);
                        for (k = 0, klen = keys.length; k < klen; ++k) {
                            merge(keys[k], target, source, options);
                        }
                    }

                    return target;
                },

                /**
                 * Recursively deep copies `source` properties into `target` *only* if not defined in target.
                 * IMPORTANT: `target` is not cloned and will be updated with `source` properties.
                 * @param {object} target - The target object in which all sources are merged into.
                 * @param {object|object[]} source - Object(s) to merge into `target`.
                 * @returns {object} The `target` object.
                 */
                mergeIf: function(target, source) {
                    return helpers.merge(target, source, {merger: helpers._mergerIf});
                },

                /**
                 * Applies the contents of two or more objects together into the first object.
                 * @param {object} target - The target object in which all objects are merged into.
                 * @param {object} arg1 - Object containing additional properties to merge in target.
                 * @param {object} argN - Additional objects containing properties to merge in target.
                 * @returns {object} The `target` object.
                 */
                extend: Object.assign || function(target) {
                    return helpers.merge(target, [].slice.call(arguments, 1), {
                        merger: function(key, dst, src) {
                            dst[key] = src[key];
                        }
                    });
                },

                /**
                 * Basic javascript inheritance based on the model created in Backbone.js
                 */
                inherits: function(extensions) {
                    var me = this;
                    var ChartElement = (extensions && extensions.hasOwnProperty('constructor')) ? extensions.constructor : function() {
                        return me.apply(this, arguments);
                    };

                    var Surrogate = function() {
                        this.constructor = ChartElement;
                    };

                    Surrogate.prototype = me.prototype;
                    ChartElement.prototype = new Surrogate();
                    ChartElement.extend = helpers.inherits;

                    if (extensions) {
                        helpers.extend(ChartElement.prototype, extensions);
                    }

                    ChartElement.__super__ = me.prototype;
                    return ChartElement;
                },

                _deprecated: function(scope, value, previous, current) {
                    if (value !== undefined) {
                        console.warn(scope + ': "' + previous +
                            '" is deprecated. Please use "' + current + '" instead');
                    }
                }
            };

            var helpers_core = helpers;

            // DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.helpers.callback instead.
             * @function Chart.helpers.callCallback
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             * @private
             */
            helpers.callCallback = helpers.callback;

            /**
             * Provided for backward compatibility, use Array.prototype.indexOf instead.
             * Array.prototype.indexOf compatibility: Chrome, Opera, Safari, FF1.5+, IE9+
             * @function Chart.helpers.indexOf
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.indexOf = function(array, item, fromIndex) {
                return Array.prototype.indexOf.call(array, item, fromIndex);
            };

            /**
             * Provided for backward compatibility, use Chart.helpers.valueOrDefault instead.
             * @function Chart.helpers.getValueOrDefault
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.getValueOrDefault = helpers.valueOrDefault;

            /**
             * Provided for backward compatibility, use Chart.helpers.valueAtIndexOrDefault instead.
             * @function Chart.helpers.getValueAtIndexOrDefault
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers.getValueAtIndexOrDefault = helpers.valueAtIndexOrDefault;

            /**
             * Easing functions adapted from Robert Penner's easing equations.
             * @namespace Chart.helpers.easingEffects
             * @see http://www.robertpenner.com/easing/
             */
            var effects = {
                linear: function(t) {
                    return t;
                },

                easeInQuad: function(t) {
                    return t * t;
                },

                easeOutQuad: function(t) {
                    return -t * (t - 2);
                },

                easeInOutQuad: function(t) {
                    if ((t /= 0.5) < 1) {
                        return 0.5 * t * t;
                    }
                    return -0.5 * ((--t) * (t - 2) - 1);
                },

                easeInCubic: function(t) {
                    return t * t * t;
                },

                easeOutCubic: function(t) {
                    return (t = t - 1) * t * t + 1;
                },

                easeInOutCubic: function(t) {
                    if ((t /= 0.5) < 1) {
                        return 0.5 * t * t * t;
                    }
                    return 0.5 * ((t -= 2) * t * t + 2);
                },

                easeInQuart: function(t) {
                    return t * t * t * t;
                },

                easeOutQuart: function(t) {
                    return -((t = t - 1) * t * t * t - 1);
                },

                easeInOutQuart: function(t) {
                    if ((t /= 0.5) < 1) {
                        return 0.5 * t * t * t * t;
                    }
                    return -0.5 * ((t -= 2) * t * t * t - 2);
                },

                easeInQuint: function(t) {
                    return t * t * t * t * t;
                },

                easeOutQuint: function(t) {
                    return (t = t - 1) * t * t * t * t + 1;
                },

                easeInOutQuint: function(t) {
                    if ((t /= 0.5) < 1) {
                        return 0.5 * t * t * t * t * t;
                    }
                    return 0.5 * ((t -= 2) * t * t * t * t + 2);
                },

                easeInSine: function(t) {
                    return -Math.cos(t * (Math.PI / 2)) + 1;
                },

                easeOutSine: function(t) {
                    return Math.sin(t * (Math.PI / 2));
                },

                easeInOutSine: function(t) {
                    return -0.5 * (Math.cos(Math.PI * t) - 1);
                },

                easeInExpo: function(t) {
                    return (t === 0) ? 0 : Math.pow(2, 10 * (t - 1));
                },

                easeOutExpo: function(t) {
                    return (t === 1) ? 1 : -Math.pow(2, -10 * t) + 1;
                },

                easeInOutExpo: function(t) {
                    if (t === 0) {
                        return 0;
                    }
                    if (t === 1) {
                        return 1;
                    }
                    if ((t /= 0.5) < 1) {
                        return 0.5 * Math.pow(2, 10 * (t - 1));
                    }
                    return 0.5 * (-Math.pow(2, -10 * --t) + 2);
                },

                easeInCirc: function(t) {
                    if (t >= 1) {
                        return t;
                    }
                    return -(Math.sqrt(1 - t * t) - 1);
                },

                easeOutCirc: function(t) {
                    return Math.sqrt(1 - (t = t - 1) * t);
                },

                easeInOutCirc: function(t) {
                    if ((t /= 0.5) < 1) {
                        return -0.5 * (Math.sqrt(1 - t * t) - 1);
                    }
                    return 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
                },

                easeInElastic: function(t) {
                    var s = 1.70158;
                    var p = 0;
                    var a = 1;
                    if (t === 0) {
                        return 0;
                    }
                    if (t === 1) {
                        return 1;
                    }
                    if (!p) {
                        p = 0.3;
                    }
                    if (a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p / (2 * Math.PI) * Math.asin(1 / a);
                    }
                    return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
                },

                easeOutElastic: function(t) {
                    var s = 1.70158;
                    var p = 0;
                    var a = 1;
                    if (t === 0) {
                        return 0;
                    }
                    if (t === 1) {
                        return 1;
                    }
                    if (!p) {
                        p = 0.3;
                    }
                    if (a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p / (2 * Math.PI) * Math.asin(1 / a);
                    }
                    return a * Math.pow(2, -10 * t) * Math.sin((t - s) * (2 * Math.PI) / p) + 1;
                },

                easeInOutElastic: function(t) {
                    var s = 1.70158;
                    var p = 0;
                    var a = 1;
                    if (t === 0) {
                        return 0;
                    }
                    if ((t /= 0.5) === 2) {
                        return 1;
                    }
                    if (!p) {
                        p = 0.45;
                    }
                    if (a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p / (2 * Math.PI) * Math.asin(1 / a);
                    }
                    if (t < 1) {
                        return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p));
                    }
                    return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * (2 * Math.PI) / p) * 0.5 + 1;
                },
                easeInBack: function(t) {
                    var s = 1.70158;
                    return t * t * ((s + 1) * t - s);
                },

                easeOutBack: function(t) {
                    var s = 1.70158;
                    return (t = t - 1) * t * ((s + 1) * t + s) + 1;
                },

                easeInOutBack: function(t) {
                    var s = 1.70158;
                    if ((t /= 0.5) < 1) {
                        return 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s));
                    }
                    return 0.5 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2);
                },

                easeInBounce: function(t) {
                    return 1 - effects.easeOutBounce(1 - t);
                },

                easeOutBounce: function(t) {
                    if (t < (1 / 2.75)) {
                        return 7.5625 * t * t;
                    }
                    if (t < (2 / 2.75)) {
                        return 7.5625 * (t -= (1.5 / 2.75)) * t + 0.75;
                    }
                    if (t < (2.5 / 2.75)) {
                        return 7.5625 * (t -= (2.25 / 2.75)) * t + 0.9375;
                    }
                    return 7.5625 * (t -= (2.625 / 2.75)) * t + 0.984375;
                },

                easeInOutBounce: function(t) {
                    if (t < 0.5) {
                        return effects.easeInBounce(t * 2) * 0.5;
                    }
                    return effects.easeOutBounce(t * 2 - 1) * 0.5 + 0.5;
                }
            };

            var helpers_easing = {
                effects: effects
            };

            // DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.helpers.easing.effects instead.
             * @function Chart.helpers.easingEffects
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers_core.easingEffects = effects;

            var PI = Math.PI;
            var RAD_PER_DEG = PI / 180;
            var DOUBLE_PI = PI * 2;
            var HALF_PI = PI / 2;
            var QUARTER_PI = PI / 4;
            var TWO_THIRDS_PI = PI * 2 / 3;

            /**
             * @namespace Chart.helpers.canvas
             */
            var exports$1 = {
                /**
                 * Clears the entire canvas associated to the given `chart`.
                 * @param {Chart} chart - The chart for which to clear the canvas.
                 */
                clear: function(chart) {
                    chart.ctx.clearRect(0, 0, chart.width, chart.height);
                },

                /**
                 * Creates a "path" for a rectangle with rounded corners at position (x, y) with a
                 * given size (width, height) and the same `radius` for all corners.
                 * @param {CanvasRenderingContext2D} ctx - The canvas 2D Context.
                 * @param {number} x - The x axis of the coordinate for the rectangle starting point.
                 * @param {number} y - The y axis of the coordinate for the rectangle starting point.
                 * @param {number} width - The rectangle's width.
                 * @param {number} height - The rectangle's height.
                 * @param {number} radius - The rounded amount (in pixels) for the four corners.
                 * @todo handle `radius` as top-left, top-right, bottom-right, bottom-left array/object?
                 */
                roundedRect: function(ctx, x, y, width, height, radius) {
                    if (radius) {
                        var r = Math.min(radius, height / 2, width / 2);
                        var left = x + r;
                        var top = y + r;
                        var right = x + width - r;
                        var bottom = y + height - r;

                        ctx.moveTo(x, top);
                        if (left < right && top < bottom) {
                            ctx.arc(left, top, r, -PI, -HALF_PI);
                            ctx.arc(right, top, r, -HALF_PI, 0);
                            ctx.arc(right, bottom, r, 0, HALF_PI);
                            ctx.arc(left, bottom, r, HALF_PI, PI);
                        } else if (left < right) {
                            ctx.moveTo(left, y);
                            ctx.arc(right, top, r, -HALF_PI, HALF_PI);
                            ctx.arc(left, top, r, HALF_PI, PI + HALF_PI);
                        } else if (top < bottom) {
                            ctx.arc(left, top, r, -PI, 0);
                            ctx.arc(left, bottom, r, 0, PI);
                        } else {
                            ctx.arc(left, top, r, -PI, PI);
                        }
                        ctx.closePath();
                        ctx.moveTo(x, y);
                    } else {
                        ctx.rect(x, y, width, height);
                    }
                },

                drawPoint: function(ctx, style, radius, x, y, rotation) {
                    var type, xOffset, yOffset, size, cornerRadius;
                    var rad = (rotation || 0) * RAD_PER_DEG;

                    if (style && typeof style === 'object') {
                        type = style.toString();
                        if (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]') {
                            ctx.save();
                            ctx.translate(x, y);
                            ctx.rotate(rad);
                            ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                            ctx.restore();
                            return;
                        }
                    }

                    if (isNaN(radius) || radius <= 0) {
                        return;
                    }

                    ctx.beginPath();

                    switch (style) {
                        // Default includes circle
                        default:
                            ctx.arc(x, y, radius, 0, DOUBLE_PI);
                            ctx.closePath();
                            break;
                        case 'triangle':
                            ctx.moveTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                            rad += TWO_THIRDS_PI;
                            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                            rad += TWO_THIRDS_PI;
                            ctx.lineTo(x + Math.sin(rad) * radius, y - Math.cos(rad) * radius);
                            ctx.closePath();
                            break;
                        case 'rectRounded':
                            // NOTE: the rounded rect implementation changed to use `arc` instead of
                            // `quadraticCurveTo` since it generates better results when rect is
                            // almost a circle. 0.516 (instead of 0.5) produces results with visually
                            // closer proportion to the previous impl and it is inscribed in the
                            // circle with `radius`. For more details, see the following PRs:
                            // https://github.com/chartjs/Chart.js/issues/5597
                            // https://github.com/chartjs/Chart.js/issues/5858
                            cornerRadius = radius * 0.516;
                            size = radius - cornerRadius;
                            xOffset = Math.cos(rad + QUARTER_PI) * size;
                            yOffset = Math.sin(rad + QUARTER_PI) * size;
                            ctx.arc(x - xOffset, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                            ctx.arc(x + yOffset, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                            ctx.arc(x + xOffset, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                            ctx.arc(x - yOffset, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                            ctx.closePath();
                            break;
                        case 'rect':
                            if (!rotation) {
                                size = Math.SQRT1_2 * radius;
                                ctx.rect(x - size, y - size, 2 * size, 2 * size);
                                break;
                            }
                            rad += QUARTER_PI;
                        /* falls through */
                        case 'rectRot':
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + yOffset, y - xOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            ctx.lineTo(x - yOffset, y + xOffset);
                            ctx.closePath();
                            break;
                        case 'crossRot':
                            rad += QUARTER_PI;
                        /* falls through */
                        case 'cross':
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            ctx.moveTo(x + yOffset, y - xOffset);
                            ctx.lineTo(x - yOffset, y + xOffset);
                            break;
                        case 'star':
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            ctx.moveTo(x + yOffset, y - xOffset);
                            ctx.lineTo(x - yOffset, y + xOffset);
                            rad += QUARTER_PI;
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            ctx.moveTo(x + yOffset, y - xOffset);
                            ctx.lineTo(x - yOffset, y + xOffset);
                            break;
                        case 'line':
                            xOffset = Math.cos(rad) * radius;
                            yOffset = Math.sin(rad) * radius;
                            ctx.moveTo(x - xOffset, y - yOffset);
                            ctx.lineTo(x + xOffset, y + yOffset);
                            break;
                        case 'dash':
                            ctx.moveTo(x, y);
                            ctx.lineTo(x + Math.cos(rad) * radius, y + Math.sin(rad) * radius);
                            break;
                    }

                    ctx.fill();
                    ctx.stroke();
                },

                /**
                 * Returns true if the point is inside the rectangle
                 * @param {object} point - The point to test
                 * @param {object} area - The rectangle
                 * @returns {boolean}
                 * @private
                 */
                _isPointInArea: function(point, area) {
                    var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.

                    return point.x > area.left - epsilon && point.x < area.right + epsilon &&
                        point.y > area.top - epsilon && point.y < area.bottom + epsilon;
                },

                clipArea: function(ctx, area) {
                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
                    ctx.clip();
                },

                unclipArea: function(ctx) {
                    ctx.restore();
                },

                lineTo: function(ctx, previous, target, flip) {
                    var stepped = target.steppedLine;
                    if (stepped) {
                        if (stepped === 'middle') {
                            var midpoint = (previous.x + target.x) / 2.0;
                            ctx.lineTo(midpoint, flip ? target.y : previous.y);
                            ctx.lineTo(midpoint, flip ? previous.y : target.y);
                        } else if ((stepped === 'after' && !flip) || (stepped !== 'after' && flip)) {
                            ctx.lineTo(previous.x, target.y);
                        } else {
                            ctx.lineTo(target.x, previous.y);
                        }
                        ctx.lineTo(target.x, target.y);
                        return;
                    }

                    if (!target.tension) {
                        ctx.lineTo(target.x, target.y);
                        return;
                    }

                    ctx.bezierCurveTo(
                        flip ? previous.controlPointPreviousX : previous.controlPointNextX,
                        flip ? previous.controlPointPreviousY : previous.controlPointNextY,
                        flip ? target.controlPointNextX : target.controlPointPreviousX,
                        flip ? target.controlPointNextY : target.controlPointPreviousY,
                        target.x,
                        target.y);
                }
            };

            var helpers_canvas = exports$1;

            // DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.helpers.canvas.clear instead.
             * @namespace Chart.helpers.clear
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers_core.clear = exports$1.clear;

            /**
             * Provided for backward compatibility, use Chart.helpers.canvas.roundedRect instead.
             * @namespace Chart.helpers.drawRoundedRectangle
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers_core.drawRoundedRectangle = function(ctx) {
                ctx.beginPath();
                exports$1.roundedRect.apply(exports$1, arguments);
            };

            var defaults = {
                /**
                 * @private
                 */
                _set: function(scope, values) {
                    return helpers_core.merge(this[scope] || (this[scope] = {}), values);
                }
            };

            // TODO(v3): remove 'global' from namespace.  all default are global and
            // there's inconsistency around which options are under 'global'
            defaults._set('global', {
                defaultColor: 'rgba(0,0,0,0.1)',
                defaultFontColor: '#666',
                defaultFontFamily: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                defaultFontSize: 12,
                defaultFontStyle: 'normal',
                defaultLineHeight: 1.2,
                showLines: true
            });

            var core_defaults = defaults;

            var valueOrDefault = helpers_core.valueOrDefault;

            /**
             * Converts the given font object into a CSS font string.
             * @param {object} font - A font object.
             * @return {string} The CSS font string. See https://developer.mozilla.org/en-US/docs/Web/CSS/font
             * @private
             */
            function toFontString(font) {
                if (!font || helpers_core.isNullOrUndef(font.size) || helpers_core.isNullOrUndef(font.family)) {
                    return null;
                }

                return (font.style ? font.style + ' ' : '')
                    + (font.weight ? font.weight + ' ' : '')
                    + font.size + 'px '
                    + font.family;
            }

            /**
             * @alias Chart.helpers.options
             * @namespace
             */
            var helpers_options = {
                /**
                 * Converts the given line height `value` in pixels for a specific font `size`.
                 * @param {number|string} value - The lineHeight to parse (eg. 1.6, '14px', '75%', '1.6em').
                 * @param {number} size - The font size (in pixels) used to resolve relative `value`.
                 * @returns {number} The effective line height in pixels (size * 1.2 if value is invalid).
                 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/line-height
                 * @since 2.7.0
                 */
                toLineHeight: function(value, size) {
                    var matches = ('' + value).match(/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/);
                    if (!matches || matches[1] === 'normal') {
                        return size * 1.2;
                    }

                    value = +matches[2];

                    switch (matches[3]) {
                        case 'px':
                            return value;
                        case '%':
                            value /= 100;
                            break;
                    }

                    return size * value;
                },

                /**
                 * Converts the given value into a padding object with pre-computed width/height.
                 * @param {number|object} value - If a number, set the value to all TRBL component,
                 *  else, if and object, use defined properties and sets undefined ones to 0.
                 * @returns {object} The padding values (top, right, bottom, left, width, height)
                 * @since 2.7.0
                 */
                toPadding: function(value) {
                    var t, r, b, l;

                    if (helpers_core.isObject(value)) {
                        t = +value.top || 0;
                        r = +value.right || 0;
                        b = +value.bottom || 0;
                        l = +value.left || 0;
                    } else {
                        t = r = b = l = +value || 0;
                    }

                    return {
                        top: t,
                        right: r,
                        bottom: b,
                        left: l,
                        height: t + b,
                        width: l + r
                    };
                },

                /**
                 * Parses font options and returns the font object.
                 * @param {object} options - A object that contains font options to be parsed.
                 * @return {object} The font object.
                 * @todo Support font.* options and renamed to toFont().
                 * @private
                 */
                _parseFont: function(options) {
                    var globalDefaults = core_defaults.global;
                    var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);
                    var font = {
                        family: valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily),
                        lineHeight: helpers_core.options.toLineHeight(valueOrDefault(options.lineHeight, globalDefaults.defaultLineHeight), size),
                        size: size,
                        style: valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle),
                        weight: null,
                        string: ''
                    };

                    font.string = toFontString(font);
                    return font;
                },

                /**
                 * Evaluates the given `inputs` sequentially and returns the first defined value.
                 * @param {Array} inputs - An array of values, falling back to the last value.
                 * @param {object} [context] - If defined and the current value is a function, the value
                 * is called with `context` as first argument and the result becomes the new input.
                 * @param {number} [index] - If defined and the current value is an array, the value
                 * at `index` become the new input.
                 * @param {object} [info] - object to return information about resolution in
                 * @param {boolean} [info.cacheable] - Will be set to `false` if option is not cacheable.
                 * @since 2.7.0
                 */
                resolve: function(inputs, context, index, info) {
                    var cacheable = true;
                    var i, ilen, value;

                    for (i = 0, ilen = inputs.length; i < ilen; ++i) {
                        value = inputs[i];
                        if (value === undefined) {
                            continue;
                        }
                        if (context !== undefined && typeof value === 'function') {
                            value = value(context);
                            cacheable = false;
                        }
                        if (index !== undefined && helpers_core.isArray(value)) {
                            value = value[index];
                            cacheable = false;
                        }
                        if (value !== undefined) {
                            if (info && !cacheable) {
                                info.cacheable = false;
                            }
                            return value;
                        }
                    }
                }
            };

            /**
             * @alias Chart.helpers.math
             * @namespace
             */
            var exports$2 = {
                /**
                 * Returns an array of factors sorted from 1 to sqrt(value)
                 * @private
                 */
                _factorize: function(value) {
                    var result = [];
                    var sqrt = Math.sqrt(value);
                    var i;

                    for (i = 1; i < sqrt; i++) {
                        if (value % i === 0) {
                            result.push(i);
                            result.push(value / i);
                        }
                    }
                    if (sqrt === (sqrt | 0)) { // if value is a square number
                        result.push(sqrt);
                    }

                    result.sort(function(a, b) {
                        return a - b;
                    }).pop();
                    return result;
                },

                log10: Math.log10 || function(x) {
                    var exponent = Math.log(x) * Math.LOG10E; // Math.LOG10E = 1 / Math.LN10.
                    // Check for whole powers of 10,
                    // which due to floating point rounding error should be corrected.
                    var powerOf10 = Math.round(exponent);
                    var isPowerOf10 = x === Math.pow(10, powerOf10);

                    return isPowerOf10 ? powerOf10 : exponent;
                }
            };

            var helpers_math = exports$2;

            // DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.helpers.math.log10 instead.
             * @namespace Chart.helpers.log10
             * @deprecated since version 2.9.0
             * @todo remove at version 3
             * @private
             */
            helpers_core.log10 = exports$2.log10;

            var getRtlAdapter = function(rectX, width) {
                return {
                    x: function(x) {
                        return rectX + rectX + width - x;
                    },
                    setWidth: function(w) {
                        width = w;
                    },
                    textAlign: function(align) {
                        if (align === 'center') {
                            return align;
                        }
                        return align === 'right' ? 'left' : 'right';
                    },
                    xPlus: function(x, value) {
                        return x - value;
                    },
                    leftForLtr: function(x, itemWidth) {
                        return x - itemWidth;
                    },
                };
            };

            var getLtrAdapter = function() {
                return {
                    x: function(x) {
                        return x;
                    },
                    setWidth: function(w) { // eslint-disable-line no-unused-vars
                    },
                    textAlign: function(align) {
                        return align;
                    },
                    xPlus: function(x, value) {
                        return x + value;
                    },
                    leftForLtr: function(x, _itemWidth) { // eslint-disable-line no-unused-vars
                        return x;
                    },
                };
            };

            var getAdapter = function(rtl, rectX, width) {
                return rtl ? getRtlAdapter(rectX, width) : getLtrAdapter();
            };

            var overrideTextDirection = function(ctx, direction) {
                var style, original;
                if (direction === 'ltr' || direction === 'rtl') {
                    style = ctx.canvas.style;
                    original = [
                        style.getPropertyValue('direction'),
                        style.getPropertyPriority('direction'),
                    ];

                    style.setProperty('direction', direction, 'important');
                    ctx.prevTextDirection = original;
                }
            };

            var restoreTextDirection = function(ctx) {
                var original = ctx.prevTextDirection;
                if (original !== undefined) {
                    delete ctx.prevTextDirection;
                    ctx.canvas.style.setProperty('direction', original[0], original[1]);
                }
            };

            var helpers_rtl = {
                getRtlAdapter: getAdapter,
                overrideTextDirection: overrideTextDirection,
                restoreTextDirection: restoreTextDirection,
            };

            var helpers$1 = helpers_core;
            var easing = helpers_easing;
            var canvas = helpers_canvas;
            var options = helpers_options;
            var math = helpers_math;
            var rtl = helpers_rtl;
            helpers$1.easing = easing;
            helpers$1.canvas = canvas;
            helpers$1.options = options;
            helpers$1.math = math;
            helpers$1.rtl = rtl;

            function interpolate(start, view, model, ease) {
                var keys = Object.keys(model);
                var i, ilen, key, actual, origin, target, type, c0, c1;

                for (i = 0, ilen = keys.length; i < ilen; ++i) {
                    key = keys[i];

                    target = model[key];

                    // if a value is added to the model after pivot() has been called, the view
                    // doesn't contain it, so let's initialize the view to the target value.
                    if (!view.hasOwnProperty(key)) {
                        view[key] = target;
                    }

                    actual = view[key];

                    if (actual === target || key[0] === '_') {
                        continue;
                    }

                    if (!start.hasOwnProperty(key)) {
                        start[key] = actual;
                    }

                    origin = start[key];

                    type = typeof target;

                    if (type === typeof origin) {
                        if (type === 'string') {
                            c0 = chartjsColor(origin);
                            if (c0.valid) {
                                c1 = chartjsColor(target);
                                if (c1.valid) {
                                    view[key] = c1.mix(c0, ease).rgbString();
                                    continue;
                                }
                            }
                        } else if (helpers$1.isFinite(origin) && helpers$1.isFinite(target)) {
                            view[key] = origin + (target - origin) * ease;
                            continue;
                        }
                    }

                    view[key] = target;
                }
            }

            var Element = function(configuration) {
                helpers$1.extend(this, configuration);
                this.initialize.apply(this, arguments);
            };

            helpers$1.extend(Element.prototype, {
                _type: undefined,

                initialize: function() {
                    this.hidden = false;
                },

                pivot: function() {
                    var me = this;
                    if (!me._view) {
                        me._view = helpers$1.extend({}, me._model);
                    }
                    me._start = {};
                    return me;
                },

                transition: function(ease) {
                    var me = this;
                    var model = me._model;
                    var start = me._start;
                    var view = me._view;

                    // No animation -> No Transition
                    if (!model || ease === 1) {
                        me._view = helpers$1.extend({}, model);
                        me._start = null;
                        return me;
                    }

                    if (!view) {
                        view = me._view = {};
                    }

                    if (!start) {
                        start = me._start = {};
                    }

                    interpolate(start, view, model, ease);

                    return me;
                },

                tooltipPosition: function() {
                    return {
                        x: this._model.x,
                        y: this._model.y
                    };
                },

                hasValue: function() {
                    return helpers$1.isNumber(this._model.x) && helpers$1.isNumber(this._model.y);
                }
            });

            Element.extend = helpers$1.inherits;

            var core_element = Element;

            var exports$3 = core_element.extend({
                chart: null, // the animation associated chart instance
                currentStep: 0, // the current animation step
                numSteps: 60, // default number of steps
                easing: '', // the easing to use for this animation
                render: null, // render function used by the animation service

                onAnimationProgress: null, // user specified callback to fire on each step of the animation
                onAnimationComplete: null, // user specified callback to fire when the animation finishes
            });

            var core_animation = exports$3;

            // DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart.Animation instead
             * @prop Chart.Animation#animationObject
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             */
            Object.defineProperty(exports$3.prototype, 'animationObject', {
                get: function() {
                    return this;
                }
            });

            /**
             * Provided for backward compatibility, use Chart.Animation#chart instead
             * @prop Chart.Animation#chartInstance
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             */
            Object.defineProperty(exports$3.prototype, 'chartInstance', {
                get: function() {
                    return this.chart;
                },
                set: function(value) {
                    this.chart = value;
                }
            });

            core_defaults._set('global', {
                animation: {
                    duration: 1000,
                    easing: 'easeOutQuart',
                    onProgress: helpers$1.noop,
                    onComplete: helpers$1.noop
                }
            });

            var core_animations = {
                animations: [],
                request: null,

                /**
                 * @param {Chart} chart - The chart to animate.
                 * @param {Chart.Animation} animation - The animation that we will animate.
                 * @param {number} duration - The animation duration in ms.
                 * @param {boolean} lazy - if true, the chart is not marked as animating to enable more responsive interactions
                 */
                addAnimation: function(chart, animation, duration, lazy) {
                    var animations = this.animations;
                    var i, ilen;

                    animation.chart = chart;
                    animation.startTime = Date.now();
                    animation.duration = duration;

                    if (!lazy) {
                        chart.animating = true;
                    }

                    for (i = 0, ilen = animations.length; i < ilen; ++i) {
                        if (animations[i].chart === chart) {
                            animations[i] = animation;
                            return;
                        }
                    }

                    animations.push(animation);

                    // If there are no animations queued, manually kickstart a digest, for lack of a better word
                    if (animations.length === 1) {
                        this.requestAnimationFrame();
                    }
                },

                cancelAnimation: function(chart) {
                    var index = helpers$1.findIndex(this.animations, function(animation) {
                        return animation.chart === chart;
                    });

                    if (index !== -1) {
                        this.animations.splice(index, 1);
                        chart.animating = false;
                    }
                },

                requestAnimationFrame: function() {
                    var me = this;
                    if (me.request === null) {
                        // Skip animation frame requests until the active one is executed.
                        // This can happen when processing mouse events, e.g. 'mousemove'
                        // and 'mouseout' events will trigger multiple renders.
                        me.request = helpers$1.requestAnimFrame.call(window, function() {
                            me.request = null;
                            me.startDigest();
                        });
                    }
                },

                /**
                 * @private
                 */
                startDigest: function() {
                    var me = this;

                    me.advance();

                    // Do we have more stuff to animate?
                    if (me.animations.length > 0) {
                        me.requestAnimationFrame();
                    }
                },

                /**
                 * @private
                 */
                advance: function() {
                    var animations = this.animations;
                    var animation, chart, numSteps, nextStep;
                    var i = 0;

                    // 1 animation per chart, so we are looping charts here
                    while (i < animations.length) {
                        animation = animations[i];
                        chart = animation.chart;
                        numSteps = animation.numSteps;

                        // Make sure that currentStep starts at 1
                        // https://github.com/chartjs/Chart.js/issues/6104
                        nextStep = Math.floor((Date.now() - animation.startTime) / animation.duration * numSteps) + 1;
                        animation.currentStep = Math.min(nextStep, numSteps);

                        helpers$1.callback(animation.render, [chart, animation], chart);
                        helpers$1.callback(animation.onAnimationProgress, [animation], chart);

                        if (animation.currentStep >= numSteps) {
                            helpers$1.callback(animation.onAnimationComplete, [animation], chart);
                            chart.animating = false;
                            animations.splice(i, 1);
                        } else {
                            ++i;
                        }
                    }
                }
            };

            var resolve = helpers$1.options.resolve;

            var arrayEvents = ['push', 'pop', 'shift', 'splice', 'unshift'];

            /**
             * Hooks the array methods that add or remove values ('push', pop', 'shift', 'splice',
             * 'unshift') and notify the listener AFTER the array has been altered. Listeners are
             * called on the 'onData*' callbacks (e.g. onDataPush, etc.) with same arguments.
             */
            function listenArrayEvents(array, listener) {
                if (array._chartjs) {
                    array._chartjs.listeners.push(listener);
                    return;
                }

                Object.defineProperty(array, '_chartjs', {
                    configurable: true,
                    enumerable: false,
                    value: {
                        listeners: [listener]
                    }
                });

                arrayEvents.forEach(function(key) {
                    var method = 'onData' + key.charAt(0).toUpperCase() + key.slice(1);
                    var base = array[key];

                    Object.defineProperty(array, key, {
                        configurable: true,
                        enumerable: false,
                        value: function() {
                            var args = Array.prototype.slice.call(arguments);
                            var res = base.apply(this, args);

                            helpers$1.each(array._chartjs.listeners, function(object) {
                                if (typeof object[method] === 'function') {
                                    object[method].apply(object, args);
                                }
                            });

                            return res;
                        }
                    });
                });
            }

            /**
             * Removes the given array event listener and cleanup extra attached properties (such as
             * the _chartjs stub and overridden methods) if array doesn't have any more listeners.
             */
            function unlistenArrayEvents(array, listener) {
                var stub = array._chartjs;
                if (!stub) {
                    return;
                }

                var listeners = stub.listeners;
                var index = listeners.indexOf(listener);
                if (index !== -1) {
                    listeners.splice(index, 1);
                }

                if (listeners.length > 0) {
                    return;
                }

                arrayEvents.forEach(function(key) {
                    delete array[key];
                });

                delete array._chartjs;
            }

            // Base class for all dataset controllers (line, bar, etc)
            var DatasetController = function(chart, datasetIndex) {
                this.initialize(chart, datasetIndex);
            };

            helpers$1.extend(DatasetController.prototype, {

                /**
                 * Element type used to generate a meta dataset (e.g. Chart.element.Line).
                 * @type {Chart.core.element}
                 */
                datasetElementType: null,

                /**
                 * Element type used to generate a meta data (e.g. Chart.element.Point).
                 * @type {Chart.core.element}
                 */
                dataElementType: null,

                /**
                 * Dataset element option keys to be resolved in _resolveDatasetElementOptions.
                 * A derived controller may override this to resolve controller-specific options.
                 * The keys defined here are for backward compatibility for legend styles.
                 * @private
                 */
                _datasetElementOptions: [
                    'backgroundColor',
                    'borderCapStyle',
                    'borderColor',
                    'borderDash',
                    'borderDashOffset',
                    'borderJoinStyle',
                    'borderWidth'
                ],

                /**
                 * Data element option keys to be resolved in _resolveDataElementOptions.
                 * A derived controller may override this to resolve controller-specific options.
                 * The keys defined here are for backward compatibility for legend styles.
                 * @private
                 */
                _dataElementOptions: [
                    'backgroundColor',
                    'borderColor',
                    'borderWidth',
                    'pointStyle'
                ],

                initialize: function(chart, datasetIndex) {
                    var me = this;
                    me.chart = chart;
                    me.index = datasetIndex;
                    me.linkScales();
                    me.addElements();
                    me._type = me.getMeta().type;
                },

                updateIndex: function(datasetIndex) {
                    this.index = datasetIndex;
                },

                linkScales: function() {
                    var me = this;
                    var meta = me.getMeta();
                    var chart = me.chart;
                    var scales = chart.scales;
                    var dataset = me.getDataset();
                    var scalesOpts = chart.options.scales;

                    if (meta.xAxisID === null || !(meta.xAxisID in scales) || dataset.xAxisID) {
                        meta.xAxisID = dataset.xAxisID || scalesOpts.xAxes[0].id;
                    }
                    if (meta.yAxisID === null || !(meta.yAxisID in scales) || dataset.yAxisID) {
                        meta.yAxisID = dataset.yAxisID || scalesOpts.yAxes[0].id;
                    }
                },

                getDataset: function() {
                    return this.chart.data.datasets[this.index];
                },

                getMeta: function() {
                    return this.chart.getDatasetMeta(this.index);
                },

                getScaleForId: function(scaleID) {
                    return this.chart.scales[scaleID];
                },

                /**
                 * @private
                 */
                _getValueScaleId: function() {
                    return this.getMeta().yAxisID;
                },

                /**
                 * @private
                 */
                _getIndexScaleId: function() {
                    return this.getMeta().xAxisID;
                },

                /**
                 * @private
                 */
                _getValueScale: function() {
                    return this.getScaleForId(this._getValueScaleId());
                },

                /**
                 * @private
                 */
                _getIndexScale: function() {
                    return this.getScaleForId(this._getIndexScaleId());
                },

                reset: function() {
                    this._update(true);
                },

                /**
                 * @private
                 */
                destroy: function() {
                    if (this._data) {
                        unlistenArrayEvents(this._data, this);
                    }
                },

                createMetaDataset: function() {
                    var me = this;
                    var type = me.datasetElementType;
                    return type && new type({
                        _chart: me.chart,
                        _datasetIndex: me.index
                    });
                },

                createMetaData: function(index) {
                    var me = this;
                    var type = me.dataElementType;
                    return type && new type({
                        _chart: me.chart,
                        _datasetIndex: me.index,
                        _index: index
                    });
                },

                addElements: function() {
                    var me = this;
                    var meta = me.getMeta();
                    var data = me.getDataset().data || [];
                    var metaData = meta.data;
                    var i, ilen;

                    for (i = 0, ilen = data.length; i < ilen; ++i) {
                        metaData[i] = metaData[i] || me.createMetaData(i);
                    }

                    meta.dataset = meta.dataset || me.createMetaDataset();
                },

                addElementAndReset: function(index) {
                    var element = this.createMetaData(index);
                    this.getMeta().data.splice(index, 0, element);
                    this.updateElement(element, index, true);
                },

                buildOrUpdateElements: function() {
                    var me = this;
                    var dataset = me.getDataset();
                    var data = dataset.data || (dataset.data = []);

                    // In order to correctly handle data addition/deletion animation (an thus simulate
                    // real-time charts), we need to monitor these data modifications and synchronize
                    // the internal meta data accordingly.
                    if (me._data !== data) {
                        if (me._data) {
                            // This case happens when the user replaced the data array instance.
                            unlistenArrayEvents(me._data, me);
                        }

                        if (data && Object.isExtensible(data)) {
                            listenArrayEvents(data, me);
                        }
                        me._data = data;
                    }

                    // Re-sync meta data in case the user replaced the data array or if we missed
                    // any updates and so make sure that we handle number of datapoints changing.
                    me.resyncElements();
                },

                /**
                 * Returns the merged user-supplied and default dataset-level options
                 * @private
                 */
                _configure: function() {
                    var me = this;
                    me._config = helpers$1.merge({}, [
                        me.chart.options.datasets[me._type],
                        me.getDataset(),
                    ], {
                        merger: function(key, target, source) {
                            if (key !== '_meta' && key !== 'data') {
                                helpers$1._merger(key, target, source);
                            }
                        }
                    });
                },

                _update: function(reset) {
                    var me = this;
                    me._configure();
                    me._cachedDataOpts = null;
                    me.update(reset);
                },

                update: helpers$1.noop,

                transition: function(easingValue) {
                    var meta = this.getMeta();
                    var elements = meta.data || [];
                    var ilen = elements.length;
                    var i = 0;

                    for (; i < ilen; ++i) {
                        elements[i].transition(easingValue);
                    }

                    if (meta.dataset) {
                        meta.dataset.transition(easingValue);
                    }
                },

                draw: function() {
                    var meta = this.getMeta();
                    var elements = meta.data || [];
                    var ilen = elements.length;
                    var i = 0;

                    if (meta.dataset) {
                        meta.dataset.draw();
                    }

                    for (; i < ilen; ++i) {
                        elements[i].draw();
                    }
                },

                /**
                 * Returns a set of predefined style properties that should be used to represent the dataset
                 * or the data if the index is specified
                 * @param {number} index - data index
                 * @return {IStyleInterface} style object
                 */
                getStyle: function(index) {
                    var me = this;
                    var meta = me.getMeta();
                    var dataset = meta.dataset;
                    var style;

                    me._configure();
                    if (dataset && index === undefined) {
                        style = me._resolveDatasetElementOptions(dataset || {});
                    } else {
                        index = index || 0;
                        style = me._resolveDataElementOptions(meta.data[index] || {}, index);
                    }

                    if (style.fill === false || style.fill === null) {
                        style.backgroundColor = 'rgba(0,0,0,0)';
                    }

                    return style;
                },

                /**
                 * @private
                 */
                _resolveDatasetElementOptions: function(element, hover) {
                    var me = this;
                    var chart = me.chart;
                    var datasetOpts = me._config;
                    var custom = element.custom || {};
                    var options = chart.options.elements[me.datasetElementType.prototype._type] || {};
                    var elementOptions = me._datasetElementOptions;
                    var values = {};
                    var i, ilen, key, readKey;

                    // Scriptable options
                    var context = {
                        chart: chart,
                        dataset: me.getDataset(),
                        datasetIndex: me.index,
                        hover: hover
                    };

                    for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                        key = elementOptions[i];
                        readKey = hover ? 'hover' + key.charAt(0).toUpperCase() + key.slice(1) : key;
                        values[key] = resolve([
                            custom[readKey],
                            datasetOpts[readKey],
                            options[readKey]
                        ], context);
                    }

                    return values;
                },

                /**
                 * @private
                 */
                _resolveDataElementOptions: function(element, index) {
                    var me = this;
                    var custom = element && element.custom;
                    var cached = me._cachedDataOpts;
                    if (cached && !custom) {
                        return cached;
                    }
                    var chart = me.chart;
                    var datasetOpts = me._config;
                    var options = chart.options.elements[me.dataElementType.prototype._type] || {};
                    var elementOptions = me._dataElementOptions;
                    var values = {};

                    // Scriptable options
                    var context = {
                        chart: chart,
                        dataIndex: index,
                        dataset: me.getDataset(),
                        datasetIndex: me.index
                    };

                    // `resolve` sets cacheable to `false` if any option is indexed or scripted
                    var info = {cacheable: !custom};

                    var keys, i, ilen, key;

                    custom = custom || {};

                    if (helpers$1.isArray(elementOptions)) {
                        for (i = 0, ilen = elementOptions.length; i < ilen; ++i) {
                            key = elementOptions[i];
                            values[key] = resolve([
                                custom[key],
                                datasetOpts[key],
                                options[key]
                            ], context, index, info);
                        }
                    } else {
                        keys = Object.keys(elementOptions);
                        for (i = 0, ilen = keys.length; i < ilen; ++i) {
                            key = keys[i];
                            values[key] = resolve([
                                custom[key],
                                datasetOpts[elementOptions[key]],
                                datasetOpts[key],
                                options[key]
                            ], context, index, info);
                        }
                    }

                    if (info.cacheable) {
                        me._cachedDataOpts = Object.freeze(values);
                    }

                    return values;
                },

                removeHoverStyle: function(element) {
                    helpers$1.merge(element._model, element.$previousStyle || {});
                    delete element.$previousStyle;
                },

                setHoverStyle: function(element) {
                    var dataset = this.chart.data.datasets[element._datasetIndex];
                    var index = element._index;
                    var custom = element.custom || {};
                    var model = element._model;
                    var getHoverColor = helpers$1.getHoverColor;

                    element.$previousStyle = {
                        backgroundColor: model.backgroundColor,
                        borderColor: model.borderColor,
                        borderWidth: model.borderWidth
                    };

                    model.backgroundColor = resolve([custom.hoverBackgroundColor, dataset.hoverBackgroundColor, getHoverColor(model.backgroundColor)], undefined, index);
                    model.borderColor = resolve([custom.hoverBorderColor, dataset.hoverBorderColor, getHoverColor(model.borderColor)], undefined, index);
                    model.borderWidth = resolve([custom.hoverBorderWidth, dataset.hoverBorderWidth, model.borderWidth], undefined, index);
                },

                /**
                 * @private
                 */
                _removeDatasetHoverStyle: function() {
                    var element = this.getMeta().dataset;

                    if (element) {
                        this.removeHoverStyle(element);
                    }
                },

                /**
                 * @private
                 */
                _setDatasetHoverStyle: function() {
                    var element = this.getMeta().dataset;
                    var prev = {};
                    var i, ilen, key, keys, hoverOptions, model;

                    if (!element) {
                        return;
                    }

                    model = element._model;
                    hoverOptions = this._resolveDatasetElementOptions(element, true);

                    keys = Object.keys(hoverOptions);
                    for (i = 0, ilen = keys.length; i < ilen; ++i) {
                        key = keys[i];
                        prev[key] = model[key];
                        model[key] = hoverOptions[key];
                    }

                    element.$previousStyle = prev;
                },

                /**
                 * @private
                 */
                resyncElements: function() {
                    var me = this;
                    var meta = me.getMeta();
                    var data = me.getDataset().data;
                    var numMeta = meta.data.length;
                    var numData = data.length;

                    if (numData < numMeta) {
                        meta.data.splice(numData, numMeta - numData);
                    } else if (numData > numMeta) {
                        me.insertElements(numMeta, numData - numMeta);
                    }
                },

                /**
                 * @private
                 */
                insertElements: function(start, count) {
                    for (var i = 0; i < count; ++i) {
                        this.addElementAndReset(start + i);
                    }
                },

                /**
                 * @private
                 */
                onDataPush: function() {
                    var count = arguments.length;
                    this.insertElements(this.getDataset().data.length - count, count);
                },

                /**
                 * @private
                 */
                onDataPop: function() {
                    this.getMeta().data.pop();
                },

                /**
                 * @private
                 */
                onDataShift: function() {
                    this.getMeta().data.shift();
                },

                /**
                 * @private
                 */
                onDataSplice: function(start, count) {
                    this.getMeta().data.splice(start, count);
                    this.insertElements(start, arguments.length - 2);
                },

                /**
                 * @private
                 */
                onDataUnshift: function() {
                    this.insertElements(0, arguments.length);
                }
            });

            DatasetController.extend = helpers$1.inherits;

            var core_datasetController = DatasetController;

            var TAU = Math.PI * 2;

            core_defaults._set('global', {
                elements: {
                    arc: {
                        backgroundColor: core_defaults.global.defaultColor,
                        borderColor: '#fff',
                        borderWidth: 2,
                        borderAlign: 'center'
                    }
                }
            });

            function clipArc(ctx, arc) {
                var startAngle = arc.startAngle;
                var endAngle = arc.endAngle;
                var pixelMargin = arc.pixelMargin;
                var angleMargin = pixelMargin / arc.outerRadius;
                var x = arc.x;
                var y = arc.y;

                // Draw an inner border by cliping the arc and drawing a double-width border
                // Enlarge the clipping arc by 0.33 pixels to eliminate glitches between borders
                ctx.beginPath();
                ctx.arc(x, y, arc.outerRadius, startAngle - angleMargin, endAngle + angleMargin);
                if (arc.innerRadius > pixelMargin) {
                    angleMargin = pixelMargin / arc.innerRadius;
                    ctx.arc(x, y, arc.innerRadius - pixelMargin, endAngle + angleMargin, startAngle - angleMargin, true);
                } else {
                    ctx.arc(x, y, pixelMargin, endAngle + Math.PI / 2, startAngle - Math.PI / 2);
                }
                ctx.closePath();
                ctx.clip();
            }

            function drawFullCircleBorders(ctx, vm, arc, inner) {
                var endAngle = arc.endAngle;
                var i;

                if (inner) {
                    arc.endAngle = arc.startAngle + TAU;
                    clipArc(ctx, arc);
                    arc.endAngle = endAngle;
                    if (arc.endAngle === arc.startAngle && arc.fullCircles) {
                        arc.endAngle += TAU;
                        arc.fullCircles--;
                    }
                }

                ctx.beginPath();
                ctx.arc(arc.x, arc.y, arc.innerRadius, arc.startAngle + TAU, arc.startAngle, true);
                for (i = 0; i < arc.fullCircles; ++i) {
                    ctx.stroke();
                }

                ctx.beginPath();
                ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.startAngle + TAU);
                for (i = 0; i < arc.fullCircles; ++i) {
                    ctx.stroke();
                }
            }

            function drawBorder(ctx, vm, arc) {
                var inner = vm.borderAlign === 'inner';

                if (inner) {
                    ctx.lineWidth = vm.borderWidth * 2;
                    ctx.lineJoin = 'round';
                } else {
                    ctx.lineWidth = vm.borderWidth;
                    ctx.lineJoin = 'bevel';
                }

                if (arc.fullCircles) {
                    drawFullCircleBorders(ctx, vm, arc, inner);
                }

                if (inner) {
                    clipArc(ctx, arc);
                }

                ctx.beginPath();
                ctx.arc(arc.x, arc.y, vm.outerRadius, arc.startAngle, arc.endAngle);
                ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                ctx.closePath();
                ctx.stroke();
            }

            var element_arc = core_element.extend({
                _type: 'arc',

                inLabelRange: function(mouseX) {
                    var vm = this._view;

                    if (vm) {
                        return (Math.pow(mouseX - vm.x, 2) < Math.pow(vm.radius + vm.hoverRadius, 2));
                    }
                    return false;
                },

                inRange: function(chartX, chartY) {
                    var vm = this._view;

                    if (vm) {
                        var pointRelativePosition = helpers$1.getAngleFromPoint(vm, {x: chartX, y: chartY});
                        var angle = pointRelativePosition.angle;
                        var distance = pointRelativePosition.distance;

                        // Sanitise angle range
                        var startAngle = vm.startAngle;
                        var endAngle = vm.endAngle;
                        while (endAngle < startAngle) {
                            endAngle += TAU;
                        }
                        while (angle > endAngle) {
                            angle -= TAU;
                        }
                        while (angle < startAngle) {
                            angle += TAU;
                        }

                        // Check if within the range of the open/close angle
                        var betweenAngles = (angle >= startAngle && angle <= endAngle);
                        var withinRadius = (distance >= vm.innerRadius && distance <= vm.outerRadius);

                        return (betweenAngles && withinRadius);
                    }
                    return false;
                },

                getCenterPoint: function() {
                    var vm = this._view;
                    var halfAngle = (vm.startAngle + vm.endAngle) / 2;
                    var halfRadius = (vm.innerRadius + vm.outerRadius) / 2;
                    return {
                        x: vm.x + Math.cos(halfAngle) * halfRadius,
                        y: vm.y + Math.sin(halfAngle) * halfRadius
                    };
                },

                getArea: function() {
                    var vm = this._view;
                    return Math.PI * ((vm.endAngle - vm.startAngle) / (2 * Math.PI)) * (Math.pow(vm.outerRadius, 2) - Math.pow(vm.innerRadius, 2));
                },

                tooltipPosition: function() {
                    var vm = this._view;
                    var centreAngle = vm.startAngle + ((vm.endAngle - vm.startAngle) / 2);
                    var rangeFromCentre = (vm.outerRadius - vm.innerRadius) / 2 + vm.innerRadius;

                    return {
                        x: vm.x + (Math.cos(centreAngle) * rangeFromCentre),
                        y: vm.y + (Math.sin(centreAngle) * rangeFromCentre)
                    };
                },

                draw: function() {
                    var ctx = this._chart.ctx;
                    var vm = this._view;
                    var pixelMargin = (vm.borderAlign === 'inner') ? 0.33 : 0;
                    var arc = {
                        x: vm.x,
                        y: vm.y,
                        innerRadius: vm.innerRadius,
                        outerRadius: Math.max(vm.outerRadius - pixelMargin, 0),
                        pixelMargin: pixelMargin,
                        startAngle: vm.startAngle,
                        endAngle: vm.endAngle,
                        fullCircles: Math.floor(vm.circumference / TAU)
                    };
                    var i;

                    ctx.save();

                    ctx.fillStyle = vm.backgroundColor;
                    ctx.strokeStyle = vm.borderColor;

                    if (arc.fullCircles) {
                        arc.endAngle = arc.startAngle + TAU;
                        ctx.beginPath();
                        ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
                        ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                        ctx.closePath();
                        for (i = 0; i < arc.fullCircles; ++i) {
                            ctx.fill();
                        }
                        arc.endAngle = arc.startAngle + vm.circumference % TAU;
                    }

                    ctx.beginPath();
                    ctx.arc(arc.x, arc.y, arc.outerRadius, arc.startAngle, arc.endAngle);
                    ctx.arc(arc.x, arc.y, arc.innerRadius, arc.endAngle, arc.startAngle, true);
                    ctx.closePath();
                    ctx.fill();

                    if (vm.borderWidth) {
                        drawBorder(ctx, vm, arc);
                    }

                    ctx.restore();
                }
            });

            var valueOrDefault$1 = helpers$1.valueOrDefault;

            var defaultColor = core_defaults.global.defaultColor;

            core_defaults._set('global', {
                elements: {
                    line: {
                        tension: 0.4,
                        backgroundColor: defaultColor,
                        borderWidth: 3,
                        borderColor: defaultColor,
                        borderCapStyle: 'butt',
                        borderDash: [],
                        borderDashOffset: 0.0,
                        borderJoinStyle: 'miter',
                        capBezierPoints: true,
                        fill: true, // do we fill in the area between the line and its base axis
                    }
                }
            });

            var element_line = core_element.extend({
                _type: 'line',

                draw: function() {
                    var me = this;
                    var vm = me._view;
                    var ctx = me._chart.ctx;
                    var spanGaps = vm.spanGaps;
                    var points = me._children.slice(); // clone array
                    var globalDefaults = core_defaults.global;
                    var globalOptionLineElements = globalDefaults.elements.line;
                    var lastDrawnIndex = -1;
                    var closePath = me._loop;
                    var index, previous, currentVM;

                    if (!points.length) {
                        return;
                    }

                    if (me._loop) {
                        for (index = 0; index < points.length; ++index) {
                            previous = helpers$1.previousItem(points, index);
                            // If the line has an open path, shift the point array
                            if (!points[index]._view.skip && previous._view.skip) {
                                points = points.slice(index).concat(points.slice(0, index));
                                closePath = spanGaps;
                                break;
                            }
                        }
                        // If the line has a close path, add the first point again
                        if (closePath) {
                            points.push(points[0]);
                        }
                    }

                    ctx.save();

                    // Stroke Line Options
                    ctx.lineCap = vm.borderCapStyle || globalOptionLineElements.borderCapStyle;

                    // IE 9 and 10 do not support line dash
                    if (ctx.setLineDash) {
                        ctx.setLineDash(vm.borderDash || globalOptionLineElements.borderDash);
                    }

                    ctx.lineDashOffset = valueOrDefault$1(vm.borderDashOffset, globalOptionLineElements.borderDashOffset);
                    ctx.lineJoin = vm.borderJoinStyle || globalOptionLineElements.borderJoinStyle;
                    ctx.lineWidth = valueOrDefault$1(vm.borderWidth, globalOptionLineElements.borderWidth);
                    ctx.strokeStyle = vm.borderColor || globalDefaults.defaultColor;

                    // Stroke Line
                    ctx.beginPath();

                    // First point moves to it's starting position no matter what
                    currentVM = points[0]._view;
                    if (!currentVM.skip) {
                        ctx.moveTo(currentVM.x, currentVM.y);
                        lastDrawnIndex = 0;
                    }

                    for (index = 1; index < points.length; ++index) {
                        currentVM = points[index]._view;
                        previous = lastDrawnIndex === -1 ? helpers$1.previousItem(points, index) : points[lastDrawnIndex];

                        if (!currentVM.skip) {
                            if ((lastDrawnIndex !== (index - 1) && !spanGaps) || lastDrawnIndex === -1) {
                                // There was a gap and this is the first point after the gap
                                ctx.moveTo(currentVM.x, currentVM.y);
                            } else {
                                // Line to next point
                                helpers$1.canvas.lineTo(ctx, previous._view, currentVM);
                            }
                            lastDrawnIndex = index;
                        }
                    }

                    if (closePath) {
                        ctx.closePath();
                    }

                    ctx.stroke();
                    ctx.restore();
                }
            });

            var valueOrDefault$2 = helpers$1.valueOrDefault;

            var defaultColor$1 = core_defaults.global.defaultColor;

            core_defaults._set('global', {
                elements: {
                    point: {
                        radius: 3,
                        pointStyle: 'circle',
                        backgroundColor: defaultColor$1,
                        borderColor: defaultColor$1,
                        borderWidth: 1,
                        // Hover
                        hitRadius: 1,
                        hoverRadius: 4,
                        hoverBorderWidth: 1
                    }
                }
            });

            function xRange(mouseX) {
                var vm = this._view;
                return vm ? (Math.abs(mouseX - vm.x) < vm.radius + vm.hitRadius) : false;
            }

            function yRange(mouseY) {
                var vm = this._view;
                return vm ? (Math.abs(mouseY - vm.y) < vm.radius + vm.hitRadius) : false;
            }

            var element_point = core_element.extend({
                _type: 'point',

                inRange: function(mouseX, mouseY) {
                    var vm = this._view;
                    return vm ? ((Math.pow(mouseX - vm.x, 2) + Math.pow(mouseY - vm.y, 2)) < Math.pow(vm.hitRadius + vm.radius, 2)) : false;
                },

                inLabelRange: xRange,
                inXRange: xRange,
                inYRange: yRange,

                getCenterPoint: function() {
                    var vm = this._view;
                    return {
                        x: vm.x,
                        y: vm.y
                    };
                },

                getArea: function() {
                    return Math.PI * Math.pow(this._view.radius, 2);
                },

                tooltipPosition: function() {
                    var vm = this._view;
                    return {
                        x: vm.x,
                        y: vm.y,
                        padding: vm.radius + vm.borderWidth
                    };
                },

                draw: function(chartArea) {
                    var vm = this._view;
                    var ctx = this._chart.ctx;
                    var pointStyle = vm.pointStyle;
                    var rotation = vm.rotation;
                    var radius = vm.radius;
                    var x = vm.x;
                    var y = vm.y;
                    var globalDefaults = core_defaults.global;
                    var defaultColor = globalDefaults.defaultColor; // eslint-disable-line no-shadow

                    if (vm.skip) {
                        return;
                    }

                    // Clipping for Points.
                    if (chartArea === undefined || helpers$1.canvas._isPointInArea(vm, chartArea)) {
                        ctx.strokeStyle = vm.borderColor || defaultColor;
                        ctx.lineWidth = valueOrDefault$2(vm.borderWidth, globalDefaults.elements.point.borderWidth);
                        ctx.fillStyle = vm.backgroundColor || defaultColor;
                        helpers$1.canvas.drawPoint(ctx, pointStyle, radius, x, y, rotation);
                    }
                }
            });

            var defaultColor$2 = core_defaults.global.defaultColor;

            core_defaults._set('global', {
                elements: {
                    rectangle: {
                        backgroundColor: defaultColor$2,
                        borderColor: defaultColor$2,
                        borderSkipped: 'bottom',
                        borderWidth: 0
                    }
                }
            });

            function isVertical(vm) {
                return vm && vm.width !== undefined;
            }

            /**
             * Helper function to get the bounds of the bar regardless of the orientation
             * @param bar {Chart.Element.Rectangle} the bar
             * @return {Bounds} bounds of the bar
             * @private
             */
            function getBarBounds(vm) {
                var x1, x2, y1, y2, half;

                if (isVertical(vm)) {
                    half = vm.width / 2;
                    x1 = vm.x - half;
                    x2 = vm.x + half;
                    y1 = Math.min(vm.y, vm.base);
                    y2 = Math.max(vm.y, vm.base);
                } else {
                    half = vm.height / 2;
                    x1 = Math.min(vm.x, vm.base);
                    x2 = Math.max(vm.x, vm.base);
                    y1 = vm.y - half;
                    y2 = vm.y + half;
                }

                return {
                    left: x1,
                    top: y1,
                    right: x2,
                    bottom: y2
                };
            }

            function swap(orig, v1, v2) {
                return orig === v1 ? v2 : orig === v2 ? v1 : orig;
            }

            function parseBorderSkipped(vm) {
                var edge = vm.borderSkipped;
                var res = {};

                if (!edge) {
                    return res;
                }

                if (vm.horizontal) {
                    if (vm.base > vm.x) {
                        edge = swap(edge, 'left', 'right');
                    }
                } else if (vm.base < vm.y) {
                    edge = swap(edge, 'bottom', 'top');
                }

                res[edge] = true;
                return res;
            }

            function parseBorderWidth(vm, maxW, maxH) {
                var value = vm.borderWidth;
                var skip = parseBorderSkipped(vm);
                var t, r, b, l;

                if (helpers$1.isObject(value)) {
                    t = +value.top || 0;
                    r = +value.right || 0;
                    b = +value.bottom || 0;
                    l = +value.left || 0;
                } else {
                    t = r = b = l = +value || 0;
                }

                return {
                    t: skip.top || (t < 0) ? 0 : t > maxH ? maxH : t,
                    r: skip.right || (r < 0) ? 0 : r > maxW ? maxW : r,
                    b: skip.bottom || (b < 0) ? 0 : b > maxH ? maxH : b,
                    l: skip.left || (l < 0) ? 0 : l > maxW ? maxW : l
                };
            }

            function boundingRects(vm) {
                var bounds = getBarBounds(vm);
                var width = bounds.right - bounds.left;
                var height = bounds.bottom - bounds.top;
                var border = parseBorderWidth(vm, width / 2, height / 2);

                return {
                    outer: {
                        x: bounds.left,
                        y: bounds.top,
                        w: width,
                        h: height
                    },
                    inner: {
                        x: bounds.left + border.l,
                        y: bounds.top + border.t,
                        w: width - border.l - border.r,
                        h: height - border.t - border.b
                    }
                };
            }

            function inRange(vm, x, y) {
                var skipX = x === null;
                var skipY = y === null;
                var bounds = !vm || (skipX && skipY) ? false : getBarBounds(vm);

                return bounds
                    && (skipX || x >= bounds.left && x <= bounds.right)
                    && (skipY || y >= bounds.top && y <= bounds.bottom);
            }

            var element_rectangle = core_element.extend({
                _type: 'rectangle',

                draw: function() {
                    var ctx = this._chart.ctx;
                    var vm = this._view;
                    var rects = boundingRects(vm);
                    var outer = rects.outer;
                    var inner = rects.inner;

                    ctx.fillStyle = vm.backgroundColor;
                    ctx.fillRect(outer.x, outer.y, outer.w, outer.h);

                    if (outer.w === inner.w && outer.h === inner.h) {
                        return;
                    }

                    ctx.save();
                    ctx.beginPath();
                    ctx.rect(outer.x, outer.y, outer.w, outer.h);
                    ctx.clip();
                    ctx.fillStyle = vm.borderColor;
                    ctx.rect(inner.x, inner.y, inner.w, inner.h);
                    ctx.fill('evenodd');
                    ctx.restore();
                },

                height: function() {
                    var vm = this._view;
                    return vm.base - vm.y;
                },

                inRange: function(mouseX, mouseY) {
                    return inRange(this._view, mouseX, mouseY);
                },

                inLabelRange: function(mouseX, mouseY) {
                    var vm = this._view;
                    return isVertical(vm)
                        ? inRange(vm, mouseX, null)
                        : inRange(vm, null, mouseY);
                },

                inXRange: function(mouseX) {
                    return inRange(this._view, mouseX, null);
                },

                inYRange: function(mouseY) {
                    return inRange(this._view, null, mouseY);
                },

                getCenterPoint: function() {
                    var vm = this._view;
                    var x, y;
                    if (isVertical(vm)) {
                        x = vm.x;
                        y = (vm.y + vm.base) / 2;
                    } else {
                        x = (vm.x + vm.base) / 2;
                        y = vm.y;
                    }

                    return {x: x, y: y};
                },

                getArea: function() {
                    var vm = this._view;

                    return isVertical(vm)
                        ? vm.width * Math.abs(vm.y - vm.base)
                        : vm.height * Math.abs(vm.x - vm.base);
                },

                tooltipPosition: function() {
                    var vm = this._view;
                    return {
                        x: vm.x,
                        y: vm.y
                    };
                }
            });

            var elements = {};
            var Arc = element_arc;
            var Line = element_line;
            var Point = element_point;
            var Rectangle = element_rectangle;
            elements.Arc = Arc;
            elements.Line = Line;
            elements.Point = Point;
            elements.Rectangle = Rectangle;

            var deprecated = helpers$1._deprecated;
            var valueOrDefault$3 = helpers$1.valueOrDefault;

            core_defaults._set('bar', {
                hover: {
                    mode: 'label'
                },

                scales: {
                    xAxes: [{
                        type: 'category',
                        offset: true,
                        gridLines: {
                            offsetGridLines: true
                        }
                    }],

                    yAxes: [{
                        type: 'linear'
                    }]
                }
            });

            core_defaults._set('global', {
                datasets: {
                    bar: {
                        categoryPercentage: 0.8,
                        barPercentage: 0.9
                    }
                }
            });

            /**
             * Computes the "optimal" sample size to maintain bars equally sized while preventing overlap.
             * @private
             */
            function computeMinSampleSize(scale, pixels) {
                var min = scale._length;
                var prev, curr, i, ilen;

                for (i = 1, ilen = pixels.length; i < ilen; ++i) {
                    min = Math.min(min, Math.abs(pixels[i] - pixels[i - 1]));
                }

                for (i = 0, ilen = scale.getTicks().length; i < ilen; ++i) {
                    curr = scale.getPixelForTick(i);
                    min = i > 0 ? Math.min(min, Math.abs(curr - prev)) : min;
                    prev = curr;
                }

                return min;
            }

            /**
             * Computes an "ideal" category based on the absolute bar thickness or, if undefined or null,
             * uses the smallest interval (see computeMinSampleSize) that prevents bar overlapping. This
             * mode currently always generates bars equally sized (until we introduce scriptable options?).
             * @private
             */
            function computeFitCategoryTraits(index, ruler, options) {
                var thickness = options.barThickness;
                var count = ruler.stackCount;
                var curr = ruler.pixels[index];
                var min = helpers$1.isNullOrUndef(thickness)
                    ? computeMinSampleSize(ruler.scale, ruler.pixels)
                    : -1;
                var size, ratio;

                if (helpers$1.isNullOrUndef(thickness)) {
                    size = min * options.categoryPercentage;
                    ratio = options.barPercentage;
                } else {
                    // When bar thickness is enforced, category and bar percentages are ignored.
                    // Note(SB): we could add support for relative bar thickness (e.g. barThickness: '50%')
                    // and deprecate barPercentage since this value is ignored when thickness is absolute.
                    size = thickness * count;
                    ratio = 1;
                }

                return {
                    chunk: size / count,
                    ratio: ratio,
                    start: curr - (size / 2)
                };
            }

            /**
             * Computes an "optimal" category that globally arranges bars side by side (no gap when
             * percentage options are 1), based on the previous and following categories. This mode
             * generates bars with different widths when data are not evenly spaced.
             * @private
             */
            function computeFlexCategoryTraits(index, ruler, options) {
                var pixels = ruler.pixels;
                var curr = pixels[index];
                var prev = index > 0 ? pixels[index - 1] : null;
                var next = index < pixels.length - 1 ? pixels[index + 1] : null;
                var percent = options.categoryPercentage;
                var start, size;

                if (prev === null) {
                    // first data: its size is double based on the next point or,
                    // if it's also the last data, we use the scale size.
                    prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
                }

                if (next === null) {
                    // last data: its size is also double based on the previous point.
                    next = curr + curr - prev;
                }

                start = curr - (curr - Math.min(prev, next)) / 2 * percent;
                size = Math.abs(next - prev) / 2 * percent;

                return {
                    chunk: size / ruler.stackCount,
                    ratio: options.barPercentage,
                    start: start
                };
            }

            var controller_bar = core_datasetController.extend({

                dataElementType: elements.Rectangle,

                /**
                 * @private
                 */
                _dataElementOptions: [
                    'backgroundColor',
                    'borderColor',
                    'borderSkipped',
                    'borderWidth',
                    'barPercentage',
                    'barThickness',
                    'categoryPercentage',
                    'maxBarThickness',
                    'minBarLength'
                ],

                initialize: function() {
                    var me = this;
                    var meta, scaleOpts;

                    core_datasetController.prototype.initialize.apply(me, arguments);

                    meta = me.getMeta();
                    meta.stack = me.getDataset().stack;
                    meta.bar = true;

                    scaleOpts = me._getIndexScale().options;
                    deprecated('bar chart', scaleOpts.barPercentage, 'scales.[x/y]Axes.barPercentage', 'dataset.barPercentage');
                    deprecated('bar chart', scaleOpts.barThickness, 'scales.[x/y]Axes.barThickness', 'dataset.barThickness');
                    deprecated('bar chart', scaleOpts.categoryPercentage, 'scales.[x/y]Axes.categoryPercentage', 'dataset.categoryPercentage');
                    deprecated('bar chart', me._getValueScale().options.minBarLength, 'scales.[x/y]Axes.minBarLength', 'dataset.minBarLength');
                    deprecated('bar chart', scaleOpts.maxBarThickness, 'scales.[x/y]Axes.maxBarThickness', 'dataset.maxBarThickness');
                },

                update: function(reset) {
                    var me = this;
                    var rects = me.getMeta().data;
                    var i, ilen;

                    me._ruler = me.getRuler();

                    for (i = 0, ilen = rects.length; i < ilen; ++i) {
                        me.updateElement(rects[i], i, reset);
                    }
                },

                updateElement: function(rectangle, index, reset) {
                    var me = this;
                    var meta = me.getMeta();
                    var dataset = me.getDataset();
                    var options = me._resolveDataElementOptions(rectangle, index);

                    rectangle._xScale = me.getScaleForId(meta.xAxisID);
                    rectangle._yScale = me.getScaleForId(meta.yAxisID);
                    rectangle._datasetIndex = me.index;
                    rectangle._index = index;
                    rectangle._model = {
                        backgroundColor: options.backgroundColor,
                        borderColor: options.borderColor,
                        borderSkipped: options.borderSkipped,
                        borderWidth: options.borderWidth,
                        datasetLabel: dataset.label,
                        label: me.chart.data.labels[index]
                    };

                    if (helpers$1.isArray(dataset.data[index])) {
                        rectangle._model.borderSkipped = null;
                    }

                    me._updateElementGeometry(rectangle, index, reset, options);

                    rectangle.pivot();
                },

                /**
                 * @private
                 */
                _updateElementGeometry: function(rectangle, index, reset, options) {
                    var me = this;
                    var model = rectangle._model;
                    var vscale = me._getValueScale();
                    var base = vscale.getBasePixel();
                    var horizontal = vscale.isHorizontal();
                    var ruler = me._ruler || me.getRuler();
                    var vpixels = me.calculateBarValuePixels(me.index, index, options);
                    var ipixels = me.calculateBarIndexPixels(me.index, index, ruler, options);

                    model.horizontal = horizontal;
                    model.base = reset ? base : vpixels.base;
                    model.x = horizontal ? reset ? base : vpixels.head : ipixels.center;
                    model.y = horizontal ? ipixels.center : reset ? base : vpixels.head;
                    model.height = horizontal ? ipixels.size : undefined;
                    model.width = horizontal ? undefined : ipixels.size;
                },

                /**
                 * Returns the stacks based on groups and bar visibility.
                 * @param {number} [last] - The dataset index
                 * @returns {string[]} The list of stack IDs
                 * @private
                 */
                _getStacks: function(last) {
                    var me = this;
                    var scale = me._getIndexScale();
                    var metasets = scale._getMatchingVisibleMetas(me._type);
                    var stacked = scale.options.stacked;
                    var ilen = metasets.length;
                    var stacks = [];
                    var i, meta;

                    for (i = 0; i < ilen; ++i) {
                        meta = metasets[i];
                        // stacked   | meta.stack
                        //           | found | not found | undefined
                        // false     |   x   |     x     |     x
                        // true      |       |     x     |
                        // undefined |       |     x     |     x
                        if (stacked === false || stacks.indexOf(meta.stack) === -1 ||
                            (stacked === undefined && meta.stack === undefined)) {
                            stacks.push(meta.stack);
                        }
                        if (meta.index === last) {
                            break;
                        }
                    }

                    return stacks;
                },

                /**
                 * Returns the effective number of stacks based on groups and bar visibility.
                 * @private
                 */
                getStackCount: function() {
                    return this._getStacks().length;
                },

                /**
                 * Returns the stack index for the given dataset based on groups and bar visibility.
                 * @param {number} [datasetIndex] - The dataset index
                 * @param {string} [name] - The stack name to find
                 * @returns {number} The stack index
                 * @private
                 */
                getStackIndex: function(datasetIndex, name) {
                    var stacks = this._getStacks(datasetIndex);
                    var index = (name !== undefined)
                        ? stacks.indexOf(name)
                        : -1; // indexOf returns -1 if element is not present

                    return (index === -1)
                        ? stacks.length - 1
                        : index;
                },

                /**
                 * @private
                 */
                getRuler: function() {
                    var me = this;
                    var scale = me._getIndexScale();
                    var pixels = [];
                    var i, ilen;

                    for (i = 0, ilen = me.getMeta().data.length; i < ilen; ++i) {
                        pixels.push(scale.getPixelForValue(null, i, me.index));
                    }

                    return {
                        pixels: pixels,
                        start: scale._startPixel,
                        end: scale._endPixel,
                        stackCount: me.getStackCount(),
                        scale: scale
                    };
                },

                /**
                 * Note: pixel values are not clamped to the scale area.
                 * @private
                 */
                calculateBarValuePixels: function(datasetIndex, index, options) {
                    var me = this;
                    var chart = me.chart;
                    var scale = me._getValueScale();
                    var isHorizontal = scale.isHorizontal();
                    var datasets = chart.data.datasets;
                    var metasets = scale._getMatchingVisibleMetas(me._type);
                    var value = scale._parseValue(datasets[datasetIndex].data[index]);
                    var minBarLength = options.minBarLength;
                    var stacked = scale.options.stacked;
                    var stack = me.getMeta().stack;
                    var start = value.start === undefined ? 0 : value.max >= 0 && value.min >= 0 ? value.min : value.max;
                    var length = value.start === undefined ? value.end : value.max >= 0 && value.min >= 0 ? value.max - value.min : value.min - value.max;
                    var ilen = metasets.length;
                    var i, imeta, ivalue, base, head, size, stackLength;

                    if (stacked || (stacked === undefined && stack !== undefined)) {
                        for (i = 0; i < ilen; ++i) {
                            imeta = metasets[i];

                            if (imeta.index === datasetIndex) {
                                break;
                            }

                            if (imeta.stack === stack) {
                                stackLength = scale._parseValue(datasets[imeta.index].data[index]);
                                ivalue = stackLength.start === undefined ? stackLength.end : stackLength.min >= 0 && stackLength.max >= 0 ? stackLength.max : stackLength.min;

                                if ((value.min < 0 && ivalue < 0) || (value.max >= 0 && ivalue > 0)) {
                                    start += ivalue;
                                }
                            }
                        }
                    }

                    base = scale.getPixelForValue(start);
                    head = scale.getPixelForValue(start + length);
                    size = head - base;

                    if (minBarLength !== undefined && Math.abs(size) < minBarLength) {
                        size = minBarLength;
                        if (length >= 0 && !isHorizontal || length < 0 && isHorizontal) {
                            head = base - minBarLength;
                        } else {
                            head = base + minBarLength;
                        }
                    }

                    return {
                        size: size,
                        base: base,
                        head: head,
                        center: head + size / 2
                    };
                },

                /**
                 * @private
                 */
                calculateBarIndexPixels: function(datasetIndex, index, ruler, options) {
                    var me = this;
                    var range = options.barThickness === 'flex'
                        ? computeFlexCategoryTraits(index, ruler, options)
                        : computeFitCategoryTraits(index, ruler, options);

                    var stackIndex = me.getStackIndex(datasetIndex, me.getMeta().stack);
                    var center = range.start + (range.chunk * stackIndex) + (range.chunk / 2);
                    var size = Math.min(
                        valueOrDefault$3(options.maxBarThickness, Infinity),
                        range.chunk * range.ratio);

                    return {
                        base: center - size / 2,
                        head: center + size / 2,
                        center: center,
                        size: size
                    };
                },

                draw: function() {
                    var me = this;
                    var chart = me.chart;
                    var scale = me._getValueScale();
                    var rects = me.getMeta().data;
                    var dataset = me.getDataset();
                    var ilen = rects.length;
                    var i = 0;

                    helpers$1.canvas.clipArea(chart.ctx, chart.chartArea);

                    for (; i < ilen; ++i) {
                        var val = scale._parseValue(dataset.data[i]);
                        if (!isNaN(val.min) && !isNaN(val.max)) {
                            rects[i].draw();
                        }
                    }

                    helpers$1.canvas.unclipArea(chart.ctx);
                },

                /**
                 * @private
                 */
                _resolveDataElementOptions: function() {
                    var me = this;
                    var values = helpers$1.extend({}, core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments));
                    var indexOpts = me._getIndexScale().options;
                    var valueOpts = me._getValueScale().options;

                    values.barPercentage = valueOrDefault$3(indexOpts.barPercentage, values.barPercentage);
                    values.barThickness = valueOrDefault$3(indexOpts.barThickness, values.barThickness);
                    values.categoryPercentage = valueOrDefault$3(indexOpts.categoryPercentage, values.categoryPercentage);
                    values.maxBarThickness = valueOrDefault$3(indexOpts.maxBarThickness, values.maxBarThickness);
                    values.minBarLength = valueOrDefault$3(valueOpts.minBarLength, values.minBarLength);

                    return values;
                }

            });

            var valueOrDefault$4 = helpers$1.valueOrDefault;
            var resolve$1 = helpers$1.options.resolve;

            core_defaults._set('bubble', {
                hover: {
                    mode: 'single'
                },

                scales: {
                    xAxes: [{
                        type: 'linear', // bubble should probably use a linear scale by default
                        position: 'bottom',
                        id: 'x-axis-0' // need an ID so datasets can reference the scale
                    }],
                    yAxes: [{
                        type: 'linear',
                        position: 'left',
                        id: 'y-axis-0'
                    }]
                },

                tooltips: {
                    callbacks: {
                        title: function() {
                            // Title doesn't make sense for scatter since we format the data as a point
                            return '';
                        },
                        label: function(item, data) {
                            var datasetLabel = data.datasets[item.datasetIndex].label || '';
                            var dataPoint = data.datasets[item.datasetIndex].data[item.index];
                            return datasetLabel + ': (' + item.xLabel + ', ' + item.yLabel + ', ' + dataPoint.r + ')';
                        }
                    }
                }
            });

            var controller_bubble = core_datasetController.extend({
                /**
                 * @protected
                 */
                dataElementType: elements.Point,

                /**
                 * @private
                 */
                _dataElementOptions: [
                    'backgroundColor',
                    'borderColor',
                    'borderWidth',
                    'hoverBackgroundColor',
                    'hoverBorderColor',
                    'hoverBorderWidth',
                    'hoverRadius',
                    'hitRadius',
                    'pointStyle',
                    'rotation'
                ],

                /**
                 * @protected
                 */
                update: function(reset) {
                    var me = this;
                    var meta = me.getMeta();
                    var points = meta.data;

                    // Update Points
                    helpers$1.each(points, function(point, index) {
                        me.updateElement(point, index, reset);
                    });
                },

                /**
                 * @protected
                 */
                updateElement: function(point, index, reset) {
                    var me = this;
                    var meta = me.getMeta();
                    var custom = point.custom || {};
                    var xScale = me.getScaleForId(meta.xAxisID);
                    var yScale = me.getScaleForId(meta.yAxisID);
                    var options = me._resolveDataElementOptions(point, index);
                    var data = me.getDataset().data[index];
                    var dsIndex = me.index;

                    var x = reset ? xScale.getPixelForDecimal(0.5) : xScale.getPixelForValue(typeof data === 'object' ? data : NaN, index, dsIndex);
                    var y = reset ? yScale.getBasePixel() : yScale.getPixelForValue(data, index, dsIndex);

                    point._xScale = xScale;
                    point._yScale = yScale;
                    point._options = options;
                    point._datasetIndex = dsIndex;
                    point._index = index;
                    point._model = {
                        backgroundColor: options.backgroundColor,
                        borderColor: options.borderColor,
                        borderWidth: options.borderWidth,
                        hitRadius: options.hitRadius,
                        pointStyle: options.pointStyle,
                        rotation: options.rotation,
                        radius: reset ? 0 : options.radius,
                        skip: custom.skip || isNaN(x) || isNaN(y),
                        x: x,
                        y: y,
                    };

                    point.pivot();
                },

                /**
                 * @protected
                 */
                setHoverStyle: function(point) {
                    var model = point._model;
                    var options = point._options;
                    var getHoverColor = helpers$1.getHoverColor;

                    point.$previousStyle = {
                        backgroundColor: model.backgroundColor,
                        borderColor: model.borderColor,
                        borderWidth: model.borderWidth,
                        radius: model.radius
                    };

                    model.backgroundColor = valueOrDefault$4(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                    model.borderColor = valueOrDefault$4(options.hoverBorderColor, getHoverColor(options.borderColor));
                    model.borderWidth = valueOrDefault$4(options.hoverBorderWidth, options.borderWidth);
                    model.radius = options.radius + options.hoverRadius;
                },

                /**
                 * @private
                 */
                _resolveDataElementOptions: function(point, index) {
                    var me = this;
                    var chart = me.chart;
                    var dataset = me.getDataset();
                    var custom = point.custom || {};
                    var data = dataset.data[index] || {};
                    var values = core_datasetController.prototype._resolveDataElementOptions.apply(me, arguments);

                    // Scriptable options
                    var context = {
                        chart: chart,
                        dataIndex: index,
                        dataset: dataset,
                        datasetIndex: me.index
                    };

                    // In case values were cached (and thus frozen), we need to clone the values
                    if (me._cachedDataOpts === values) {
                        values = helpers$1.extend({}, values);
                    }

                    // Custom radius resolution
                    values.radius = resolve$1([
                        custom.radius,
                        data.r,
                        me._config.radius,
                        chart.options.elements.point.radius
                    ], context, index);

                    return values;
                }
            });

            var valueOrDefault$5 = helpers$1.valueOrDefault;

            var PI$1 = Math.PI;
            var DOUBLE_PI$1 = PI$1 * 2;
            var HALF_PI$1 = PI$1 / 2;

            core_defaults._set('doughnut', {
                animation: {
                    // Boolean - Whether we animate the rotation of the Doughnut
                    animateRotate: true,
                    // Boolean - Whether we animate scaling the Doughnut from the centre
                    animateScale: false
                },
                hover: {
                    mode: 'single'
                },
                legendCallback: function(chart) {
                    var list = document.createElement('ul');
                    var data = chart.data;
                    var datasets = data.datasets;
                    var labels = data.labels;
                    var i, ilen, listItem, listItemSpan;

                    list.setAttribute('class', chart.id + '-legend');
                    if (datasets.length) {
                        for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                            listItem = list.appendChild(document.createElement('li'));
                            listItemSpan = listItem.appendChild(document.createElement('span'));
                            listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                            if (labels[i]) {
                                listItem.appendChild(document.createTextNode(labels[i]));
                            }
                        }
                    }

                    return list.outerHTML;
                },
                legend: {
                    labels: {
                        generateLabels: function(chart) {
                            var data = chart.data;
                            if (data.labels.length && data.datasets.length) {
                                return data.labels.map(function(label, i) {
                                    var meta = chart.getDatasetMeta(0);
                                    var style = meta.controller.getStyle(i);

                                    return {
                                        text: label,
                                        fillStyle: style.backgroundColor,
                                        strokeStyle: style.borderColor,
                                        lineWidth: style.borderWidth,
                                        hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,

                                        // Extra data used for toggling the correct item
                                        index: i
                                    };
                                });
                            }
                            return [];
                        }
                    },

                    onClick: function(e, legendItem) {
                        var index = legendItem.index;
                        var chart = this.chart;
                        var i, ilen, meta;

                        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                            meta = chart.getDatasetMeta(i);
                            // toggle visibility of index if exists
                            if (meta.data[index]) {
                                meta.data[index].hidden = !meta.data[index].hidden;
                            }
                        }

                        chart.update();
                    }
                },

                // The percentage of the chart that we cut out of the middle.
                cutoutPercentage: 50,

                // The rotation of the chart, where the first data arc begins.
                rotation: -HALF_PI$1,

                // The total circumference of the chart.
                circumference: DOUBLE_PI$1,

                // Need to override these to give a nice default
                tooltips: {
                    callbacks: {
                        title: function() {
                            return '';
                        },
                        label: function(tooltipItem, data) {
                            var dataLabel = data.labels[tooltipItem.index];
                            var value = ': ' + data.datasets[tooltipItem.datasetIndex].data[tooltipItem.index];

                            if (helpers$1.isArray(dataLabel)) {
                                // show value on first line of multiline label
                                // need to clone because we are changing the value
                                dataLabel = dataLabel.slice();
                                dataLabel[0] += value;
                            } else {
                                dataLabel += value;
                            }

                            return dataLabel;
                        }
                    }
                }
            });

            var controller_doughnut = core_datasetController.extend({

                dataElementType: elements.Arc,

                linkScales: helpers$1.noop,

                /**
                 * @private
                 */
                _dataElementOptions: [
                    'backgroundColor',
                    'borderColor',
                    'borderWidth',
                    'borderAlign',
                    'hoverBackgroundColor',
                    'hoverBorderColor',
                    'hoverBorderWidth',
                ],

                // Get index of the dataset in relation to the visible datasets. This allows determining the inner and outer radius correctly
                getRingIndex: function(datasetIndex) {
                    var ringIndex = 0;

                    for (var j = 0; j < datasetIndex; ++j) {
                        if (this.chart.isDatasetVisible(j)) {
                            ++ringIndex;
                        }
                    }

                    return ringIndex;
                },

                update: function(reset) {
                    var me = this;
                    var chart = me.chart;
                    var chartArea = chart.chartArea;
                    var opts = chart.options;
                    var ratioX = 1;
                    var ratioY = 1;
                    var offsetX = 0;
                    var offsetY = 0;
                    var meta = me.getMeta();
                    var arcs = meta.data;
                    var cutout = opts.cutoutPercentage / 100 || 0;
                    var circumference = opts.circumference;
                    var chartWeight = me._getRingWeight(me.index);
                    var maxWidth, maxHeight, i, ilen;

                    // If the chart's circumference isn't a full circle, calculate size as a ratio of the width/height of the arc
                    if (circumference < DOUBLE_PI$1) {
                        var startAngle = opts.rotation % DOUBLE_PI$1;
                        startAngle += startAngle >= PI$1 ? -DOUBLE_PI$1 : startAngle < -PI$1 ? DOUBLE_PI$1 : 0;
                        var endAngle = startAngle + circumference;
                        var startX = Math.cos(startAngle);
                        var startY = Math.sin(startAngle);
                        var endX = Math.cos(endAngle);
                        var endY = Math.sin(endAngle);
                        var contains0 = (startAngle <= 0 && endAngle >= 0) || endAngle >= DOUBLE_PI$1;
                        var contains90 = (startAngle <= HALF_PI$1 && endAngle >= HALF_PI$1) || endAngle >= DOUBLE_PI$1 + HALF_PI$1;
                        var contains180 = startAngle === -PI$1 || endAngle >= PI$1;
                        var contains270 = (startAngle <= -HALF_PI$1 && endAngle >= -HALF_PI$1) || endAngle >= PI$1 + HALF_PI$1;
                        var minX = contains180 ? -1 : Math.min(startX, startX * cutout, endX, endX * cutout);
                        var minY = contains270 ? -1 : Math.min(startY, startY * cutout, endY, endY * cutout);
                        var maxX = contains0 ? 1 : Math.max(startX, startX * cutout, endX, endX * cutout);
                        var maxY = contains90 ? 1 : Math.max(startY, startY * cutout, endY, endY * cutout);
                        ratioX = (maxX - minX) / 2;
                        ratioY = (maxY - minY) / 2;
                        offsetX = -(maxX + minX) / 2;
                        offsetY = -(maxY + minY) / 2;
                    }

                    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                        arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
                    }

                    chart.borderWidth = me.getMaxBorderWidth();
                    maxWidth = (chartArea.right - chartArea.left - chart.borderWidth) / ratioX;
                    maxHeight = (chartArea.bottom - chartArea.top - chart.borderWidth) / ratioY;
                    chart.outerRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
                    chart.innerRadius = Math.max(chart.outerRadius * cutout, 0);
                    chart.radiusLength = (chart.outerRadius - chart.innerRadius) / (me._getVisibleDatasetWeightTotal() || 1);
                    chart.offsetX = offsetX * chart.outerRadius;
                    chart.offsetY = offsetY * chart.outerRadius;

                    meta.total = me.calculateTotal();

                    me.outerRadius = chart.outerRadius - chart.radiusLength * me._getRingWeightOffset(me.index);
                    me.innerRadius = Math.max(me.outerRadius - chart.radiusLength * chartWeight, 0);

                    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                        me.updateElement(arcs[i], i, reset);
                    }
                },

                updateElement: function(arc, index, reset) {
                    var me = this;
                    var chart = me.chart;
                    var chartArea = chart.chartArea;
                    var opts = chart.options;
                    var animationOpts = opts.animation;
                    var centerX = (chartArea.left + chartArea.right) / 2;
                    var centerY = (chartArea.top + chartArea.bottom) / 2;
                    var startAngle = opts.rotation; // non reset case handled later
                    var endAngle = opts.rotation; // non reset case handled later
                    var dataset = me.getDataset();
                    var circumference = reset && animationOpts.animateRotate ? 0 : arc.hidden ? 0 : me.calculateCircumference(dataset.data[index]) * (opts.circumference / DOUBLE_PI$1);
                    var innerRadius = reset && animationOpts.animateScale ? 0 : me.innerRadius;
                    var outerRadius = reset && animationOpts.animateScale ? 0 : me.outerRadius;
                    var options = arc._options || {};

                    helpers$1.extend(arc, {
                        // Utility
                        _datasetIndex: me.index,
                        _index: index,

                        // Desired view properties
                        _model: {
                            backgroundColor: options.backgroundColor,
                            borderColor: options.borderColor,
                            borderWidth: options.borderWidth,
                            borderAlign: options.borderAlign,
                            x: centerX + chart.offsetX,
                            y: centerY + chart.offsetY,
                            startAngle: startAngle,
                            endAngle: endAngle,
                            circumference: circumference,
                            outerRadius: outerRadius,
                            innerRadius: innerRadius,
                            label: helpers$1.valueAtIndexOrDefault(dataset.label, index, chart.data.labels[index])
                        }
                    });

                    var model = arc._model;

                    // Set correct angles if not resetting
                    if (!reset || !animationOpts.animateRotate) {
                        if (index === 0) {
                            model.startAngle = opts.rotation;
                        } else {
                            model.startAngle = me.getMeta().data[index - 1]._model.endAngle;
                        }

                        model.endAngle = model.startAngle + model.circumference;
                    }

                    arc.pivot();
                },

                calculateTotal: function() {
                    var dataset = this.getDataset();
                    var meta = this.getMeta();
                    var total = 0;
                    var value;

                    helpers$1.each(meta.data, function(element, index) {
                        value = dataset.data[index];
                        if (!isNaN(value) && !element.hidden) {
                            total += Math.abs(value);
                        }
                    });

                    /* if (total === 0) {
				total = NaN;
			}*/

                    return total;
                },

                calculateCircumference: function(value) {
                    var total = this.getMeta().total;
                    if (total > 0 && !isNaN(value)) {
                        return DOUBLE_PI$1 * (Math.abs(value) / total);
                    }
                    return 0;
                },

                // gets the max border or hover width to properly scale pie charts
                getMaxBorderWidth: function(arcs) {
                    var me = this;
                    var max = 0;
                    var chart = me.chart;
                    var i, ilen, meta, arc, controller, options, borderWidth, hoverWidth;

                    if (!arcs) {
                        // Find the outmost visible dataset
                        for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                            if (chart.isDatasetVisible(i)) {
                                meta = chart.getDatasetMeta(i);
                                arcs = meta.data;
                                if (i !== me.index) {
                                    controller = meta.controller;
                                }
                                break;
                            }
                        }
                    }

                    if (!arcs) {
                        return 0;
                    }

                    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                        arc = arcs[i];
                        if (controller) {
                            controller._configure();
                            options = controller._resolveDataElementOptions(arc, i);
                        } else {
                            options = arc._options;
                        }
                        if (options.borderAlign !== 'inner') {
                            borderWidth = options.borderWidth;
                            hoverWidth = options.hoverBorderWidth;

                            max = borderWidth > max ? borderWidth : max;
                            max = hoverWidth > max ? hoverWidth : max;
                        }
                    }
                    return max;
                },

                /**
                 * @protected
                 */
                setHoverStyle: function(arc) {
                    var model = arc._model;
                    var options = arc._options;
                    var getHoverColor = helpers$1.getHoverColor;

                    arc.$previousStyle = {
                        backgroundColor: model.backgroundColor,
                        borderColor: model.borderColor,
                        borderWidth: model.borderWidth,
                    };

                    model.backgroundColor = valueOrDefault$5(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                    model.borderColor = valueOrDefault$5(options.hoverBorderColor, getHoverColor(options.borderColor));
                    model.borderWidth = valueOrDefault$5(options.hoverBorderWidth, options.borderWidth);
                },

                /**
                 * Get radius length offset of the dataset in relation to the visible datasets weights. This allows determining the inner and outer radius correctly
                 * @private
                 */
                _getRingWeightOffset: function(datasetIndex) {
                    var ringWeightOffset = 0;

                    for (var i = 0; i < datasetIndex; ++i) {
                        if (this.chart.isDatasetVisible(i)) {
                            ringWeightOffset += this._getRingWeight(i);
                        }
                    }

                    return ringWeightOffset;
                },

                /**
                 * @private
                 */
                _getRingWeight: function(dataSetIndex) {
                    return Math.max(valueOrDefault$5(this.chart.data.datasets[dataSetIndex].weight, 1), 0);
                },

                /**
                 * Returns the sum of all visibile data set weights.  This value can be 0.
                 * @private
                 */
                _getVisibleDatasetWeightTotal: function() {
                    return this._getRingWeightOffset(this.chart.data.datasets.length);
                }
            });

            core_defaults._set('horizontalBar', {
                hover: {
                    mode: 'index',
                    axis: 'y'
                },

                scales: {
                    xAxes: [{
                        type: 'linear',
                        position: 'bottom'
                    }],

                    yAxes: [{
                        type: 'category',
                        position: 'left',
                        offset: true,
                        gridLines: {
                            offsetGridLines: true
                        }
                    }]
                },

                elements: {
                    rectangle: {
                        borderSkipped: 'left'
                    }
                },

                tooltips: {
                    mode: 'index',
                    axis: 'y'
                }
            });

            core_defaults._set('global', {
                datasets: {
                    horizontalBar: {
                        categoryPercentage: 0.8,
                        barPercentage: 0.9
                    }
                }
            });

            var controller_horizontalBar = controller_bar.extend({
                /**
                 * @private
                 */
                _getValueScaleId: function() {
                    return this.getMeta().xAxisID;
                },

                /**
                 * @private
                 */
                _getIndexScaleId: function() {
                    return this.getMeta().yAxisID;
                }
            });

            var valueOrDefault$6 = helpers$1.valueOrDefault;
            var resolve$2 = helpers$1.options.resolve;
            var isPointInArea = helpers$1.canvas._isPointInArea;

            core_defaults._set('line', {
                showLines: true,
                spanGaps: false,

                hover: {
                    mode: 'label'
                },

                scales: {
                    xAxes: [{
                        type: 'category',
                        id: 'x-axis-0'
                    }],
                    yAxes: [{
                        type: 'linear',
                        id: 'y-axis-0'
                    }]
                }
            });

            function scaleClip(scale, halfBorderWidth) {
                var tickOpts = scale && scale.options.ticks || {};
                var reverse = tickOpts.reverse;
                var min = tickOpts.min === undefined ? halfBorderWidth : 0;
                var max = tickOpts.max === undefined ? halfBorderWidth : 0;
                return {
                    start: reverse ? max : min,
                    end: reverse ? min : max
                };
            }

            function defaultClip(xScale, yScale, borderWidth) {
                var halfBorderWidth = borderWidth / 2;
                var x = scaleClip(xScale, halfBorderWidth);
                var y = scaleClip(yScale, halfBorderWidth);

                return {
                    top: y.end,
                    right: x.end,
                    bottom: y.start,
                    left: x.start
                };
            }

            function toClip(value) {
                var t, r, b, l;

                if (helpers$1.isObject(value)) {
                    t = value.top;
                    r = value.right;
                    b = value.bottom;
                    l = value.left;
                } else {
                    t = r = b = l = value;
                }

                return {
                    top: t,
                    right: r,
                    bottom: b,
                    left: l
                };
            }


            var controller_line = core_datasetController.extend({

                datasetElementType: elements.Line,

                dataElementType: elements.Point,

                /**
                 * @private
                 */
                _datasetElementOptions: [
                    'backgroundColor',
                    'borderCapStyle',
                    'borderColor',
                    'borderDash',
                    'borderDashOffset',
                    'borderJoinStyle',
                    'borderWidth',
                    'cubicInterpolationMode',
                    'fill'
                ],

                /**
                 * @private
                 */
                _dataElementOptions: {
                    backgroundColor: 'pointBackgroundColor',
                    borderColor: 'pointBorderColor',
                    borderWidth: 'pointBorderWidth',
                    hitRadius: 'pointHitRadius',
                    hoverBackgroundColor: 'pointHoverBackgroundColor',
                    hoverBorderColor: 'pointHoverBorderColor',
                    hoverBorderWidth: 'pointHoverBorderWidth',
                    hoverRadius: 'pointHoverRadius',
                    pointStyle: 'pointStyle',
                    radius: 'pointRadius',
                    rotation: 'pointRotation'
                },

                update: function(reset) {
                    var me = this;
                    var meta = me.getMeta();
                    var line = meta.dataset;
                    var points = meta.data || [];
                    var options = me.chart.options;
                    var config = me._config;
                    var showLine = me._showLine = valueOrDefault$6(config.showLine, options.showLines);
                    var i, ilen;

                    me._xScale = me.getScaleForId(meta.xAxisID);
                    me._yScale = me.getScaleForId(meta.yAxisID);

                    // Update Line
                    if (showLine) {
                        // Compatibility: If the properties are defined with only the old name, use those values
                        if (config.tension !== undefined && config.lineTension === undefined) {
                            config.lineTension = config.tension;
                        }

                        // Utility
                        line._scale = me._yScale;
                        line._datasetIndex = me.index;
                        // Data
                        line._children = points;
                        // Model
                        line._model = me._resolveDatasetElementOptions(line);

                        line.pivot();
                    }

                    // Update Points
                    for (i = 0, ilen = points.length; i < ilen; ++i) {
                        me.updateElement(points[i], i, reset);
                    }

                    if (showLine && line._model.tension !== 0) {
                        me.updateBezierControlPoints();
                    }

                    // Now pivot the point for animation
                    for (i = 0, ilen = points.length; i < ilen; ++i) {
                        points[i].pivot();
                    }
                },

                updateElement: function(point, index, reset) {
                    var me = this;
                    var meta = me.getMeta();
                    var custom = point.custom || {};
                    var dataset = me.getDataset();
                    var datasetIndex = me.index;
                    var value = dataset.data[index];
                    var xScale = me._xScale;
                    var yScale = me._yScale;
                    var lineModel = meta.dataset._model;
                    var x, y;

                    var options = me._resolveDataElementOptions(point, index);

                    x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);
                    y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);

                    // Utility
                    point._xScale = xScale;
                    point._yScale = yScale;
                    point._options = options;
                    point._datasetIndex = datasetIndex;
                    point._index = index;

                    // Desired view properties
                    point._model = {
                        x: x,
                        y: y,
                        skip: custom.skip || isNaN(x) || isNaN(y),
                        // Appearance
                        radius: options.radius,
                        pointStyle: options.pointStyle,
                        rotation: options.rotation,
                        backgroundColor: options.backgroundColor,
                        borderColor: options.borderColor,
                        borderWidth: options.borderWidth,
                        tension: valueOrDefault$6(custom.tension, lineModel ? lineModel.tension : 0),
                        steppedLine: lineModel ? lineModel.steppedLine : false,
                        // Tooltip
                        hitRadius: options.hitRadius
                    };
                },

                /**
                 * @private
                 */
                _resolveDatasetElementOptions: function(element) {
                    var me = this;
                    var config = me._config;
                    var custom = element.custom || {};
                    var options = me.chart.options;
                    var lineOptions = options.elements.line;
                    var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);

                    // The default behavior of lines is to break at null values, according
                    // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158
                    // This option gives lines the ability to span gaps
                    values.spanGaps = valueOrDefault$6(config.spanGaps, options.spanGaps);
                    values.tension = valueOrDefault$6(config.lineTension, lineOptions.tension);
                    values.steppedLine = resolve$2([custom.steppedLine, config.steppedLine, lineOptions.stepped]);
                    values.clip = toClip(valueOrDefault$6(config.clip, defaultClip(me._xScale, me._yScale, values.borderWidth)));

                    return values;
                },

                calculatePointY: function(value, index, datasetIndex) {
                    var me = this;
                    var chart = me.chart;
                    var yScale = me._yScale;
                    var sumPos = 0;
                    var sumNeg = 0;
                    var i, ds, dsMeta, stackedRightValue, rightValue, metasets, ilen;

                    if (yScale.options.stacked) {
                        rightValue = +yScale.getRightValue(value);
                        metasets = chart._getSortedVisibleDatasetMetas();
                        ilen = metasets.length;

                        for (i = 0; i < ilen; ++i) {
                            dsMeta = metasets[i];
                            if (dsMeta.index === datasetIndex) {
                                break;
                            }

                            ds = chart.data.datasets[dsMeta.index];
                            if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id) {
                                stackedRightValue = +yScale.getRightValue(ds.data[index]);
                                if (stackedRightValue < 0) {
                                    sumNeg += stackedRightValue || 0;
                                } else {
                                    sumPos += stackedRightValue || 0;
                                }
                            }
                        }

                        if (rightValue < 0) {
                            return yScale.getPixelForValue(sumNeg + rightValue);
                        }
                        return yScale.getPixelForValue(sumPos + rightValue);
                    }
                    return yScale.getPixelForValue(value);
                },

                updateBezierControlPoints: function() {
                    var me = this;
                    var chart = me.chart;
                    var meta = me.getMeta();
                    var lineModel = meta.dataset._model;
                    var area = chart.chartArea;
                    var points = meta.data || [];
                    var i, ilen, model, controlPoints;

                    // Only consider points that are drawn in case the spanGaps option is used
                    if (lineModel.spanGaps) {
                        points = points.filter(function(pt) {
                            return !pt._model.skip;
                        });
                    }

                    function capControlPoint(pt, min, max) {
                        return Math.max(Math.min(pt, max), min);
                    }

                    if (lineModel.cubicInterpolationMode === 'monotone') {
                        helpers$1.splineCurveMonotone(points);
                    } else {
                        for (i = 0, ilen = points.length; i < ilen; ++i) {
                            model = points[i]._model;
                            controlPoints = helpers$1.splineCurve(
                                helpers$1.previousItem(points, i)._model,
                                model,
                                helpers$1.nextItem(points, i)._model,
                                lineModel.tension
                            );
                            model.controlPointPreviousX = controlPoints.previous.x;
                            model.controlPointPreviousY = controlPoints.previous.y;
                            model.controlPointNextX = controlPoints.next.x;
                            model.controlPointNextY = controlPoints.next.y;
                        }
                    }

                    if (chart.options.elements.line.capBezierPoints) {
                        for (i = 0, ilen = points.length; i < ilen; ++i) {
                            model = points[i]._model;
                            if (isPointInArea(model, area)) {
                                if (i > 0 && isPointInArea(points[i - 1]._model, area)) {
                                    model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);
                                    model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);
                                }
                                if (i < points.length - 1 && isPointInArea(points[i + 1]._model, area)) {
                                    model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);
                                    model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);
                                }
                            }
                        }
                    }
                },

                draw: function() {
                    var me = this;
                    var chart = me.chart;
                    var meta = me.getMeta();
                    var points = meta.data || [];
                    var area = chart.chartArea;
                    var canvas = chart.canvas;
                    var i = 0;
                    var ilen = points.length;
                    var clip;

                    if (me._showLine) {
                        clip = meta.dataset._model.clip;

                        helpers$1.canvas.clipArea(chart.ctx, {
                            left: clip.left === false ? 0 : area.left - clip.left,
                            right: clip.right === false ? canvas.width : area.right + clip.right,
                            top: clip.top === false ? 0 : area.top - clip.top,
                            bottom: clip.bottom === false ? canvas.height : area.bottom + clip.bottom
                        });

                        meta.dataset.draw();

                        helpers$1.canvas.unclipArea(chart.ctx);
                    }

                    // Draw the points
                    for (; i < ilen; ++i) {
                        points[i].draw(area);
                    }
                },

                /**
                 * @protected
                 */
                setHoverStyle: function(point) {
                    var model = point._model;
                    var options = point._options;
                    var getHoverColor = helpers$1.getHoverColor;

                    point.$previousStyle = {
                        backgroundColor: model.backgroundColor,
                        borderColor: model.borderColor,
                        borderWidth: model.borderWidth,
                        radius: model.radius
                    };

                    model.backgroundColor = valueOrDefault$6(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                    model.borderColor = valueOrDefault$6(options.hoverBorderColor, getHoverColor(options.borderColor));
                    model.borderWidth = valueOrDefault$6(options.hoverBorderWidth, options.borderWidth);
                    model.radius = valueOrDefault$6(options.hoverRadius, options.radius);
                },
            });

            var resolve$3 = helpers$1.options.resolve;

            core_defaults._set('polarArea', {
                scale: {
                    type: 'radialLinear',
                    angleLines: {
                        display: false
                    },
                    gridLines: {
                        circular: true
                    },
                    pointLabels: {
                        display: false
                    },
                    ticks: {
                        beginAtZero: true
                    }
                },

                // Boolean - Whether to animate the rotation of the chart
                animation: {
                    animateRotate: true,
                    animateScale: true
                },

                startAngle: -0.5 * Math.PI,
                legendCallback: function(chart) {
                    var list = document.createElement('ul');
                    var data = chart.data;
                    var datasets = data.datasets;
                    var labels = data.labels;
                    var i, ilen, listItem, listItemSpan;

                    list.setAttribute('class', chart.id + '-legend');
                    if (datasets.length) {
                        for (i = 0, ilen = datasets[0].data.length; i < ilen; ++i) {
                            listItem = list.appendChild(document.createElement('li'));
                            listItemSpan = listItem.appendChild(document.createElement('span'));
                            listItemSpan.style.backgroundColor = datasets[0].backgroundColor[i];
                            if (labels[i]) {
                                listItem.appendChild(document.createTextNode(labels[i]));
                            }
                        }
                    }

                    return list.outerHTML;
                },
                legend: {
                    labels: {
                        generateLabels: function(chart) {
                            var data = chart.data;
                            if (data.labels.length && data.datasets.length) {
                                return data.labels.map(function(label, i) {
                                    var meta = chart.getDatasetMeta(0);
                                    var style = meta.controller.getStyle(i);

                                    return {
                                        text: label,
                                        fillStyle: style.backgroundColor,
                                        strokeStyle: style.borderColor,
                                        lineWidth: style.borderWidth,
                                        hidden: isNaN(data.datasets[0].data[i]) || meta.data[i].hidden,

                                        // Extra data used for toggling the correct item
                                        index: i
                                    };
                                });
                            }
                            return [];
                        }
                    },

                    onClick: function(e, legendItem) {
                        var index = legendItem.index;
                        var chart = this.chart;
                        var i, ilen, meta;

                        for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                            meta = chart.getDatasetMeta(i);
                            meta.data[index].hidden = !meta.data[index].hidden;
                        }

                        chart.update();
                    }
                },

                // Need to override these to give a nice default
                tooltips: {
                    callbacks: {
                        title: function() {
                            return '';
                        },
                        label: function(item, data) {
                            return data.labels[item.index] + ': ' + item.yLabel;
                        }
                    }
                }
            });

            var controller_polarArea = core_datasetController.extend({

                dataElementType: elements.Arc,

                linkScales: helpers$1.noop,

                /**
                 * @private
                 */
                _dataElementOptions: [
                    'backgroundColor',
                    'borderColor',
                    'borderWidth',
                    'borderAlign',
                    'hoverBackgroundColor',
                    'hoverBorderColor',
                    'hoverBorderWidth',
                ],

                /**
                 * @private
                 */
                _getIndexScaleId: function() {
                    return this.chart.scale.id;
                },

                /**
                 * @private
                 */
                _getValueScaleId: function() {
                    return this.chart.scale.id;
                },

                update: function(reset) {
                    var me = this;
                    var dataset = me.getDataset();
                    var meta = me.getMeta();
                    var start = me.chart.options.startAngle || 0;
                    var starts = me._starts = [];
                    var angles = me._angles = [];
                    var arcs = meta.data;
                    var i, ilen, angle;

                    me._updateRadius();

                    meta.count = me.countVisibleElements();

                    for (i = 0, ilen = dataset.data.length; i < ilen; i++) {
                        starts[i] = start;
                        angle = me._computeAngle(i);
                        angles[i] = angle;
                        start += angle;
                    }

                    for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                        arcs[i]._options = me._resolveDataElementOptions(arcs[i], i);
                        me.updateElement(arcs[i], i, reset);
                    }
                },

                /**
                 * @private
                 */
                _updateRadius: function() {
                    var me = this;
                    var chart = me.chart;
                    var chartArea = chart.chartArea;
                    var opts = chart.options;
                    var minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);

                    chart.outerRadius = Math.max(minSize / 2, 0);
                    chart.innerRadius = Math.max(opts.cutoutPercentage ? (chart.outerRadius / 100) * (opts.cutoutPercentage) : 1, 0);
                    chart.radiusLength = (chart.outerRadius - chart.innerRadius) / chart.getVisibleDatasetCount();

                    me.outerRadius = chart.outerRadius - (chart.radiusLength * me.index);
                    me.innerRadius = me.outerRadius - chart.radiusLength;
                },

                updateElement: function(arc, index, reset) {
                    var me = this;
                    var chart = me.chart;
                    var dataset = me.getDataset();
                    var opts = chart.options;
                    var animationOpts = opts.animation;
                    var scale = chart.scale;
                    var labels = chart.data.labels;

                    var centerX = scale.xCenter;
                    var centerY = scale.yCenter;

                    // var negHalfPI = -0.5 * Math.PI;
                    var datasetStartAngle = opts.startAngle;
                    var distance = arc.hidden ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
                    var startAngle = me._starts[index];
                    var endAngle = startAngle + (arc.hidden ? 0 : me._angles[index]);

                    var resetRadius = animationOpts.animateScale ? 0 : scale.getDistanceFromCenterForValue(dataset.data[index]);
                    var options = arc._options || {};

                    helpers$1.extend(arc, {
                        // Utility
                        _datasetIndex: me.index,
                        _index: index,
                        _scale: scale,

                        // Desired view properties
                        _model: {
                            backgroundColor: options.backgroundColor,
                            borderColor: options.borderColor,
                            borderWidth: options.borderWidth,
                            borderAlign: options.borderAlign,
                            x: centerX,
                            y: centerY,
                            innerRadius: 0,
                            outerRadius: reset ? resetRadius : distance,
                            startAngle: reset && animationOpts.animateRotate ? datasetStartAngle : startAngle,
                            endAngle: reset && animationOpts.animateRotate ? datasetStartAngle : endAngle,
                            label: helpers$1.valueAtIndexOrDefault(labels, index, labels[index])
                        }
                    });

                    arc.pivot();
                },

                countVisibleElements: function() {
                    var dataset = this.getDataset();
                    var meta = this.getMeta();
                    var count = 0;

                    helpers$1.each(meta.data, function(element, index) {
                        if (!isNaN(dataset.data[index]) && !element.hidden) {
                            count++;
                        }
                    });

                    return count;
                },

                /**
                 * @protected
                 */
                setHoverStyle: function(arc) {
                    var model = arc._model;
                    var options = arc._options;
                    var getHoverColor = helpers$1.getHoverColor;
                    var valueOrDefault = helpers$1.valueOrDefault;

                    arc.$previousStyle = {
                        backgroundColor: model.backgroundColor,
                        borderColor: model.borderColor,
                        borderWidth: model.borderWidth,
                    };

                    model.backgroundColor = valueOrDefault(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                    model.borderColor = valueOrDefault(options.hoverBorderColor, getHoverColor(options.borderColor));
                    model.borderWidth = valueOrDefault(options.hoverBorderWidth, options.borderWidth);
                },

                /**
                 * @private
                 */
                _computeAngle: function(index) {
                    var me = this;
                    var count = this.getMeta().count;
                    var dataset = me.getDataset();
                    var meta = me.getMeta();

                    if (isNaN(dataset.data[index]) || meta.data[index].hidden) {
                        return 0;
                    }

                    // Scriptable options
                    var context = {
                        chart: me.chart,
                        dataIndex: index,
                        dataset: dataset,
                        datasetIndex: me.index
                    };

                    return resolve$3([
                        me.chart.options.elements.arc.angle,
                        (2 * Math.PI) / count
                    ], context, index);
                }
            });

            core_defaults._set('pie', helpers$1.clone(core_defaults.doughnut));
            core_defaults._set('pie', {
                cutoutPercentage: 0
            });

            // Pie charts are Doughnut chart with different defaults
            var controller_pie = controller_doughnut;

            var valueOrDefault$7 = helpers$1.valueOrDefault;

            core_defaults._set('radar', {
                spanGaps: false,
                scale: {
                    type: 'radialLinear'
                },
                elements: {
                    line: {
                        fill: 'start',
                        tension: 0 // no bezier in radar
                    }
                }
            });

            var controller_radar = core_datasetController.extend({
                datasetElementType: elements.Line,

                dataElementType: elements.Point,

                linkScales: helpers$1.noop,

                /**
                 * @private
                 */
                _datasetElementOptions: [
                    'backgroundColor',
                    'borderWidth',
                    'borderColor',
                    'borderCapStyle',
                    'borderDash',
                    'borderDashOffset',
                    'borderJoinStyle',
                    'fill'
                ],

                /**
                 * @private
                 */
                _dataElementOptions: {
                    backgroundColor: 'pointBackgroundColor',
                    borderColor: 'pointBorderColor',
                    borderWidth: 'pointBorderWidth',
                    hitRadius: 'pointHitRadius',
                    hoverBackgroundColor: 'pointHoverBackgroundColor',
                    hoverBorderColor: 'pointHoverBorderColor',
                    hoverBorderWidth: 'pointHoverBorderWidth',
                    hoverRadius: 'pointHoverRadius',
                    pointStyle: 'pointStyle',
                    radius: 'pointRadius',
                    rotation: 'pointRotation'
                },

                /**
                 * @private
                 */
                _getIndexScaleId: function() {
                    return this.chart.scale.id;
                },

                /**
                 * @private
                 */
                _getValueScaleId: function() {
                    return this.chart.scale.id;
                },

                update: function(reset) {
                    var me = this;
                    var meta = me.getMeta();
                    var line = meta.dataset;
                    var points = meta.data || [];
                    var scale = me.chart.scale;
                    var config = me._config;
                    var i, ilen;

                    // Compatibility: If the properties are defined with only the old name, use those values
                    if (config.tension !== undefined && config.lineTension === undefined) {
                        config.lineTension = config.tension;
                    }

                    // Utility
                    line._scale = scale;
                    line._datasetIndex = me.index;
                    // Data
                    line._children = points;
                    line._loop = true;
                    // Model
                    line._model = me._resolveDatasetElementOptions(line);

                    line.pivot();

                    // Update Points
                    for (i = 0, ilen = points.length; i < ilen; ++i) {
                        me.updateElement(points[i], i, reset);
                    }

                    // Update bezier control points
                    me.updateBezierControlPoints();

                    // Now pivot the point for animation
                    for (i = 0, ilen = points.length; i < ilen; ++i) {
                        points[i].pivot();
                    }
                },

                updateElement: function(point, index, reset) {
                    var me = this;
                    var custom = point.custom || {};
                    var dataset = me.getDataset();
                    var scale = me.chart.scale;
                    var pointPosition = scale.getPointPositionForValue(index, dataset.data[index]);
                    var options = me._resolveDataElementOptions(point, index);
                    var lineModel = me.getMeta().dataset._model;
                    var x = reset ? scale.xCenter : pointPosition.x;
                    var y = reset ? scale.yCenter : pointPosition.y;

                    // Utility
                    point._scale = scale;
                    point._options = options;
                    point._datasetIndex = me.index;
                    point._index = index;

                    // Desired view properties
                    point._model = {
                        x: x, // value not used in dataset scale, but we want a consistent API between scales
                        y: y,
                        skip: custom.skip || isNaN(x) || isNaN(y),
                        // Appearance
                        radius: options.radius,
                        pointStyle: options.pointStyle,
                        rotation: options.rotation,
                        backgroundColor: options.backgroundColor,
                        borderColor: options.borderColor,
                        borderWidth: options.borderWidth,
                        tension: valueOrDefault$7(custom.tension, lineModel ? lineModel.tension : 0),

                        // Tooltip
                        hitRadius: options.hitRadius
                    };
                },

                /**
                 * @private
                 */
                _resolveDatasetElementOptions: function() {
                    var me = this;
                    var config = me._config;
                    var options = me.chart.options;
                    var values = core_datasetController.prototype._resolveDatasetElementOptions.apply(me, arguments);

                    values.spanGaps = valueOrDefault$7(config.spanGaps, options.spanGaps);
                    values.tension = valueOrDefault$7(config.lineTension, options.elements.line.tension);

                    return values;
                },

                updateBezierControlPoints: function() {
                    var me = this;
                    var meta = me.getMeta();
                    var area = me.chart.chartArea;
                    var points = meta.data || [];
                    var i, ilen, model, controlPoints;

                    // Only consider points that are drawn in case the spanGaps option is used
                    if (meta.dataset._model.spanGaps) {
                        points = points.filter(function(pt) {
                            return !pt._model.skip;
                        });
                    }

                    function capControlPoint(pt, min, max) {
                        return Math.max(Math.min(pt, max), min);
                    }

                    for (i = 0, ilen = points.length; i < ilen; ++i) {
                        model = points[i]._model;
                        controlPoints = helpers$1.splineCurve(
                            helpers$1.previousItem(points, i, true)._model,
                            model,
                            helpers$1.nextItem(points, i, true)._model,
                            model.tension
                        );

                        // Prevent the bezier going outside of the bounds of the graph
                        model.controlPointPreviousX = capControlPoint(controlPoints.previous.x, area.left, area.right);
                        model.controlPointPreviousY = capControlPoint(controlPoints.previous.y, area.top, area.bottom);
                        model.controlPointNextX = capControlPoint(controlPoints.next.x, area.left, area.right);
                        model.controlPointNextY = capControlPoint(controlPoints.next.y, area.top, area.bottom);
                    }
                },

                setHoverStyle: function(point) {
                    var model = point._model;
                    var options = point._options;
                    var getHoverColor = helpers$1.getHoverColor;

                    point.$previousStyle = {
                        backgroundColor: model.backgroundColor,
                        borderColor: model.borderColor,
                        borderWidth: model.borderWidth,
                        radius: model.radius
                    };

                    model.backgroundColor = valueOrDefault$7(options.hoverBackgroundColor, getHoverColor(options.backgroundColor));
                    model.borderColor = valueOrDefault$7(options.hoverBorderColor, getHoverColor(options.borderColor));
                    model.borderWidth = valueOrDefault$7(options.hoverBorderWidth, options.borderWidth);
                    model.radius = valueOrDefault$7(options.hoverRadius, options.radius);
                }
            });

            core_defaults._set('scatter', {
                hover: {
                    mode: 'single'
                },

                scales: {
                    xAxes: [{
                        id: 'x-axis-1',    // need an ID so datasets can reference the scale
                        type: 'linear',    // scatter should not use a category axis
                        position: 'bottom'
                    }],
                    yAxes: [{
                        id: 'y-axis-1',
                        type: 'linear',
                        position: 'left'
                    }]
                },

                tooltips: {
                    callbacks: {
                        title: function() {
                            return '';     // doesn't make sense for scatter since data are formatted as a point
                        },
                        label: function(item) {
                            return '(' + item.xLabel + ', ' + item.yLabel + ')';
                        }
                    }
                }
            });

            core_defaults._set('global', {
                datasets: {
                    scatter: {
                        showLine: false
                    }
                }
            });

            // Scatter charts use line controllers
            var controller_scatter = controller_line;

            // NOTE export a map in which the key represents the controller type, not
            // the class, and so must be CamelCase in order to be correctly retrieved
            // by the controller in core.controller.js (`controllers[meta.type]`).

            var controllers = {
                bar: controller_bar,
                bubble: controller_bubble,
                doughnut: controller_doughnut,
                horizontalBar: controller_horizontalBar,
                line: controller_line,
                polarArea: controller_polarArea,
                pie: controller_pie,
                radar: controller_radar,
                scatter: controller_scatter
            };

            /**
             * Helper function to get relative position for an event
             * @param {Event|IEvent} event - The event to get the position for
             * @param {Chart} chart - The chart
             * @returns {object} the event position
             */
            function getRelativePosition(e, chart) {
                if (e.native) {
                    return {
                        x: e.x,
                        y: e.y
                    };
                }

                return helpers$1.getRelativePosition(e, chart);
            }

            /**
             * Helper function to traverse all of the visible elements in the chart
             * @param {Chart} chart - the chart
             * @param {function} handler - the callback to execute for each visible item
             */
            function parseVisibleItems(chart, handler) {
                var metasets = chart._getSortedVisibleDatasetMetas();
                var metadata, i, j, ilen, jlen, element;

                for (i = 0, ilen = metasets.length; i < ilen; ++i) {
                    metadata = metasets[i].data;
                    for (j = 0, jlen = metadata.length; j < jlen; ++j) {
                        element = metadata[j];
                        if (!element._view.skip) {
                            handler(element);
                        }
                    }
                }
            }

            /**
             * Helper function to get the items that intersect the event position
             * @param {ChartElement[]} items - elements to filter
             * @param {object} position - the point to be nearest to
             * @return {ChartElement[]} the nearest items
             */
            function getIntersectItems(chart, position) {
                var elements = [];

                parseVisibleItems(chart, function(element) {
                    if (element.inRange(position.x, position.y)) {
                        elements.push(element);
                    }
                });

                return elements;
            }

            /**
             * Helper function to get the items nearest to the event position considering all visible items in teh chart
             * @param {Chart} chart - the chart to look at elements from
             * @param {object} position - the point to be nearest to
             * @param {boolean} intersect - if true, only consider items that intersect the position
             * @param {function} distanceMetric - function to provide the distance between points
             * @return {ChartElement[]} the nearest items
             */
            function getNearestItems(chart, position, intersect, distanceMetric) {
                var minDistance = Number.POSITIVE_INFINITY;
                var nearestItems = [];

                parseVisibleItems(chart, function(element) {
                    if (intersect && !element.inRange(position.x, position.y)) {
                        return;
                    }

                    var center = element.getCenterPoint();
                    var distance = distanceMetric(position, center);
                    if (distance < minDistance) {
                        nearestItems = [element];
                        minDistance = distance;
                    } else if (distance === minDistance) {
                        // Can have multiple items at the same distance in which case we sort by size
                        nearestItems.push(element);
                    }
                });

                return nearestItems;
            }

            /**
             * Get a distance metric function for two points based on the
             * axis mode setting
             * @param {string} axis - the axis mode. x|y|xy
             */
            function getDistanceMetricForAxis(axis) {
                var useX = axis.indexOf('x') !== -1;
                var useY = axis.indexOf('y') !== -1;

                return function(pt1, pt2) {
                    var deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
                    var deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
                    return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
                };
            }

            function indexMode(chart, e, options) {
                var position = getRelativePosition(e, chart);
                // Default axis for index mode is 'x' to match old behaviour
                options.axis = options.axis || 'x';
                var distanceMetric = getDistanceMetricForAxis(options.axis);
                var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);
                var elements = [];

                if (!items.length) {
                    return [];
                }

                chart._getSortedVisibleDatasetMetas().forEach(function(meta) {
                    var element = meta.data[items[0]._index];

                    // don't count items that are skipped (null data)
                    if (element && !element._view.skip) {
                        elements.push(element);
                    }
                });

                return elements;
            }

            /**
             * @interface IInteractionOptions
             */
            /**
             * If true, only consider items that intersect the point
             * @name IInterfaceOptions#boolean
             * @type Boolean
             */

            /**
             * Contains interaction related functions
             * @namespace Chart.Interaction
             */
            var core_interaction = {
                // Helper function for different modes
                modes: {
                    single: function(chart, e) {
                        var position = getRelativePosition(e, chart);
                        var elements = [];

                        parseVisibleItems(chart, function(element) {
                            if (element.inRange(position.x, position.y)) {
                                elements.push(element);
                                return elements;
                            }
                        });

                        return elements.slice(0, 1);
                    },

                    /**
                     * @function Chart.Interaction.modes.label
                     * @deprecated since version 2.4.0
                     * @todo remove at version 3
                     * @private
                     */
                    label: indexMode,

                    /**
                     * Returns items at the same index. If the options.intersect parameter is true, we only return items if we intersect something
                     * If the options.intersect mode is false, we find the nearest item and return the items at the same index as that item
                     * @function Chart.Interaction.modes.index
                     * @since v2.4.0
                     * @param {Chart} chart - the chart we are returning items from
                     * @param {Event} e - the event we are find things at
                     * @param {IInteractionOptions} options - options to use during interaction
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    index: indexMode,

                    /**
                     * Returns items in the same dataset. If the options.intersect parameter is true, we only return items if we intersect something
                     * If the options.intersect is false, we find the nearest item and return the items in that dataset
                     * @function Chart.Interaction.modes.dataset
                     * @param {Chart} chart - the chart we are returning items from
                     * @param {Event} e - the event we are find things at
                     * @param {IInteractionOptions} options - options to use during interaction
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    dataset: function(chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        options.axis = options.axis || 'xy';
                        var distanceMetric = getDistanceMetricForAxis(options.axis);
                        var items = options.intersect ? getIntersectItems(chart, position) : getNearestItems(chart, position, false, distanceMetric);

                        if (items.length > 0) {
                            items = chart.getDatasetMeta(items[0]._datasetIndex).data;
                        }

                        return items;
                    },

                    /**
                     * @function Chart.Interaction.modes.x-axis
                     * @deprecated since version 2.4.0. Use index mode and intersect == true
                     * @todo remove at version 3
                     * @private
                     */
                    'x-axis': function(chart, e) {
                        return indexMode(chart, e, {intersect: false});
                    },

                    /**
                     * Point mode returns all elements that hit test based on the event position
                     * of the event
                     * @function Chart.Interaction.modes.intersect
                     * @param {Chart} chart - the chart we are returning items from
                     * @param {Event} e - the event we are find things at
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    point: function(chart, e) {
                        var position = getRelativePosition(e, chart);
                        return getIntersectItems(chart, position);
                    },

                    /**
                     * nearest mode returns the element closest to the point
                     * @function Chart.Interaction.modes.intersect
                     * @param {Chart} chart - the chart we are returning items from
                     * @param {Event} e - the event we are find things at
                     * @param {IInteractionOptions} options - options to use
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    nearest: function(chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        options.axis = options.axis || 'xy';
                        var distanceMetric = getDistanceMetricForAxis(options.axis);
                        return getNearestItems(chart, position, options.intersect, distanceMetric);
                    },

                    /**
                     * x mode returns the elements that hit-test at the current x coordinate
                     * @function Chart.Interaction.modes.x
                     * @param {Chart} chart - the chart we are returning items from
                     * @param {Event} e - the event we are find things at
                     * @param {IInteractionOptions} options - options to use
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    x: function(chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        var items = [];
                        var intersectsItem = false;

                        parseVisibleItems(chart, function(element) {
                            if (element.inXRange(position.x)) {
                                items.push(element);
                            }

                            if (element.inRange(position.x, position.y)) {
                                intersectsItem = true;
                            }
                        });

                        // If we want to trigger on an intersect and we don't have any items
                        // that intersect the position, return nothing
                        if (options.intersect && !intersectsItem) {
                            items = [];
                        }
                        return items;
                    },

                    /**
                     * y mode returns the elements that hit-test at the current y coordinate
                     * @function Chart.Interaction.modes.y
                     * @param {Chart} chart - the chart we are returning items from
                     * @param {Event} e - the event we are find things at
                     * @param {IInteractionOptions} options - options to use
                     * @return {Chart.Element[]} Array of elements that are under the point. If none are found, an empty array is returned
                     */
                    y: function(chart, e, options) {
                        var position = getRelativePosition(e, chart);
                        var items = [];
                        var intersectsItem = false;

                        parseVisibleItems(chart, function(element) {
                            if (element.inYRange(position.y)) {
                                items.push(element);
                            }

                            if (element.inRange(position.x, position.y)) {
                                intersectsItem = true;
                            }
                        });

                        // If we want to trigger on an intersect and we don't have any items
                        // that intersect the position, return nothing
                        if (options.intersect && !intersectsItem) {
                            items = [];
                        }
                        return items;
                    }
                }
            };

            var extend = helpers$1.extend;

            function filterByPosition(array, position) {
                return helpers$1.where(array, function(v) {
                    return v.pos === position;
                });
            }

            function sortByWeight(array, reverse) {
                return array.sort(function(a, b) {
                    var v0 = reverse ? b : a;
                    var v1 = reverse ? a : b;
                    return v0.weight === v1.weight ?
                        v0.index - v1.index :
                        v0.weight - v1.weight;
                });
            }

            function wrapBoxes(boxes) {
                var layoutBoxes = [];
                var i, ilen, box;

                for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
                    box = boxes[i];
                    layoutBoxes.push({
                        index: i,
                        box: box,
                        pos: box.position,
                        horizontal: box.isHorizontal(),
                        weight: box.weight
                    });
                }
                return layoutBoxes;
            }

            function setLayoutDims(layouts, params) {
                var i, ilen, layout;
                for (i = 0, ilen = layouts.length; i < ilen; ++i) {
                    layout = layouts[i];
                    // store width used instead of chartArea.w in fitBoxes
                    layout.width = layout.horizontal
                        ? layout.box.fullWidth && params.availableWidth
                        : params.vBoxMaxWidth;
                    // store height used instead of chartArea.h in fitBoxes
                    layout.height = layout.horizontal && params.hBoxMaxHeight;
                }
            }

            function buildLayoutBoxes(boxes) {
                var layoutBoxes = wrapBoxes(boxes);
                var left = sortByWeight(filterByPosition(layoutBoxes, 'left'), true);
                var right = sortByWeight(filterByPosition(layoutBoxes, 'right'));
                var top = sortByWeight(filterByPosition(layoutBoxes, 'top'), true);
                var bottom = sortByWeight(filterByPosition(layoutBoxes, 'bottom'));

                return {
                    leftAndTop: left.concat(top),
                    rightAndBottom: right.concat(bottom),
                    chartArea: filterByPosition(layoutBoxes, 'chartArea'),
                    vertical: left.concat(right),
                    horizontal: top.concat(bottom)
                };
            }

            function getCombinedMax(maxPadding, chartArea, a, b) {
                return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
            }

            function updateDims(chartArea, params, layout) {
                var box = layout.box;
                var maxPadding = chartArea.maxPadding;
                var newWidth, newHeight;

                if (layout.size) {
                    // this layout was already counted for, lets first reduce old size
                    chartArea[layout.pos] -= layout.size;
                }
                layout.size = layout.horizontal ? box.height : box.width;
                chartArea[layout.pos] += layout.size;

                if (box.getPadding) {
                    var boxPadding = box.getPadding();
                    maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
                    maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
                    maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
                    maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
                }

                newWidth = params.outerWidth - getCombinedMax(maxPadding, chartArea, 'left', 'right');
                newHeight = params.outerHeight - getCombinedMax(maxPadding, chartArea, 'top', 'bottom');

                if (newWidth !== chartArea.w || newHeight !== chartArea.h) {
                    chartArea.w = newWidth;
                    chartArea.h = newHeight;

                    // return true if chart area changed in layout's direction
                    return layout.horizontal ? newWidth !== chartArea.w : newHeight !== chartArea.h;
                }
            }

            function handleMaxPadding(chartArea) {
                var maxPadding = chartArea.maxPadding;

                function updatePos(pos) {
                    var change = Math.max(maxPadding[pos] - chartArea[pos], 0);
                    chartArea[pos] += change;
                    return change;
                }
                chartArea.y += updatePos('top');
                chartArea.x += updatePos('left');
                updatePos('right');
                updatePos('bottom');
            }

            function getMargins(horizontal, chartArea) {
                var maxPadding = chartArea.maxPadding;

                function marginForPositions(positions) {
                    var margin = {left: 0, top: 0, right: 0, bottom: 0};
                    positions.forEach(function(pos) {
                        margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
                    });
                    return margin;
                }

                return horizontal
                    ? marginForPositions(['left', 'right'])
                    : marginForPositions(['top', 'bottom']);
            }

            function fitBoxes(boxes, chartArea, params) {
                var refitBoxes = [];
                var i, ilen, layout, box, refit, changed;

                for (i = 0, ilen = boxes.length; i < ilen; ++i) {
                    layout = boxes[i];
                    box = layout.box;

                    box.update(
                        layout.width || chartArea.w,
                        layout.height || chartArea.h,
                        getMargins(layout.horizontal, chartArea)
                    );
                    if (updateDims(chartArea, params, layout)) {
                        changed = true;
                        if (refitBoxes.length) {
                            // Dimensions changed and there were non full width boxes before this
                            // -> we have to refit those
                            refit = true;
                        }
                    }
                    if (!box.fullWidth) { // fullWidth boxes don't need to be re-fitted in any case
                        refitBoxes.push(layout);
                    }
                }

                return refit ? fitBoxes(refitBoxes, chartArea, params) || changed : changed;
            }

            function placeBoxes(boxes, chartArea, params) {
                var userPadding = params.padding;
                var x = chartArea.x;
                var y = chartArea.y;
                var i, ilen, layout, box;

                for (i = 0, ilen = boxes.length; i < ilen; ++i) {
                    layout = boxes[i];
                    box = layout.box;
                    if (layout.horizontal) {
                        box.left = box.fullWidth ? userPadding.left : chartArea.left;
                        box.right = box.fullWidth ? params.outerWidth - userPadding.right : chartArea.left + chartArea.w;
                        box.top = y;
                        box.bottom = y + box.height;
                        box.width = box.right - box.left;
                        y = box.bottom;
                    } else {
                        box.left = x;
                        box.right = x + box.width;
                        box.top = chartArea.top;
                        box.bottom = chartArea.top + chartArea.h;
                        box.height = box.bottom - box.top;
                        x = box.right;
                    }
                }

                chartArea.x = x;
                chartArea.y = y;
            }

            core_defaults._set('global', {
                layout: {
                    padding: {
                        top: 0,
                        right: 0,
                        bottom: 0,
                        left: 0
                    }
                }
            });

            /**
             * @interface ILayoutItem
             * @prop {string} position - The position of the item in the chart layout. Possible values are
             * 'left', 'top', 'right', 'bottom', and 'chartArea'
             * @prop {number} weight - The weight used to sort the item. Higher weights are further away from the chart area
             * @prop {boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down
             * @prop {function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)
             * @prop {function} update - Takes two parameters: width and height. Returns size of item
             * @prop {function} getPadding -  Returns an object with padding on the edges
             * @prop {number} width - Width of item. Must be valid after update()
             * @prop {number} height - Height of item. Must be valid after update()
             * @prop {number} left - Left edge of the item. Set by layout system and cannot be used in update
             * @prop {number} top - Top edge of the item. Set by layout system and cannot be used in update
             * @prop {number} right - Right edge of the item. Set by layout system and cannot be used in update
             * @prop {number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update
             */

                // The layout service is very self explanatory.  It's responsible for the layout within a chart.
                // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need
                // It is this service's responsibility of carrying out that layout.
            var core_layouts = {
                    defaults: {},

                    /**
                     * Register a box to a chart.
                     * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.
                     * @param {Chart} chart - the chart to use
                     * @param {ILayoutItem} item - the item to add to be layed out
                     */
                    addBox: function(chart, item) {
                        if (!chart.boxes) {
                            chart.boxes = [];
                        }

                        // initialize item with default values
                        item.fullWidth = item.fullWidth || false;
                        item.position = item.position || 'top';
                        item.weight = item.weight || 0;
                        item._layers = item._layers || function() {
                            return [{
                                z: 0,
                                draw: function() {
                                    item.draw.apply(item, arguments);
                                }
                            }];
                        };

                        chart.boxes.push(item);
                    },

                    /**
                     * Remove a layoutItem from a chart
                     * @param {Chart} chart - the chart to remove the box from
                     * @param {ILayoutItem} layoutItem - the item to remove from the layout
                     */
                    removeBox: function(chart, layoutItem) {
                        var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
                        if (index !== -1) {
                            chart.boxes.splice(index, 1);
                        }
                    },

                    /**
                     * Sets (or updates) options on the given `item`.
                     * @param {Chart} chart - the chart in which the item lives (or will be added to)
                     * @param {ILayoutItem} item - the item to configure with the given options
                     * @param {object} options - the new item options.
                     */
                    configure: function(chart, item, options) {
                        var props = ['fullWidth', 'position', 'weight'];
                        var ilen = props.length;
                        var i = 0;
                        var prop;

                        for (; i < ilen; ++i) {
                            prop = props[i];
                            if (options.hasOwnProperty(prop)) {
                                item[prop] = options[prop];
                            }
                        }
                    },

                    /**
                     * Fits boxes of the given chart into the given size by having each box measure itself
                     * then running a fitting algorithm
                     * @param {Chart} chart - the chart
                     * @param {number} width - the width to fit into
                     * @param {number} height - the height to fit into
                     */
                    update: function(chart, width, height) {
                        if (!chart) {
                            return;
                        }

                        var layoutOptions = chart.options.layout || {};
                        var padding = helpers$1.options.toPadding(layoutOptions.padding);

                        var availableWidth = width - padding.width;
                        var availableHeight = height - padding.height;
                        var boxes = buildLayoutBoxes(chart.boxes);
                        var verticalBoxes = boxes.vertical;
                        var horizontalBoxes = boxes.horizontal;

                        // Essentially we now have any number of boxes on each of the 4 sides.
                        // Our canvas looks like the following.
                        // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and
                        // B1 is the bottom axis
                        // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays
                        // These locations are single-box locations only, when trying to register a chartArea location that is already taken,
                        // an error will be thrown.
                        //
                        // |----------------------------------------------------|
                        // |                  T1 (Full Width)                   |
                        // |----------------------------------------------------|
                        // |    |    |                 T2                  |    |
                        // |    |----|-------------------------------------|----|
                        // |    |    | C1 |                           | C2 |    |
                        // |    |    |----|                           |----|    |
                        // |    |    |                                     |    |
                        // | L1 | L2 |           ChartArea (C0)            | R1 |
                        // |    |    |                                     |    |
                        // |    |    |----|                           |----|    |
                        // |    |    | C3 |                           | C4 |    |
                        // |    |----|-------------------------------------|----|
                        // |    |    |                 B1                  |    |
                        // |----------------------------------------------------|
                        // |                  B2 (Full Width)                   |
                        // |----------------------------------------------------|
                        //

                        var params = Object.freeze({
                            outerWidth: width,
                            outerHeight: height,
                            padding: padding,
                            availableWidth: availableWidth,
                            vBoxMaxWidth: availableWidth / 2 / verticalBoxes.length,
                            hBoxMaxHeight: availableHeight / 2
                        });
                        var chartArea = extend({
                            maxPadding: extend({}, padding),
                            w: availableWidth,
                            h: availableHeight,
                            x: padding.left,
                            y: padding.top
                        }, padding);

                        setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);

                        // First fit vertical boxes
                        fitBoxes(verticalBoxes, chartArea, params);

                        // Then fit horizontal boxes
                        if (fitBoxes(horizontalBoxes, chartArea, params)) {
                            // if the area changed, re-fit vertical boxes
                            fitBoxes(verticalBoxes, chartArea, params);
                        }

                        handleMaxPadding(chartArea);

                        // Finally place the boxes to correct coordinates
                        placeBoxes(boxes.leftAndTop, chartArea, params);

                        // Move to opposite side of chart
                        chartArea.x += chartArea.w;
                        chartArea.y += chartArea.h;

                        placeBoxes(boxes.rightAndBottom, chartArea, params);

                        chart.chartArea = {
                            left: chartArea.left,
                            top: chartArea.top,
                            right: chartArea.left + chartArea.w,
                            bottom: chartArea.top + chartArea.h
                        };

                        // Finally update boxes in chartArea (radial scale for example)
                        helpers$1.each(boxes.chartArea, function(layout) {
                            var box = layout.box;
                            extend(box, chart.chartArea);
                            box.update(chartArea.w, chartArea.h);
                        });
                    }
                };

            /**
             * Platform fallback implementation (minimal).
             * @see https://github.com/chartjs/Chart.js/pull/4591#issuecomment-319575939
             */

            var platform_basic = {
                acquireContext: function(item) {
                    if (item && item.canvas) {
                        // Support for any object associated to a canvas (including a context2d)
                        item = item.canvas;
                    }

                    return item && item.getContext('2d') || null;
                }
            };

            var platform_dom = "/*\n * DOM element rendering detection\n * https://davidwalsh.name/detect-node-insertion\n */\n@keyframes chartjs-render-animation {\n\tfrom { opacity: 0.99; }\n\tto { opacity: 1; }\n}\n\n.chartjs-render-monitor {\n\tanimation: chartjs-render-animation 0.001s;\n}\n\n/*\n * DOM element resizing detection\n * https://github.com/marcj/css-element-queries\n */\n.chartjs-size-monitor,\n.chartjs-size-monitor-expand,\n.chartjs-size-monitor-shrink {\n\tposition: absolute;\n\tdirection: ltr;\n\tleft: 0;\n\ttop: 0;\n\tright: 0;\n\tbottom: 0;\n\toverflow: hidden;\n\tpointer-events: none;\n\tvisibility: hidden;\n\tz-index: -1;\n}\n\n.chartjs-size-monitor-expand > div {\n\tposition: absolute;\n\twidth: 1000000px;\n\theight: 1000000px;\n\tleft: 0;\n\ttop: 0;\n}\n\n.chartjs-size-monitor-shrink > div {\n\tposition: absolute;\n\twidth: 200%;\n\theight: 200%;\n\tleft: 0;\n\ttop: 0;\n}\n";

            var platform_dom$1 = /*#__PURE__*/Object.freeze({
                __proto__: null,
                'default': platform_dom
            });

            var stylesheet = getCjsExportFromNamespace(platform_dom$1);

            var EXPANDO_KEY = '$chartjs';
            var CSS_PREFIX = 'chartjs-';
            var CSS_SIZE_MONITOR = CSS_PREFIX + 'size-monitor';
            var CSS_RENDER_MONITOR = CSS_PREFIX + 'render-monitor';
            var CSS_RENDER_ANIMATION = CSS_PREFIX + 'render-animation';
            var ANIMATION_START_EVENTS = ['animationstart', 'webkitAnimationStart'];

            /**
             * DOM event types -> Chart.js event types.
             * Note: only events with different types are mapped.
             * @see https://developer.mozilla.org/en-US/docs/Web/Events
             */
            var EVENT_TYPES = {
                touchstart: 'mousedown',
                touchmove: 'mousemove',
                touchend: 'mouseup',
                pointerenter: 'mouseenter',
                pointerdown: 'mousedown',
                pointermove: 'mousemove',
                pointerup: 'mouseup',
                pointerleave: 'mouseout',
                pointerout: 'mouseout'
            };

            /**
             * The "used" size is the final value of a dimension property after all calculations have
             * been performed. This method uses the computed style of `element` but returns undefined
             * if the computed style is not expressed in pixels. That can happen in some cases where
             * `element` has a size relative to its parent and this last one is not yet displayed,
             * for example because of `display: none` on a parent node.
             * @see https://developer.mozilla.org/en-US/docs/Web/CSS/used_value
             * @returns {number} Size in pixels or undefined if unknown.
             */
            function readUsedSize(element, property) {
                var value = helpers$1.getStyle(element, property);
                var matches = value && value.match(/^(\d+)(\.\d+)?px$/);
                return matches ? Number(matches[1]) : undefined;
            }

            /**
             * Initializes the canvas style and render size without modifying the canvas display size,
             * since responsiveness is handled by the controller.resize() method. The config is used
             * to determine the aspect ratio to apply in case no explicit height has been specified.
             */
            function initCanvas(canvas, config) {
                var style = canvas.style;

                // NOTE(SB) canvas.getAttribute('width') !== canvas.width: in the first case it
                // returns null or '' if no explicit value has been set to the canvas attribute.
                var renderHeight = canvas.getAttribute('height');
                var renderWidth = canvas.getAttribute('width');

                // Chart.js modifies some canvas values that we want to restore on destroy
                canvas[EXPANDO_KEY] = {
                    initial: {
                        height: renderHeight,
                        width: renderWidth,
                        style: {
                            display: style.display,
                            height: style.height,
                            width: style.width
                        }
                    }
                };

                // Force canvas to display as block to avoid extra space caused by inline
                // elements, which would interfere with the responsive resize process.
                // https://github.com/chartjs/Chart.js/issues/2538
                style.display = style.display || 'block';

                if (renderWidth === null || renderWidth === '') {
                    var displayWidth = readUsedSize(canvas, 'width');
                    if (displayWidth !== undefined) {
                        canvas.width = displayWidth;
                    }
                }

                if (renderHeight === null || renderHeight === '') {
                    if (canvas.style.height === '') {
                        // If no explicit render height and style height, let's apply the aspect ratio,
                        // which one can be specified by the user but also by charts as default option
                        // (i.e. options.aspectRatio). If not specified, use canvas aspect ratio of 2.
                        canvas.height = canvas.width / (config.options.aspectRatio || 2);
                    } else {
                        var displayHeight = readUsedSize(canvas, 'height');
                        if (displayWidth !== undefined) {
                            canvas.height = displayHeight;
                        }
                    }
                }

                return canvas;
            }

            /**
             * Detects support for options object argument in addEventListener.
             * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support
             * @private
             */
            var supportsEventListenerOptions = (function() {
                var supports = false;
                try {
                    var options = Object.defineProperty({}, 'passive', {
                        // eslint-disable-next-line getter-return
                        get: function() {
                            supports = true;
                        }
                    });
                    window.addEventListener('e', null, options);
                } catch (e) {
                    // continue regardless of error
                }
                return supports;
            }());

            // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.
            // https://github.com/chartjs/Chart.js/issues/4287
            var eventListenerOptions = supportsEventListenerOptions ? {passive: true} : false;

            function addListener(node, type, listener) {
                node.addEventListener(type, listener, eventListenerOptions);
            }

            function removeListener(node, type, listener) {
                node.removeEventListener(type, listener, eventListenerOptions);
            }

            function createEvent(type, chart, x, y, nativeEvent) {
                return {
                    type: type,
                    chart: chart,
                    native: nativeEvent || null,
                    x: x !== undefined ? x : null,
                    y: y !== undefined ? y : null,
                };
            }

            function fromNativeEvent(event, chart) {
                var type = EVENT_TYPES[event.type] || event.type;
                var pos = helpers$1.getRelativePosition(event, chart);
                return createEvent(type, chart, pos.x, pos.y, event);
            }

            function throttled(fn, thisArg) {
                var ticking = false;
                var args = [];

                return function() {
                    args = Array.prototype.slice.call(arguments);
                    thisArg = thisArg || this;

                    if (!ticking) {
                        ticking = true;
                        helpers$1.requestAnimFrame.call(window, function() {
                            ticking = false;
                            fn.apply(thisArg, args);
                        });
                    }
                };
            }

            function createDiv(cls) {
                var el = document.createElement('div');
                el.className = cls || '';
                return el;
            }

            // Implementation based on https://github.com/marcj/css-element-queries
            function createResizer(handler) {
                var maxSize = 1000000;

                // NOTE(SB) Don't use innerHTML because it could be considered unsafe.
                // https://github.com/chartjs/Chart.js/issues/5902
                var resizer = createDiv(CSS_SIZE_MONITOR);
                var expand = createDiv(CSS_SIZE_MONITOR + '-expand');
                var shrink = createDiv(CSS_SIZE_MONITOR + '-shrink');

                expand.appendChild(createDiv());
                shrink.appendChild(createDiv());

                resizer.appendChild(expand);
                resizer.appendChild(shrink);
                resizer._reset = function() {
                    expand.scrollLeft = maxSize;
                    expand.scrollTop = maxSize;
                    shrink.scrollLeft = maxSize;
                    shrink.scrollTop = maxSize;
                };

                var onScroll = function() {
                    resizer._reset();
                    handler();
                };

                addListener(expand, 'scroll', onScroll.bind(expand, 'expand'));
                addListener(shrink, 'scroll', onScroll.bind(shrink, 'shrink'));

                return resizer;
            }

            // https://davidwalsh.name/detect-node-insertion
            function watchForRender(node, handler) {
                var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});
                var proxy = expando.renderProxy = function(e) {
                    if (e.animationName === CSS_RENDER_ANIMATION) {
                        handler();
                    }
                };

                helpers$1.each(ANIMATION_START_EVENTS, function(type) {
                    addListener(node, type, proxy);
                });

                // #4737: Chrome might skip the CSS animation when the CSS_RENDER_MONITOR class
                // is removed then added back immediately (same animation frame?). Accessing the
                // `offsetParent` property will force a reflow and re-evaluate the CSS animation.
                // https://gist.github.com/paulirish/5d52fb081b3570c81e3a#box-metrics
                // https://github.com/chartjs/Chart.js/issues/4737
                expando.reflow = !!node.offsetParent;

                node.classList.add(CSS_RENDER_MONITOR);
            }

            function unwatchForRender(node) {
                var expando = node[EXPANDO_KEY] || {};
                var proxy = expando.renderProxy;

                if (proxy) {
                    helpers$1.each(ANIMATION_START_EVENTS, function(type) {
                        removeListener(node, type, proxy);
                    });

                    delete expando.renderProxy;
                }

                node.classList.remove(CSS_RENDER_MONITOR);
            }

            function addResizeListener(node, listener, chart) {
                var expando = node[EXPANDO_KEY] || (node[EXPANDO_KEY] = {});

                // Let's keep track of this added resizer and thus avoid DOM query when removing it.
                var resizer = expando.resizer = createResizer(throttled(function() {
                    if (expando.resizer) {
                        var container = chart.options.maintainAspectRatio && node.parentNode;
                        var w = container ? container.clientWidth : 0;
                        listener(createEvent('resize', chart));
                        if (container && container.clientWidth < w && chart.canvas) {
                            // If the container size shrank during chart resize, let's assume
                            // scrollbar appeared. So we resize again with the scrollbar visible -
                            // effectively making chart smaller and the scrollbar hidden again.
                            // Because we are inside `throttled`, and currently `ticking`, scroll
                            // events are ignored during this whole 2 resize process.
                            // If we assumed wrong and something else happened, we are resizing
                            // twice in a frame (potential performance issue)
                            listener(createEvent('resize', chart));
                        }
                    }
                }));

                // The resizer needs to be attached to the node parent, so we first need to be
                // sure that `node` is attached to the DOM before injecting the resizer element.
                watchForRender(node, function() {
                    if (expando.resizer) {
                        var container = node.parentNode;
                        if (container && container !== resizer.parentNode) {
                            container.insertBefore(resizer, container.firstChild);
                        }

                        // The container size might have changed, let's reset the resizer state.
                        resizer._reset();
                    }
                });
            }

            function removeResizeListener(node) {
                var expando = node[EXPANDO_KEY] || {};
                var resizer = expando.resizer;

                delete expando.resizer;
                unwatchForRender(node);

                if (resizer && resizer.parentNode) {
                    resizer.parentNode.removeChild(resizer);
                }
            }

            /**
             * Injects CSS styles inline if the styles are not already present.
             * @param {HTMLDocument|ShadowRoot} rootNode - the node to contain the <style>.
             * @param {string} css - the CSS to be injected.
             */
            function injectCSS(rootNode, css) {
                // https://stackoverflow.com/q/3922139
                var expando = rootNode[EXPANDO_KEY] || (rootNode[EXPANDO_KEY] = {});
                if (!expando.containsStyles) {
                    expando.containsStyles = true;
                    css = '/* Chart.js */\n' + css;
                    var style = document.createElement('style');
                    style.setAttribute('type', 'text/css');
                    style.appendChild(document.createTextNode(css));
                    rootNode.appendChild(style);
                }
            }

            var platform_dom$2 = {
                /**
                 * When `true`, prevents the automatic injection of the stylesheet required to
                 * correctly detect when the chart is added to the DOM and then resized. This
                 * switch has been added to allow external stylesheet (`dist/Chart(.min)?.js`)
                 * to be manually imported to make this library compatible with any CSP.
                 * See https://github.com/chartjs/Chart.js/issues/5208
                 */
                disableCSSInjection: false,

                /**
                 * This property holds whether this platform is enabled for the current environment.
                 * Currently used by platform.js to select the proper implementation.
                 * @private
                 */
                _enabled: typeof window !== 'undefined' && typeof document !== 'undefined',

                /**
                 * Initializes resources that depend on platform options.
                 * @param {HTMLCanvasElement} canvas - The Canvas element.
                 * @private
                 */
                _ensureLoaded: function(canvas) {
                    if (!this.disableCSSInjection) {
                        // If the canvas is in a shadow DOM, then the styles must also be inserted
                        // into the same shadow DOM.
                        // https://github.com/chartjs/Chart.js/issues/5763
                        var root = canvas.getRootNode ? canvas.getRootNode() : document;
                        var targetNode = root.host ? root : document.head;
                        injectCSS(targetNode, stylesheet);
                    }
                },

                acquireContext: function(item, config) {
                    if (typeof item === 'string') {
                        item = document.getElementById(item);
                    } else if (item.length) {
                        // Support for array based queries (such as jQuery)
                        item = item[0];
                    }

                    if (item && item.canvas) {
                        // Support for any object associated to a canvas (including a context2d)
                        item = item.canvas;
                    }

                    // To prevent canvas fingerprinting, some add-ons undefine the getContext
                    // method, for example: https://github.com/kkapsner/CanvasBlocker
                    // https://github.com/chartjs/Chart.js/issues/2807
                    var context = item && item.getContext && item.getContext('2d');

                    // `instanceof HTMLCanvasElement/CanvasRenderingContext2D` fails when the item is
                    // inside an iframe or when running in a protected environment. We could guess the
                    // types from their toString() value but let's keep things flexible and assume it's
                    // a sufficient condition if the item has a context2D which has item as `canvas`.
                    // https://github.com/chartjs/Chart.js/issues/3887
                    // https://github.com/chartjs/Chart.js/issues/4102
                    // https://github.com/chartjs/Chart.js/issues/4152
                    if (context && context.canvas === item) {
                        // Load platform resources on first chart creation, to make it possible to
                        // import the library before setting platform options.
                        this._ensureLoaded(item);
                        initCanvas(item, config);
                        return context;
                    }

                    return null;
                },

                releaseContext: function(context) {
                    var canvas = context.canvas;
                    if (!canvas[EXPANDO_KEY]) {
                        return;
                    }

                    var initial = canvas[EXPANDO_KEY].initial;
                    ['height', 'width'].forEach(function(prop) {
                        var value = initial[prop];
                        if (helpers$1.isNullOrUndef(value)) {
                            canvas.removeAttribute(prop);
                        } else {
                            canvas.setAttribute(prop, value);
                        }
                    });

                    helpers$1.each(initial.style || {}, function(value, key) {
                        canvas.style[key] = value;
                    });

                    // The canvas render size might have been changed (and thus the state stack discarded),
                    // we can't use save() and restore() to restore the initial state. So make sure that at
                    // least the canvas context is reset to the default state by setting the canvas width.
                    // https://www.w3.org/TR/2011/WD-html5-20110525/the-canvas-element.html
                    // eslint-disable-next-line no-self-assign
                    canvas.width = canvas.width;

                    delete canvas[EXPANDO_KEY];
                },

                addEventListener: function(chart, type, listener) {
                    var canvas = chart.canvas;
                    if (type === 'resize') {
                        // Note: the resize event is not supported on all browsers.
                        addResizeListener(canvas, listener, chart);
                        return;
                    }

                    var expando = listener[EXPANDO_KEY] || (listener[EXPANDO_KEY] = {});
                    var proxies = expando.proxies || (expando.proxies = {});
                    var proxy = proxies[chart.id + '_' + type] = function(event) {
                        listener(fromNativeEvent(event, chart));
                    };

                    addListener(canvas, type, proxy);
                },

                removeEventListener: function(chart, type, listener) {
                    var canvas = chart.canvas;
                    if (type === 'resize') {
                        // Note: the resize event is not supported on all browsers.
                        removeResizeListener(canvas);
                        return;
                    }

                    var expando = listener[EXPANDO_KEY] || {};
                    var proxies = expando.proxies || {};
                    var proxy = proxies[chart.id + '_' + type];
                    if (!proxy) {
                        return;
                    }

                    removeListener(canvas, type, proxy);
                }
            };

            // DEPRECATIONS

            /**
             * Provided for backward compatibility, use EventTarget.addEventListener instead.
             * EventTarget.addEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
             * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
             * @function Chart.helpers.addEvent
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers$1.addEvent = addListener;

            /**
             * Provided for backward compatibility, use EventTarget.removeEventListener instead.
             * EventTarget.removeEventListener compatibility: Chrome, Opera 7, Safari, FF1.5+, IE9+
             * @see https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/removeEventListener
             * @function Chart.helpers.removeEvent
             * @deprecated since version 2.7.0
             * @todo remove at version 3
             * @private
             */
            helpers$1.removeEvent = removeListener;

            // @TODO Make possible to select another platform at build time.
            var implementation = platform_dom$2._enabled ? platform_dom$2 : platform_basic;

            /**
             * @namespace Chart.platform
             * @see https://chartjs.gitbooks.io/proposals/content/Platform.html
             * @since 2.4.0
             */
            var platform = helpers$1.extend({
                /**
                 * @since 2.7.0
                 */
                initialize: function() {},

                /**
                 * Called at chart construction time, returns a context2d instance implementing
                 * the [W3C Canvas 2D Context API standard]{@link https://www.w3.org/TR/2dcontext/}.
                 * @param {*} item - The native item from which to acquire context (platform specific)
                 * @param {object} options - The chart options
                 * @returns {CanvasRenderingContext2D} context2d instance
                 */
                acquireContext: function() {},

                /**
                 * Called at chart destruction time, releases any resources associated to the context
                 * previously returned by the acquireContext() method.
                 * @param {CanvasRenderingContext2D} context - The context2d instance
                 * @returns {boolean} true if the method succeeded, else false
                 */
                releaseContext: function() {},

                /**
                 * Registers the specified listener on the given chart.
                 * @param {Chart} chart - Chart from which to listen for event
                 * @param {string} type - The ({@link IEvent}) type to listen for
                 * @param {function} listener - Receives a notification (an object that implements
                 * the {@link IEvent} interface) when an event of the specified type occurs.
                 */
                addEventListener: function() {},

                /**
                 * Removes the specified listener previously registered with addEventListener.
                 * @param {Chart} chart - Chart from which to remove the listener
                 * @param {string} type - The ({@link IEvent}) type to remove
                 * @param {function} listener - The listener function to remove from the event target.
                 */
                removeEventListener: function() {}

            }, implementation);

            core_defaults._set('global', {
                plugins: {}
            });

            /**
             * The plugin service singleton
             * @namespace Chart.plugins
             * @since 2.1.0
             */
            var core_plugins = {
                /**
                 * Globally registered plugins.
                 * @private
                 */
                _plugins: [],

                /**
                 * This identifier is used to invalidate the descriptors cache attached to each chart
                 * when a global plugin is registered or unregistered. In this case, the cache ID is
                 * incremented and descriptors are regenerated during following API calls.
                 * @private
                 */
                _cacheId: 0,

                /**
                 * Registers the given plugin(s) if not already registered.
                 * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
                 */
                register: function(plugins) {
                    var p = this._plugins;
                    ([]).concat(plugins).forEach(function(plugin) {
                        if (p.indexOf(plugin) === -1) {
                            p.push(plugin);
                        }
                    });

                    this._cacheId++;
                },

                /**
                 * Unregisters the given plugin(s) only if registered.
                 * @param {IPlugin[]|IPlugin} plugins plugin instance(s).
                 */
                unregister: function(plugins) {
                    var p = this._plugins;
                    ([]).concat(plugins).forEach(function(plugin) {
                        var idx = p.indexOf(plugin);
                        if (idx !== -1) {
                            p.splice(idx, 1);
                        }
                    });

                    this._cacheId++;
                },

                /**
                 * Remove all registered plugins.
                 * @since 2.1.5
                 */
                clear: function() {
                    this._plugins = [];
                    this._cacheId++;
                },

                /**
                 * Returns the number of registered plugins?
                 * @returns {number}
                 * @since 2.1.5
                 */
                count: function() {
                    return this._plugins.length;
                },

                /**
                 * Returns all registered plugin instances.
                 * @returns {IPlugin[]} array of plugin objects.
                 * @since 2.1.5
                 */
                getAll: function() {
                    return this._plugins;
                },

                /**
                 * Calls enabled plugins for `chart` on the specified hook and with the given args.
                 * This method immediately returns as soon as a plugin explicitly returns false. The
                 * returned value can be used, for instance, to interrupt the current action.
                 * @param {Chart} chart - The chart instance for which plugins should be called.
                 * @param {string} hook - The name of the plugin method to call (e.g. 'beforeUpdate').
                 * @param {Array} [args] - Extra arguments to apply to the hook call.
                 * @returns {boolean} false if any of the plugins return false, else returns true.
                 */
                notify: function(chart, hook, args) {
                    var descriptors = this.descriptors(chart);
                    var ilen = descriptors.length;
                    var i, descriptor, plugin, params, method;

                    for (i = 0; i < ilen; ++i) {
                        descriptor = descriptors[i];
                        plugin = descriptor.plugin;
                        method = plugin[hook];
                        if (typeof method === 'function') {
                            params = [chart].concat(args || []);
                            params.push(descriptor.options);
                            if (method.apply(plugin, params) === false) {
                                return false;
                            }
                        }
                    }

                    return true;
                },

                /**
                 * Returns descriptors of enabled plugins for the given chart.
                 * @returns {object[]} [{ plugin, options }]
                 * @private
                 */
                descriptors: function(chart) {
                    var cache = chart.$plugins || (chart.$plugins = {});
                    if (cache.id === this._cacheId) {
                        return cache.descriptors;
                    }

                    var plugins = [];
                    var descriptors = [];
                    var config = (chart && chart.config) || {};
                    var options = (config.options && config.options.plugins) || {};

                    this._plugins.concat(config.plugins || []).forEach(function(plugin) {
                        var idx = plugins.indexOf(plugin);
                        if (idx !== -1) {
                            return;
                        }

                        var id = plugin.id;
                        var opts = options[id];
                        if (opts === false) {
                            return;
                        }

                        if (opts === true) {
                            opts = helpers$1.clone(core_defaults.global.plugins[id]);
                        }

                        plugins.push(plugin);
                        descriptors.push({
                            plugin: plugin,
                            options: opts || {}
                        });
                    });

                    cache.descriptors = descriptors;
                    cache.id = this._cacheId;
                    return descriptors;
                },

                /**
                 * Invalidates cache for the given chart: descriptors hold a reference on plugin option,
                 * but in some cases, this reference can be changed by the user when updating options.
                 * https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
                 * @private
                 */
                _invalidate: function(chart) {
                    delete chart.$plugins;
                }
            };

            var core_scaleService = {
                // Scale registration object. Extensions can register new scale types (such as log or DB scales) and then
                // use the new chart options to grab the correct scale
                constructors: {},
                // Use a registration function so that we can move to an ES6 map when we no longer need to support
                // old browsers

                // Scale config defaults
                defaults: {},
                registerScaleType: function(type, scaleConstructor, scaleDefaults) {
                    this.constructors[type] = scaleConstructor;
                    this.defaults[type] = helpers$1.clone(scaleDefaults);
                },
                getScaleConstructor: function(type) {
                    return this.constructors.hasOwnProperty(type) ? this.constructors[type] : undefined;
                },
                getScaleDefaults: function(type) {
                    // Return the scale defaults merged with the global settings so that we always use the latest ones
                    return this.defaults.hasOwnProperty(type) ? helpers$1.merge({}, [core_defaults.scale, this.defaults[type]]) : {};
                },
                updateScaleDefaults: function(type, additions) {
                    var me = this;
                    if (me.defaults.hasOwnProperty(type)) {
                        me.defaults[type] = helpers$1.extend(me.defaults[type], additions);
                    }
                },
                addScalesToLayout: function(chart) {
                    // Adds each scale to the chart.boxes array to be sized accordingly
                    helpers$1.each(chart.scales, function(scale) {
                        // Set ILayoutItem parameters for backwards compatibility
                        scale.fullWidth = scale.options.fullWidth;
                        scale.position = scale.options.position;
                        scale.weight = scale.options.weight;
                        core_layouts.addBox(chart, scale);
                    });
                }
            };

            var valueOrDefault$8 = helpers$1.valueOrDefault;
            var getRtlHelper = helpers$1.rtl.getRtlAdapter;

            core_defaults._set('global', {
                tooltips: {
                    enabled: true,
                    custom: null,
                    mode: 'nearest',
                    position: 'average',
                    intersect: true,
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    titleFontStyle: 'bold',
                    titleSpacing: 2,
                    titleMarginBottom: 6,
                    titleFontColor: '#fff',
                    titleAlign: 'left',
                    bodySpacing: 2,
                    bodyFontColor: '#fff',
                    bodyAlign: 'left',
                    footerFontStyle: 'bold',
                    footerSpacing: 2,
                    footerMarginTop: 6,
                    footerFontColor: '#fff',
                    footerAlign: 'left',
                    yPadding: 6,
                    xPadding: 6,
                    caretPadding: 2,
                    caretSize: 5,
                    cornerRadius: 6,
                    multiKeyBackground: '#fff',
                    displayColors: true,
                    borderColor: 'rgba(0,0,0,0)',
                    borderWidth: 0,
                    callbacks: {
                        // Args are: (tooltipItems, data)
                        beforeTitle: helpers$1.noop,
                        title: function(tooltipItems, data) {
                            var title = '';
                            var labels = data.labels;
                            var labelCount = labels ? labels.length : 0;

                            if (tooltipItems.length > 0) {
                                var item = tooltipItems[0];
                                if (item.label) {
                                    title = item.label;
                                } else if (item.xLabel) {
                                    title = item.xLabel;
                                } else if (labelCount > 0 && item.index < labelCount) {
                                    title = labels[item.index];
                                }
                            }

                            return title;
                        },
                        afterTitle: helpers$1.noop,

                        // Args are: (tooltipItems, data)
                        beforeBody: helpers$1.noop,

                        // Args are: (tooltipItem, data)
                        beforeLabel: helpers$1.noop,
                        label: function(tooltipItem, data) {
                            var label = data.datasets[tooltipItem.datasetIndex].label || '';

                            if (label) {
                                label += ': ';
                            }
                            if (!helpers$1.isNullOrUndef(tooltipItem.value)) {
                                label += tooltipItem.value;
                            } else {
                                label += tooltipItem.yLabel;
                            }
                            return label;
                        },
                        labelColor: function(tooltipItem, chart) {
                            var meta = chart.getDatasetMeta(tooltipItem.datasetIndex);
                            var activeElement = meta.data[tooltipItem.index];
                            var view = activeElement._view;
                            return {
                                borderColor: view.borderColor,
                                backgroundColor: view.backgroundColor
                            };
                        },
                        labelTextColor: function() {
                            return this._options.bodyFontColor;
                        },
                        afterLabel: helpers$1.noop,

                        // Args are: (tooltipItems, data)
                        afterBody: helpers$1.noop,

                        // Args are: (tooltipItems, data)
                        beforeFooter: helpers$1.noop,
                        footer: helpers$1.noop,
                        afterFooter: helpers$1.noop
                    }
                }
            });

            var positioners = {
                /**
                 * Average mode places the tooltip at the average position of the elements shown
                 * @function Chart.Tooltip.positioners.average
                 * @param elements {ChartElement[]} the elements being displayed in the tooltip
                 * @returns {object} tooltip position
                 */
                average: function(elements) {
                    if (!elements.length) {
                        return false;
                    }

                    var i, len;
                    var x = 0;
                    var y = 0;
                    var count = 0;

                    for (i = 0, len = elements.length; i < len; ++i) {
                        var el = elements[i];
                        if (el && el.hasValue()) {
                            var pos = el.tooltipPosition();
                            x += pos.x;
                            y += pos.y;
                            ++count;
                        }
                    }

                    return {
                        x: x / count,
                        y: y / count
                    };
                },

                /**
                 * Gets the tooltip position nearest of the item nearest to the event position
                 * @function Chart.Tooltip.positioners.nearest
                 * @param elements {Chart.Element[]} the tooltip elements
                 * @param eventPosition {object} the position of the event in canvas coordinates
                 * @returns {object} the tooltip position
                 */
                nearest: function(elements, eventPosition) {
                    var x = eventPosition.x;
                    var y = eventPosition.y;
                    var minDistance = Number.POSITIVE_INFINITY;
                    var i, len, nearestElement;

                    for (i = 0, len = elements.length; i < len; ++i) {
                        var el = elements[i];
                        if (el && el.hasValue()) {
                            var center = el.getCenterPoint();
                            var d = helpers$1.distanceBetweenPoints(eventPosition, center);

                            if (d < minDistance) {
                                minDistance = d;
                                nearestElement = el;
                            }
                        }
                    }

                    if (nearestElement) {
                        var tp = nearestElement.tooltipPosition();
                        x = tp.x;
                        y = tp.y;
                    }

                    return {
                        x: x,
                        y: y
                    };
                }
            };

            // Helper to push or concat based on if the 2nd parameter is an array or not
            function pushOrConcat(base, toPush) {
                if (toPush) {
                    if (helpers$1.isArray(toPush)) {
                        // base = base.concat(toPush);
                        Array.prototype.push.apply(base, toPush);
                    } else {
                        base.push(toPush);
                    }
                }

                return base;
            }

            /**
             * Returns array of strings split by newline
             * @param {string} value - The value to split by newline.
             * @returns {string[]} value if newline present - Returned from String split() method
             * @function
             */
            function splitNewlines(str) {
                if ((typeof str === 'string' || str instanceof String) && str.indexOf('\n') > -1) {
                    return str.split('\n');
                }
                return str;
            }


            /**
             * Private helper to create a tooltip item model
             * @param element - the chart element (point, arc, bar) to create the tooltip item for
             * @return new tooltip item
             */
            function createTooltipItem(element) {
                var xScale = element._xScale;
                var yScale = element._yScale || element._scale; // handle radar || polarArea charts
                var index = element._index;
                var datasetIndex = element._datasetIndex;
                var controller = element._chart.getDatasetMeta(datasetIndex).controller;
                var indexScale = controller._getIndexScale();
                var valueScale = controller._getValueScale();

                return {
                    xLabel: xScale ? xScale.getLabelForIndex(index, datasetIndex) : '',
                    yLabel: yScale ? yScale.getLabelForIndex(index, datasetIndex) : '',
                    label: indexScale ? '' + indexScale.getLabelForIndex(index, datasetIndex) : '',
                    value: valueScale ? '' + valueScale.getLabelForIndex(index, datasetIndex) : '',
                    index: index,
                    datasetIndex: datasetIndex,
                    x: element._model.x,
                    y: element._model.y
                };
            }

            /**
             * Helper to get the reset model for the tooltip
             * @param tooltipOpts {object} the tooltip options
             */
            function getBaseModel(tooltipOpts) {
                var globalDefaults = core_defaults.global;

                return {
                    // Positioning
                    xPadding: tooltipOpts.xPadding,
                    yPadding: tooltipOpts.yPadding,
                    xAlign: tooltipOpts.xAlign,
                    yAlign: tooltipOpts.yAlign,

                    // Drawing direction and text direction
                    rtl: tooltipOpts.rtl,
                    textDirection: tooltipOpts.textDirection,

                    // Body
                    bodyFontColor: tooltipOpts.bodyFontColor,
                    _bodyFontFamily: valueOrDefault$8(tooltipOpts.bodyFontFamily, globalDefaults.defaultFontFamily),
                    _bodyFontStyle: valueOrDefault$8(tooltipOpts.bodyFontStyle, globalDefaults.defaultFontStyle),
                    _bodyAlign: tooltipOpts.bodyAlign,
                    bodyFontSize: valueOrDefault$8(tooltipOpts.bodyFontSize, globalDefaults.defaultFontSize),
                    bodySpacing: tooltipOpts.bodySpacing,

                    // Title
                    titleFontColor: tooltipOpts.titleFontColor,
                    _titleFontFamily: valueOrDefault$8(tooltipOpts.titleFontFamily, globalDefaults.defaultFontFamily),
                    _titleFontStyle: valueOrDefault$8(tooltipOpts.titleFontStyle, globalDefaults.defaultFontStyle),
                    titleFontSize: valueOrDefault$8(tooltipOpts.titleFontSize, globalDefaults.defaultFontSize),
                    _titleAlign: tooltipOpts.titleAlign,
                    titleSpacing: tooltipOpts.titleSpacing,
                    titleMarginBottom: tooltipOpts.titleMarginBottom,

                    // Footer
                    footerFontColor: tooltipOpts.footerFontColor,
                    _footerFontFamily: valueOrDefault$8(tooltipOpts.footerFontFamily, globalDefaults.defaultFontFamily),
                    _footerFontStyle: valueOrDefault$8(tooltipOpts.footerFontStyle, globalDefaults.defaultFontStyle),
                    footerFontSize: valueOrDefault$8(tooltipOpts.footerFontSize, globalDefaults.defaultFontSize),
                    _footerAlign: tooltipOpts.footerAlign,
                    footerSpacing: tooltipOpts.footerSpacing,
                    footerMarginTop: tooltipOpts.footerMarginTop,

                    // Appearance
                    caretSize: tooltipOpts.caretSize,
                    cornerRadius: tooltipOpts.cornerRadius,
                    backgroundColor: tooltipOpts.backgroundColor,
                    opacity: 0,
                    legendColorBackground: tooltipOpts.multiKeyBackground,
                    displayColors: tooltipOpts.displayColors,
                    borderColor: tooltipOpts.borderColor,
                    borderWidth: tooltipOpts.borderWidth
                };
            }

            /**
             * Get the size of the tooltip
             */
            function getTooltipSize(tooltip, model) {
                var ctx = tooltip._chart.ctx;

                var height = model.yPadding * 2; // Tooltip Padding
                var width = 0;

                // Count of all lines in the body
                var body = model.body;
                var combinedBodyLength = body.reduce(function(count, bodyItem) {
                    return count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length;
                }, 0);
                combinedBodyLength += model.beforeBody.length + model.afterBody.length;

                var titleLineCount = model.title.length;
                var footerLineCount = model.footer.length;
                var titleFontSize = model.titleFontSize;
                var bodyFontSize = model.bodyFontSize;
                var footerFontSize = model.footerFontSize;

                height += titleLineCount * titleFontSize; // Title Lines
                height += titleLineCount ? (titleLineCount - 1) * model.titleSpacing : 0; // Title Line Spacing
                height += titleLineCount ? model.titleMarginBottom : 0; // Title's bottom Margin
                height += combinedBodyLength * bodyFontSize; // Body Lines
                height += combinedBodyLength ? (combinedBodyLength - 1) * model.bodySpacing : 0; // Body Line Spacing
                height += footerLineCount ? model.footerMarginTop : 0; // Footer Margin
                height += footerLineCount * (footerFontSize); // Footer Lines
                height += footerLineCount ? (footerLineCount - 1) * model.footerSpacing : 0; // Footer Line Spacing

                // Title width
                var widthPadding = 0;
                var maxLineWidth = function(line) {
                    width = Math.max(width, ctx.measureText(line).width + widthPadding);
                };

                ctx.font = helpers$1.fontString(titleFontSize, model._titleFontStyle, model._titleFontFamily);
                helpers$1.each(model.title, maxLineWidth);

                // Body width
                ctx.font = helpers$1.fontString(bodyFontSize, model._bodyFontStyle, model._bodyFontFamily);
                helpers$1.each(model.beforeBody.concat(model.afterBody), maxLineWidth);

                // Body lines may include some extra width due to the color box
                widthPadding = model.displayColors ? (bodyFontSize + 2) : 0;
                helpers$1.each(body, function(bodyItem) {
                    helpers$1.each(bodyItem.before, maxLineWidth);
                    helpers$1.each(bodyItem.lines, maxLineWidth);
                    helpers$1.each(bodyItem.after, maxLineWidth);
                });

                // Reset back to 0
                widthPadding = 0;

                // Footer width
                ctx.font = helpers$1.fontString(footerFontSize, model._footerFontStyle, model._footerFontFamily);
                helpers$1.each(model.footer, maxLineWidth);

                // Add padding
                width += 2 * model.xPadding;

                return {
                    width: width,
                    height: height
                };
            }

            /**
             * Helper to get the alignment of a tooltip given the size
             */
            function determineAlignment(tooltip, size) {
                var model = tooltip._model;
                var chart = tooltip._chart;
                var chartArea = tooltip._chart.chartArea;
                var xAlign = 'center';
                var yAlign = 'center';

                if (model.y < size.height) {
                    yAlign = 'top';
                } else if (model.y > (chart.height - size.height)) {
                    yAlign = 'bottom';
                }

                var lf, rf; // functions to determine left, right alignment
                var olf, orf; // functions to determine if left/right alignment causes tooltip to go outside chart
                var yf; // function to get the y alignment if the tooltip goes outside of the left or right edges
                var midX = (chartArea.left + chartArea.right) / 2;
                var midY = (chartArea.top + chartArea.bottom) / 2;

                if (yAlign === 'center') {
                    lf = function(x) {
                        return x <= midX;
                    };
                    rf = function(x) {
                        return x > midX;
                    };
                } else {
                    lf = function(x) {
                        return x <= (size.width / 2);
                    };
                    rf = function(x) {
                        return x >= (chart.width - (size.width / 2));
                    };
                }

                olf = function(x) {
                    return x + size.width + model.caretSize + model.caretPadding > chart.width;
                };
                orf = function(x) {
                    return x - size.width - model.caretSize - model.caretPadding < 0;
                };
                yf = function(y) {
                    return y <= midY ? 'top' : 'bottom';
                };

                if (lf(model.x)) {
                    xAlign = 'left';

                    // Is tooltip too wide and goes over the right side of the chart.?
                    if (olf(model.x)) {
                        xAlign = 'center';
                        yAlign = yf(model.y);
                    }
                } else if (rf(model.x)) {
                    xAlign = 'right';

                    // Is tooltip too wide and goes outside left edge of canvas?
                    if (orf(model.x)) {
                        xAlign = 'center';
                        yAlign = yf(model.y);
                    }
                }

                var opts = tooltip._options;
                return {
                    xAlign: opts.xAlign ? opts.xAlign : xAlign,
                    yAlign: opts.yAlign ? opts.yAlign : yAlign
                };
            }

            /**
             * Helper to get the location a tooltip needs to be placed at given the initial position (via the vm) and the size and alignment
             */
            function getBackgroundPoint(vm, size, alignment, chart) {
                // Background Position
                var x = vm.x;
                var y = vm.y;

                var caretSize = vm.caretSize;
                var caretPadding = vm.caretPadding;
                var cornerRadius = vm.cornerRadius;
                var xAlign = alignment.xAlign;
                var yAlign = alignment.yAlign;
                var paddingAndSize = caretSize + caretPadding;
                var radiusAndPadding = cornerRadius + caretPadding;

                if (xAlign === 'right') {
                    x -= size.width;
                } else if (xAlign === 'center') {
                    x -= (size.width / 2);
                    if (x + size.width > chart.width) {
                        x = chart.width - size.width;
                    }
                    if (x < 0) {
                        x = 0;
                    }
                }

                if (yAlign === 'top') {
                    y += paddingAndSize;
                } else if (yAlign === 'bottom') {
                    y -= size.height + paddingAndSize;
                } else {
                    y -= (size.height / 2);
                }

                if (yAlign === 'center') {
                    if (xAlign === 'left') {
                        x += paddingAndSize;
                    } else if (xAlign === 'right') {
                        x -= paddingAndSize;
                    }
                } else if (xAlign === 'left') {
                    x -= radiusAndPadding;
                } else if (xAlign === 'right') {
                    x += radiusAndPadding;
                }

                return {
                    x: x,
                    y: y
                };
            }

            function getAlignedX(vm, align) {
                return align === 'center'
                    ? vm.x + vm.width / 2
                    : align === 'right'
                        ? vm.x + vm.width - vm.xPadding
                        : vm.x + vm.xPadding;
            }

            /**
             * Helper to build before and after body lines
             */
            function getBeforeAfterBodyLines(callback) {
                return pushOrConcat([], splitNewlines(callback));
            }

            var exports$4 = core_element.extend({
                initialize: function() {
                    this._model = getBaseModel(this._options);
                    this._lastActive = [];
                },

                // Get the title
                // Args are: (tooltipItem, data)
                getTitle: function() {
                    var me = this;
                    var opts = me._options;
                    var callbacks = opts.callbacks;

                    var beforeTitle = callbacks.beforeTitle.apply(me, arguments);
                    var title = callbacks.title.apply(me, arguments);
                    var afterTitle = callbacks.afterTitle.apply(me, arguments);

                    var lines = [];
                    lines = pushOrConcat(lines, splitNewlines(beforeTitle));
                    lines = pushOrConcat(lines, splitNewlines(title));
                    lines = pushOrConcat(lines, splitNewlines(afterTitle));

                    return lines;
                },

                // Args are: (tooltipItem, data)
                getBeforeBody: function() {
                    return getBeforeAfterBodyLines(this._options.callbacks.beforeBody.apply(this, arguments));
                },

                // Args are: (tooltipItem, data)
                getBody: function(tooltipItems, data) {
                    var me = this;
                    var callbacks = me._options.callbacks;
                    var bodyItems = [];

                    helpers$1.each(tooltipItems, function(tooltipItem) {
                        var bodyItem = {
                            before: [],
                            lines: [],
                            after: []
                        };
                        pushOrConcat(bodyItem.before, splitNewlines(callbacks.beforeLabel.call(me, tooltipItem, data)));
                        pushOrConcat(bodyItem.lines, callbacks.label.call(me, tooltipItem, data));
                        pushOrConcat(bodyItem.after, splitNewlines(callbacks.afterLabel.call(me, tooltipItem, data)));

                        bodyItems.push(bodyItem);
                    });

                    return bodyItems;
                },

                // Args are: (tooltipItem, data)
                getAfterBody: function() {
                    return getBeforeAfterBodyLines(this._options.callbacks.afterBody.apply(this, arguments));
                },

                // Get the footer and beforeFooter and afterFooter lines
                // Args are: (tooltipItem, data)
                getFooter: function() {
                    var me = this;
                    var callbacks = me._options.callbacks;

                    var beforeFooter = callbacks.beforeFooter.apply(me, arguments);
                    var footer = callbacks.footer.apply(me, arguments);
                    var afterFooter = callbacks.afterFooter.apply(me, arguments);

                    var lines = [];
                    lines = pushOrConcat(lines, splitNewlines(beforeFooter));
                    lines = pushOrConcat(lines, splitNewlines(footer));
                    lines = pushOrConcat(lines, splitNewlines(afterFooter));

                    return lines;
                },

                update: function(changed) {
                    var me = this;
                    var opts = me._options;

                    // Need to regenerate the model because its faster than using extend and it is necessary due to the optimization in Chart.Element.transition
                    // that does _view = _model if ease === 1. This causes the 2nd tooltip update to set properties in both the view and model at the same time
                    // which breaks any animations.
                    var existingModel = me._model;
                    var model = me._model = getBaseModel(opts);
                    var active = me._active;

                    var data = me._data;

                    // In the case where active.length === 0 we need to keep these at existing values for good animations
                    var alignment = {
                        xAlign: existingModel.xAlign,
                        yAlign: existingModel.yAlign
                    };
                    var backgroundPoint = {
                        x: existingModel.x,
                        y: existingModel.y
                    };
                    var tooltipSize = {
                        width: existingModel.width,
                        height: existingModel.height
                    };
                    var tooltipPosition = {
                        x: existingModel.caretX,
                        y: existingModel.caretY
                    };

                    var i, len;

                    if (active.length) {
                        model.opacity = 1;

                        var labelColors = [];
                        var labelTextColors = [];
                        tooltipPosition = positioners[opts.position].call(me, active, me._eventPosition);

                        var tooltipItems = [];
                        for (i = 0, len = active.length; i < len; ++i) {
                            tooltipItems.push(createTooltipItem(active[i]));
                        }

                        // If the user provided a filter function, use it to modify the tooltip items
                        if (opts.filter) {
                            tooltipItems = tooltipItems.filter(function(a) {
                                return opts.filter(a, data);
                            });
                        }

                        // If the user provided a sorting function, use it to modify the tooltip items
                        if (opts.itemSort) {
                            tooltipItems = tooltipItems.sort(function(a, b) {
                                return opts.itemSort(a, b, data);
                            });
                        }

                        // Determine colors for boxes
                        helpers$1.each(tooltipItems, function(tooltipItem) {
                            labelColors.push(opts.callbacks.labelColor.call(me, tooltipItem, me._chart));
                            labelTextColors.push(opts.callbacks.labelTextColor.call(me, tooltipItem, me._chart));
                        });


                        // Build the Text Lines
                        model.title = me.getTitle(tooltipItems, data);
                        model.beforeBody = me.getBeforeBody(tooltipItems, data);
                        model.body = me.getBody(tooltipItems, data);
                        model.afterBody = me.getAfterBody(tooltipItems, data);
                        model.footer = me.getFooter(tooltipItems, data);

                        // Initial positioning and colors
                        model.x = tooltipPosition.x;
                        model.y = tooltipPosition.y;
                        model.caretPadding = opts.caretPadding;
                        model.labelColors = labelColors;
                        model.labelTextColors = labelTextColors;

                        // data points
                        model.dataPoints = tooltipItems;

                        // We need to determine alignment of the tooltip
                        tooltipSize = getTooltipSize(this, model);
                        alignment = determineAlignment(this, tooltipSize);
                        // Final Size and Position
                        backgroundPoint = getBackgroundPoint(model, tooltipSize, alignment, me._chart);
                    } else {
                        model.opacity = 0;
                    }

                    model.xAlign = alignment.xAlign;
                    model.yAlign = alignment.yAlign;
                    model.x = backgroundPoint.x;
                    model.y = backgroundPoint.y;
                    model.width = tooltipSize.width;
                    model.height = tooltipSize.height;

                    // Point where the caret on the tooltip points to
                    model.caretX = tooltipPosition.x;
                    model.caretY = tooltipPosition.y;

                    me._model = model;

                    if (changed && opts.custom) {
                        opts.custom.call(me, model);
                    }

                    return me;
                },

                drawCaret: function(tooltipPoint, size) {
                    var ctx = this._chart.ctx;
                    var vm = this._view;
                    var caretPosition = this.getCaretPosition(tooltipPoint, size, vm);

                    ctx.lineTo(caretPosition.x1, caretPosition.y1);
                    ctx.lineTo(caretPosition.x2, caretPosition.y2);
                    ctx.lineTo(caretPosition.x3, caretPosition.y3);
                },
                getCaretPosition: function(tooltipPoint, size, vm) {
                    var x1, x2, x3, y1, y2, y3;
                    var caretSize = vm.caretSize;
                    var cornerRadius = vm.cornerRadius;
                    var xAlign = vm.xAlign;
                    var yAlign = vm.yAlign;
                    var ptX = tooltipPoint.x;
                    var ptY = tooltipPoint.y;
                    var width = size.width;
                    var height = size.height;

                    if (yAlign === 'center') {
                        y2 = ptY + (height / 2);

                        if (xAlign === 'left') {
                            x1 = ptX;
                            x2 = x1 - caretSize;
                            x3 = x1;

                            y1 = y2 + caretSize;
                            y3 = y2 - caretSize;
                        } else {
                            x1 = ptX + width;
                            x2 = x1 + caretSize;
                            x3 = x1;

                            y1 = y2 - caretSize;
                            y3 = y2 + caretSize;
                        }
                    } else {
                        if (xAlign === 'left') {
                            x2 = ptX + cornerRadius + (caretSize);
                            x1 = x2 - caretSize;
                            x3 = x2 + caretSize;
                        } else if (xAlign === 'right') {
                            x2 = ptX + width - cornerRadius - caretSize;
                            x1 = x2 - caretSize;
                            x3 = x2 + caretSize;
                        } else {
                            x2 = vm.caretX;
                            x1 = x2 - caretSize;
                            x3 = x2 + caretSize;
                        }
                        if (yAlign === 'top') {
                            y1 = ptY;
                            y2 = y1 - caretSize;
                            y3 = y1;
                        } else {
                            y1 = ptY + height;
                            y2 = y1 + caretSize;
                            y3 = y1;
                            // invert drawing order
                            var tmp = x3;
                            x3 = x1;
                            x1 = tmp;
                        }
                    }
                    return {x1: x1, x2: x2, x3: x3, y1: y1, y2: y2, y3: y3};
                },

                drawTitle: function(pt, vm, ctx) {
                    var title = vm.title;
                    var length = title.length;
                    var titleFontSize, titleSpacing, i;

                    if (length) {
                        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);

                        pt.x = getAlignedX(vm, vm._titleAlign);

                        ctx.textAlign = rtlHelper.textAlign(vm._titleAlign);
                        ctx.textBaseline = 'middle';

                        titleFontSize = vm.titleFontSize;
                        titleSpacing = vm.titleSpacing;

                        ctx.fillStyle = vm.titleFontColor;
                        ctx.font = helpers$1.fontString(titleFontSize, vm._titleFontStyle, vm._titleFontFamily);

                        for (i = 0; i < length; ++i) {
                            ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFontSize / 2);
                            pt.y += titleFontSize + titleSpacing; // Line Height and spacing

                            if (i + 1 === length) {
                                pt.y += vm.titleMarginBottom - titleSpacing; // If Last, add margin, remove spacing
                            }
                        }
                    }
                },

                drawBody: function(pt, vm, ctx) {
                    var bodyFontSize = vm.bodyFontSize;
                    var bodySpacing = vm.bodySpacing;
                    var bodyAlign = vm._bodyAlign;
                    var body = vm.body;
                    var drawColorBoxes = vm.displayColors;
                    var xLinePadding = 0;
                    var colorX = drawColorBoxes ? getAlignedX(vm, 'left') : 0;

                    var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);

                    var fillLineOfText = function(line) {
                        ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyFontSize / 2);
                        pt.y += bodyFontSize + bodySpacing;
                    };

                    var bodyItem, textColor, labelColors, lines, i, j, ilen, jlen;
                    var bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);

                    ctx.textAlign = bodyAlign;
                    ctx.textBaseline = 'middle';
                    ctx.font = helpers$1.fontString(bodyFontSize, vm._bodyFontStyle, vm._bodyFontFamily);

                    pt.x = getAlignedX(vm, bodyAlignForCalculation);

                    // Before body lines
                    ctx.fillStyle = vm.bodyFontColor;
                    helpers$1.each(vm.beforeBody, fillLineOfText);

                    xLinePadding = drawColorBoxes && bodyAlignForCalculation !== 'right'
                        ? bodyAlign === 'center' ? (bodyFontSize / 2 + 1) : (bodyFontSize + 2)
                        : 0;

                    // Draw body lines now
                    for (i = 0, ilen = body.length; i < ilen; ++i) {
                        bodyItem = body[i];
                        textColor = vm.labelTextColors[i];
                        labelColors = vm.labelColors[i];

                        ctx.fillStyle = textColor;
                        helpers$1.each(bodyItem.before, fillLineOfText);

                        lines = bodyItem.lines;
                        for (j = 0, jlen = lines.length; j < jlen; ++j) {
                            // Draw Legend-like boxes if needed
                            if (drawColorBoxes) {
                                var rtlColorX = rtlHelper.x(colorX);

                                // Fill a white rect so that colours merge nicely if the opacity is < 1
                                ctx.fillStyle = vm.legendColorBackground;
                                ctx.fillRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);

                                // Border
                                ctx.lineWidth = 1;
                                ctx.strokeStyle = labelColors.borderColor;
                                ctx.strokeRect(rtlHelper.leftForLtr(rtlColorX, bodyFontSize), pt.y, bodyFontSize, bodyFontSize);

                                // Inner square
                                ctx.fillStyle = labelColors.backgroundColor;
                                ctx.fillRect(rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), bodyFontSize - 2), pt.y + 1, bodyFontSize - 2, bodyFontSize - 2);
                                ctx.fillStyle = textColor;
                            }

                            fillLineOfText(lines[j]);
                        }

                        helpers$1.each(bodyItem.after, fillLineOfText);
                    }

                    // Reset back to 0 for after body
                    xLinePadding = 0;

                    // After body lines
                    helpers$1.each(vm.afterBody, fillLineOfText);
                    pt.y -= bodySpacing; // Remove last body spacing
                },

                drawFooter: function(pt, vm, ctx) {
                    var footer = vm.footer;
                    var length = footer.length;
                    var footerFontSize, i;

                    if (length) {
                        var rtlHelper = getRtlHelper(vm.rtl, vm.x, vm.width);

                        pt.x = getAlignedX(vm, vm._footerAlign);
                        pt.y += vm.footerMarginTop;

                        ctx.textAlign = rtlHelper.textAlign(vm._footerAlign);
                        ctx.textBaseline = 'middle';

                        footerFontSize = vm.footerFontSize;

                        ctx.fillStyle = vm.footerFontColor;
                        ctx.font = helpers$1.fontString(footerFontSize, vm._footerFontStyle, vm._footerFontFamily);

                        for (i = 0; i < length; ++i) {
                            ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFontSize / 2);
                            pt.y += footerFontSize + vm.footerSpacing;
                        }
                    }
                },

                drawBackground: function(pt, vm, ctx, tooltipSize) {
                    ctx.fillStyle = vm.backgroundColor;
                    ctx.strokeStyle = vm.borderColor;
                    ctx.lineWidth = vm.borderWidth;
                    var xAlign = vm.xAlign;
                    var yAlign = vm.yAlign;
                    var x = pt.x;
                    var y = pt.y;
                    var width = tooltipSize.width;
                    var height = tooltipSize.height;
                    var radius = vm.cornerRadius;

                    ctx.beginPath();
                    ctx.moveTo(x + radius, y);
                    if (yAlign === 'top') {
                        this.drawCaret(pt, tooltipSize);
                    }
                    ctx.lineTo(x + width - radius, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                    if (yAlign === 'center' && xAlign === 'right') {
                        this.drawCaret(pt, tooltipSize);
                    }
                    ctx.lineTo(x + width, y + height - radius);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                    if (yAlign === 'bottom') {
                        this.drawCaret(pt, tooltipSize);
                    }
                    ctx.lineTo(x + radius, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                    if (yAlign === 'center' && xAlign === 'left') {
                        this.drawCaret(pt, tooltipSize);
                    }
                    ctx.lineTo(x, y + radius);
                    ctx.quadraticCurveTo(x, y, x + radius, y);
                    ctx.closePath();

                    ctx.fill();

                    if (vm.borderWidth > 0) {
                        ctx.stroke();
                    }
                },

                draw: function() {
                    var ctx = this._chart.ctx;
                    var vm = this._view;

                    if (vm.opacity === 0) {
                        return;
                    }

                    var tooltipSize = {
                        width: vm.width,
                        height: vm.height
                    };
                    var pt = {
                        x: vm.x,
                        y: vm.y
                    };

                    // IE11/Edge does not like very small opacities, so snap to 0
                    var opacity = Math.abs(vm.opacity < 1e-3) ? 0 : vm.opacity;

                    // Truthy/falsey value for empty tooltip
                    var hasTooltipContent = vm.title.length || vm.beforeBody.length || vm.body.length || vm.afterBody.length || vm.footer.length;

                    if (this._options.enabled && hasTooltipContent) {
                        ctx.save();
                        ctx.globalAlpha = opacity;

                        // Draw Background
                        this.drawBackground(pt, vm, ctx, tooltipSize);

                        // Draw Title, Body, and Footer
                        pt.y += vm.yPadding;

                        helpers$1.rtl.overrideTextDirection(ctx, vm.textDirection);

                        // Titles
                        this.drawTitle(pt, vm, ctx);

                        // Body
                        this.drawBody(pt, vm, ctx);

                        // Footer
                        this.drawFooter(pt, vm, ctx);

                        helpers$1.rtl.restoreTextDirection(ctx, vm.textDirection);

                        ctx.restore();
                    }
                },

                /**
                 * Handle an event
                 * @private
                 * @param {IEvent} event - The event to handle
                 * @returns {boolean} true if the tooltip changed
                 */
                handleEvent: function(e) {
                    var me = this;
                    var options = me._options;
                    var changed = false;

                    me._lastActive = me._lastActive || [];

                    // Find Active Elements for tooltips
                    if (e.type === 'mouseout') {
                        me._active = [];
                    } else {
                        me._active = me._chart.getElementsAtEventForMode(e, options.mode, options);
                        if (options.reverse) {
                            me._active.reverse();
                        }
                    }

                    // Remember Last Actives
                    changed = !helpers$1.arrayEquals(me._active, me._lastActive);

                    // Only handle target event on tooltip change
                    if (changed) {
                        me._lastActive = me._active;

                        if (options.enabled || options.custom) {
                            me._eventPosition = {
                                x: e.x,
                                y: e.y
                            };

                            me.update(true);
                            me.pivot();
                        }
                    }

                    return changed;
                }
            });

            /**
             * @namespace Chart.Tooltip.positioners
             */
            var positioners_1 = positioners;

            var core_tooltip = exports$4;
            core_tooltip.positioners = positioners_1;

            var valueOrDefault$9 = helpers$1.valueOrDefault;

            core_defaults._set('global', {
                elements: {},
                events: [
                    'mousemove',
                    'mouseout',
                    'click',
                    'touchstart',
                    'touchmove'
                ],
                hover: {
                    onHover: null,
                    mode: 'nearest',
                    intersect: true,
                    animationDuration: 400
                },
                onClick: null,
                maintainAspectRatio: true,
                responsive: true,
                responsiveAnimationDuration: 0
            });

            /**
             * Recursively merge the given config objects representing the `scales` option
             * by incorporating scale defaults in `xAxes` and `yAxes` array items, then
             * returns a deep copy of the result, thus doesn't alter inputs.
             */
            function mergeScaleConfig(/* config objects ... */) {
                return helpers$1.merge({}, [].slice.call(arguments), {
                    merger: function(key, target, source, options) {
                        if (key === 'xAxes' || key === 'yAxes') {
                            var slen = source[key].length;
                            var i, type, scale;

                            if (!target[key]) {
                                target[key] = [];
                            }

                            for (i = 0; i < slen; ++i) {
                                scale = source[key][i];
                                type = valueOrDefault$9(scale.type, key === 'xAxes' ? 'category' : 'linear');

                                if (i >= target[key].length) {
                                    target[key].push({});
                                }

                                if (!target[key][i].type || (scale.type && scale.type !== target[key][i].type)) {
                                    // new/untyped scale or type changed: let's apply the new defaults
                                    // then merge source scale to correctly overwrite the defaults.
                                    helpers$1.merge(target[key][i], [core_scaleService.getScaleDefaults(type), scale]);
                                } else {
                                    // scales type are the same
                                    helpers$1.merge(target[key][i], scale);
                                }
                            }
                        } else {
                            helpers$1._merger(key, target, source, options);
                        }
                    }
                });
            }

            /**
             * Recursively merge the given config objects as the root options by handling
             * default scale options for the `scales` and `scale` properties, then returns
             * a deep copy of the result, thus doesn't alter inputs.
             */
            function mergeConfig(/* config objects ... */) {
                return helpers$1.merge({}, [].slice.call(arguments), {
                    merger: function(key, target, source, options) {
                        var tval = target[key] || {};
                        var sval = source[key];

                        if (key === 'scales') {
                            // scale config merging is complex. Add our own function here for that
                            target[key] = mergeScaleConfig(tval, sval);
                        } else if (key === 'scale') {
                            // used in polar area & radar charts since there is only one scale
                            target[key] = helpers$1.merge(tval, [core_scaleService.getScaleDefaults(sval.type), sval]);
                        } else {
                            helpers$1._merger(key, target, source, options);
                        }
                    }
                });
            }

            function initConfig(config) {
                config = config || {};

                // Do NOT use mergeConfig for the data object because this method merges arrays
                // and so would change references to labels and datasets, preventing data updates.
                var data = config.data = config.data || {};
                data.datasets = data.datasets || [];
                data.labels = data.labels || [];

                config.options = mergeConfig(
                    core_defaults.global,
                    core_defaults[config.type],
                    config.options || {});

                return config;
            }

            function updateConfig(chart) {
                var newOptions = chart.options;

                helpers$1.each(chart.scales, function(scale) {
                    core_layouts.removeBox(chart, scale);
                });

                newOptions = mergeConfig(
                    core_defaults.global,
                    core_defaults[chart.config.type],
                    newOptions);

                chart.options = chart.config.options = newOptions;
                chart.ensureScalesHaveIDs();
                chart.buildOrUpdateScales();

                // Tooltip
                chart.tooltip._options = newOptions.tooltips;
                chart.tooltip.initialize();
            }

            function nextAvailableScaleId(axesOpts, prefix, index) {
                var id;
                var hasId = function(obj) {
                    return obj.id === id;
                };

                do {
                    id = prefix + index++;
                } while (helpers$1.findIndex(axesOpts, hasId) >= 0);

                return id;
            }

            function positionIsHorizontal(position) {
                return position === 'top' || position === 'bottom';
            }

            function compare2Level(l1, l2) {
                return function(a, b) {
                    return a[l1] === b[l1]
                        ? a[l2] - b[l2]
                        : a[l1] - b[l1];
                };
            }

            var Chart = function(item, config) {
                this.construct(item, config);
                return this;
            };

            helpers$1.extend(Chart.prototype, /** @lends Chart */ {
                /**
                 * @private
                 */
                construct: function(item, config) {
                    var me = this;

                    config = initConfig(config);

                    var context = platform.acquireContext(item, config);
                    var canvas = context && context.canvas;
                    var height = canvas && canvas.height;
                    var width = canvas && canvas.width;

                    me.id = helpers$1.uid();
                    me.ctx = context;
                    me.canvas = canvas;
                    me.config = config;
                    me.width = width;
                    me.height = height;
                    me.aspectRatio = height ? width / height : null;
                    me.options = config.options;
                    me._bufferedRender = false;
                    me._layers = [];

                    /**
                     * Provided for backward compatibility, Chart and Chart.Controller have been merged,
                     * the "instance" still need to be defined since it might be called from plugins.
                     * @prop Chart#chart
                     * @deprecated since version 2.6.0
                     * @todo remove at version 3
                     * @private
                     */
                    me.chart = me;
                    me.controller = me; // chart.chart.controller #inception

                    // Add the chart instance to the global namespace
                    Chart.instances[me.id] = me;

                    // Define alias to the config data: `chart.data === chart.config.data`
                    Object.defineProperty(me, 'data', {
                        get: function() {
                            return me.config.data;
                        },
                        set: function(value) {
                            me.config.data = value;
                        }
                    });

                    if (!context || !canvas) {
                        // The given item is not a compatible context2d element, let's return before finalizing
                        // the chart initialization but after setting basic chart / controller properties that
                        // can help to figure out that the chart is not valid (e.g chart.canvas !== null);
                        // https://github.com/chartjs/Chart.js/issues/2807
                        console.error("Failed to create chart: can't acquire context from the given item");
                        return;
                    }

                    me.initialize();
                    me.update();
                },

                /**
                 * @private
                 */
                initialize: function() {
                    var me = this;

                    // Before init plugin notification
                    core_plugins.notify(me, 'beforeInit');

                    helpers$1.retinaScale(me, me.options.devicePixelRatio);

                    me.bindEvents();

                    if (me.options.responsive) {
                        // Initial resize before chart draws (must be silent to preserve initial animations).
                        me.resize(true);
                    }

                    me.initToolTip();

                    // After init plugin notification
                    core_plugins.notify(me, 'afterInit');

                    return me;
                },

                clear: function() {
                    helpers$1.canvas.clear(this);
                    return this;
                },

                stop: function() {
                    // Stops any current animation loop occurring
                    core_animations.cancelAnimation(this);
                    return this;
                },

                resize: function(silent) {
                    var me = this;
                    var options = me.options;
                    var canvas = me.canvas;
                    var aspectRatio = (options.maintainAspectRatio && me.aspectRatio) || null;

                    // the canvas render width and height will be casted to integers so make sure that
                    // the canvas display style uses the same integer values to avoid blurring effect.

                    // Set to 0 instead of canvas.size because the size defaults to 300x150 if the element is collapsed
                    var newWidth = Math.max(0, Math.floor(helpers$1.getMaximumWidth(canvas)));
                    var newHeight = Math.max(0, Math.floor(aspectRatio ? newWidth / aspectRatio : helpers$1.getMaximumHeight(canvas)));

                    if (me.width === newWidth && me.height === newHeight) {
                        return;
                    }

                    canvas.width = me.width = newWidth;
                    canvas.height = me.height = newHeight;
                    canvas.style.width = newWidth + 'px';
                    canvas.style.height = newHeight + 'px';

                    helpers$1.retinaScale(me, options.devicePixelRatio);

                    if (!silent) {
                        // Notify any plugins about the resize
                        var newSize = {width: newWidth, height: newHeight};
                        core_plugins.notify(me, 'resize', [newSize]);

                        // Notify of resize
                        if (options.onResize) {
                            options.onResize(me, newSize);
                        }

                        me.stop();
                        me.update({
                            duration: options.responsiveAnimationDuration
                        });
                    }
                },

                ensureScalesHaveIDs: function() {
                    var options = this.options;
                    var scalesOptions = options.scales || {};
                    var scaleOptions = options.scale;

                    helpers$1.each(scalesOptions.xAxes, function(xAxisOptions, index) {
                        if (!xAxisOptions.id) {
                            xAxisOptions.id = nextAvailableScaleId(scalesOptions.xAxes, 'x-axis-', index);
                        }
                    });

                    helpers$1.each(scalesOptions.yAxes, function(yAxisOptions, index) {
                        if (!yAxisOptions.id) {
                            yAxisOptions.id = nextAvailableScaleId(scalesOptions.yAxes, 'y-axis-', index);
                        }
                    });

                    if (scaleOptions) {
                        scaleOptions.id = scaleOptions.id || 'scale';
                    }
                },

                /**
                 * Builds a map of scale ID to scale object for future lookup.
                 */
                buildOrUpdateScales: function() {
                    var me = this;
                    var options = me.options;
                    var scales = me.scales || {};
                    var items = [];
                    var updated = Object.keys(scales).reduce(function(obj, id) {
                        obj[id] = false;
                        return obj;
                    }, {});

                    if (options.scales) {
                        items = items.concat(
                            (options.scales.xAxes || []).map(function(xAxisOptions) {
                                return {options: xAxisOptions, dtype: 'category', dposition: 'bottom'};
                            }),
                            (options.scales.yAxes || []).map(function(yAxisOptions) {
                                return {options: yAxisOptions, dtype: 'linear', dposition: 'left'};
                            })
                        );
                    }

                    if (options.scale) {
                        items.push({
                            options: options.scale,
                            dtype: 'radialLinear',
                            isDefault: true,
                            dposition: 'chartArea'
                        });
                    }

                    helpers$1.each(items, function(item) {
                        var scaleOptions = item.options;
                        var id = scaleOptions.id;
                        var scaleType = valueOrDefault$9(scaleOptions.type, item.dtype);

                        if (positionIsHorizontal(scaleOptions.position) !== positionIsHorizontal(item.dposition)) {
                            scaleOptions.position = item.dposition;
                        }

                        updated[id] = true;
                        var scale = null;
                        if (id in scales && scales[id].type === scaleType) {
                            scale = scales[id];
                            scale.options = scaleOptions;
                            scale.ctx = me.ctx;
                            scale.chart = me;
                        } else {
                            var scaleClass = core_scaleService.getScaleConstructor(scaleType);
                            if (!scaleClass) {
                                return;
                            }
                            scale = new scaleClass({
                                id: id,
                                type: scaleType,
                                options: scaleOptions,
                                ctx: me.ctx,
                                chart: me
                            });
                            scales[scale.id] = scale;
                        }

                        scale.mergeTicksOptions();

                        // TODO(SB): I think we should be able to remove this custom case (options.scale)
                        // and consider it as a regular scale part of the "scales"" map only! This would
                        // make the logic easier and remove some useless? custom code.
                        if (item.isDefault) {
                            me.scale = scale;
                        }
                    });
                    // clear up discarded scales
                    helpers$1.each(updated, function(hasUpdated, id) {
                        if (!hasUpdated) {
                            delete scales[id];
                        }
                    });

                    me.scales = scales;

                    core_scaleService.addScalesToLayout(this);
                },

                buildOrUpdateControllers: function() {
                    var me = this;
                    var newControllers = [];
                    var datasets = me.data.datasets;
                    var i, ilen;

                    for (i = 0, ilen = datasets.length; i < ilen; i++) {
                        var dataset = datasets[i];
                        var meta = me.getDatasetMeta(i);
                        var type = dataset.type || me.config.type;

                        if (meta.type && meta.type !== type) {
                            me.destroyDatasetMeta(i);
                            meta = me.getDatasetMeta(i);
                        }
                        meta.type = type;
                        meta.order = dataset.order || 0;
                        meta.index = i;

                        if (meta.controller) {
                            meta.controller.updateIndex(i);
                            meta.controller.linkScales();
                        } else {
                            var ControllerClass = controllers[meta.type];
                            if (ControllerClass === undefined) {
                                throw new Error('"' + meta.type + '" is not a chart type.');
                            }

                            meta.controller = new ControllerClass(me, i);
                            newControllers.push(meta.controller);
                        }
                    }

                    return newControllers;
                },

                /**
                 * Reset the elements of all datasets
                 * @private
                 */
                resetElements: function() {
                    var me = this;
                    helpers$1.each(me.data.datasets, function(dataset, datasetIndex) {
                        me.getDatasetMeta(datasetIndex).controller.reset();
                    }, me);
                },

                /**
                 * Resets the chart back to it's state before the initial animation
                 */
                reset: function() {
                    this.resetElements();
                    this.tooltip.initialize();
                },

                update: function(config) {
                    var me = this;
                    var i, ilen;

                    if (!config || typeof config !== 'object') {
                        // backwards compatibility
                        config = {
                            duration: config,
                            lazy: arguments[1]
                        };
                    }

                    updateConfig(me);

                    // plugins options references might have change, let's invalidate the cache
                    // https://github.com/chartjs/Chart.js/issues/5111#issuecomment-355934167
                    core_plugins._invalidate(me);

                    if (core_plugins.notify(me, 'beforeUpdate') === false) {
                        return;
                    }

                    // In case the entire data object changed
                    me.tooltip._data = me.data;

                    // Make sure dataset controllers are updated and new controllers are reset
                    var newControllers = me.buildOrUpdateControllers();

                    // Make sure all dataset controllers have correct meta data counts
                    for (i = 0, ilen = me.data.datasets.length; i < ilen; i++) {
                        me.getDatasetMeta(i).controller.buildOrUpdateElements();
                    }

                    me.updateLayout();

                    // Can only reset the new controllers after the scales have been updated
                    if (me.options.animation && me.options.animation.duration) {
                        helpers$1.each(newControllers, function(controller) {
                            controller.reset();
                        });
                    }

                    me.updateDatasets();

                    // Need to reset tooltip in case it is displayed with elements that are removed
                    // after update.
                    me.tooltip.initialize();

                    // Last active contains items that were previously in the tooltip.
                    // When we reset the tooltip, we need to clear it
                    me.lastActive = [];

                    // Do this before render so that any plugins that need final scale updates can use it
                    core_plugins.notify(me, 'afterUpdate');

                    me._layers.sort(compare2Level('z', '_idx'));

                    if (me._bufferedRender) {
                        me._bufferedRequest = {
                            duration: config.duration,
                            easing: config.easing,
                            lazy: config.lazy
                        };
                    } else {
                        me.render(config);
                    }
                },

                /**
                 * Updates the chart layout unless a plugin returns `false` to the `beforeLayout`
                 * hook, in which case, plugins will not be called on `afterLayout`.
                 * @private
                 */
                updateLayout: function() {
                    var me = this;

                    if (core_plugins.notify(me, 'beforeLayout') === false) {
                        return;
                    }

                    core_layouts.update(this, this.width, this.height);

                    me._layers = [];
                    helpers$1.each(me.boxes, function(box) {
                        // _configure is called twice, once in core.scale.update and once here.
                        // Here the boxes are fully updated and at their final positions.
                        if (box._configure) {
                            box._configure();
                        }
                        me._layers.push.apply(me._layers, box._layers());
                    }, me);

                    me._layers.forEach(function(item, index) {
                        item._idx = index;
                    });

                    /**
                     * Provided for backward compatibility, use `afterLayout` instead.
                     * @method IPlugin#afterScaleUpdate
                     * @deprecated since version 2.5.0
                     * @todo remove at version 3
                     * @private
                     */
                    core_plugins.notify(me, 'afterScaleUpdate');
                    core_plugins.notify(me, 'afterLayout');
                },

                /**
                 * Updates all datasets unless a plugin returns `false` to the `beforeDatasetsUpdate`
                 * hook, in which case, plugins will not be called on `afterDatasetsUpdate`.
                 * @private
                 */
                updateDatasets: function() {
                    var me = this;

                    if (core_plugins.notify(me, 'beforeDatasetsUpdate') === false) {
                        return;
                    }

                    for (var i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
                        me.updateDataset(i);
                    }

                    core_plugins.notify(me, 'afterDatasetsUpdate');
                },

                /**
                 * Updates dataset at index unless a plugin returns `false` to the `beforeDatasetUpdate`
                 * hook, in which case, plugins will not be called on `afterDatasetUpdate`.
                 * @private
                 */
                updateDataset: function(index) {
                    var me = this;
                    var meta = me.getDatasetMeta(index);
                    var args = {
                        meta: meta,
                        index: index
                    };

                    if (core_plugins.notify(me, 'beforeDatasetUpdate', [args]) === false) {
                        return;
                    }

                    meta.controller._update();

                    core_plugins.notify(me, 'afterDatasetUpdate', [args]);
                },

                render: function(config) {
                    var me = this;

                    if (!config || typeof config !== 'object') {
                        // backwards compatibility
                        config = {
                            duration: config,
                            lazy: arguments[1]
                        };
                    }

                    var animationOptions = me.options.animation;
                    var duration = valueOrDefault$9(config.duration, animationOptions && animationOptions.duration);
                    var lazy = config.lazy;

                    if (core_plugins.notify(me, 'beforeRender') === false) {
                        return;
                    }

                    var onComplete = function(animation) {
                        core_plugins.notify(me, 'afterRender');
                        helpers$1.callback(animationOptions && animationOptions.onComplete, [animation], me);
                    };

                    if (animationOptions && duration) {
                        var animation = new core_animation({
                            numSteps: duration / 16.66, // 60 fps
                            easing: config.easing || animationOptions.easing,

                            render: function(chart, animationObject) {
                                var easingFunction = helpers$1.easing.effects[animationObject.easing];
                                var currentStep = animationObject.currentStep;
                                var stepDecimal = currentStep / animationObject.numSteps;

                                chart.draw(easingFunction(stepDecimal), stepDecimal, currentStep);
                            },

                            onAnimationProgress: animationOptions.onProgress,
                            onAnimationComplete: onComplete
                        });

                        core_animations.addAnimation(me, animation, duration, lazy);
                    } else {
                        me.draw();

                        // See https://github.com/chartjs/Chart.js/issues/3781
                        onComplete(new core_animation({numSteps: 0, chart: me}));
                    }

                    return me;
                },

                draw: function(easingValue) {
                    var me = this;
                    var i, layers;

                    me.clear();

                    if (helpers$1.isNullOrUndef(easingValue)) {
                        easingValue = 1;
                    }

                    me.transition(easingValue);

                    if (me.width <= 0 || me.height <= 0) {
                        return;
                    }

                    if (core_plugins.notify(me, 'beforeDraw', [easingValue]) === false) {
                        return;
                    }

                    // Because of plugin hooks (before/afterDatasetsDraw), datasets can't
                    // currently be part of layers. Instead, we draw
                    // layers <= 0 before(default, backward compat), and the rest after
                    layers = me._layers;
                    for (i = 0; i < layers.length && layers[i].z <= 0; ++i) {
                        layers[i].draw(me.chartArea);
                    }

                    me.drawDatasets(easingValue);

                    // Rest of layers
                    for (; i < layers.length; ++i) {
                        layers[i].draw(me.chartArea);
                    }

                    me._drawTooltip(easingValue);

                    core_plugins.notify(me, 'afterDraw', [easingValue]);
                },

                /**
                 * @private
                 */
                transition: function(easingValue) {
                    var me = this;

                    for (var i = 0, ilen = (me.data.datasets || []).length; i < ilen; ++i) {
                        if (me.isDatasetVisible(i)) {
                            me.getDatasetMeta(i).controller.transition(easingValue);
                        }
                    }

                    me.tooltip.transition(easingValue);
                },

                /**
                 * @private
                 */
                _getSortedDatasetMetas: function(filterVisible) {
                    var me = this;
                    var datasets = me.data.datasets || [];
                    var result = [];
                    var i, ilen;

                    for (i = 0, ilen = datasets.length; i < ilen; ++i) {
                        if (!filterVisible || me.isDatasetVisible(i)) {
                            result.push(me.getDatasetMeta(i));
                        }
                    }

                    result.sort(compare2Level('order', 'index'));

                    return result;
                },

                /**
                 * @private
                 */
                _getSortedVisibleDatasetMetas: function() {
                    return this._getSortedDatasetMetas(true);
                },

                /**
                 * Draws all datasets unless a plugin returns `false` to the `beforeDatasetsDraw`
                 * hook, in which case, plugins will not be called on `afterDatasetsDraw`.
                 * @private
                 */
                drawDatasets: function(easingValue) {
                    var me = this;
                    var metasets, i;

                    if (core_plugins.notify(me, 'beforeDatasetsDraw', [easingValue]) === false) {
                        return;
                    }

                    metasets = me._getSortedVisibleDatasetMetas();
                    for (i = metasets.length - 1; i >= 0; --i) {
                        me.drawDataset(metasets[i], easingValue);
                    }

                    core_plugins.notify(me, 'afterDatasetsDraw', [easingValue]);
                },

                /**
                 * Draws dataset at index unless a plugin returns `false` to the `beforeDatasetDraw`
                 * hook, in which case, plugins will not be called on `afterDatasetDraw`.
                 * @private
                 */
                drawDataset: function(meta, easingValue) {
                    var me = this;
                    var args = {
                        meta: meta,
                        index: meta.index,
                        easingValue: easingValue
                    };

                    if (core_plugins.notify(me, 'beforeDatasetDraw', [args]) === false) {
                        return;
                    }

                    meta.controller.draw(easingValue);

                    core_plugins.notify(me, 'afterDatasetDraw', [args]);
                },

                /**
                 * Draws tooltip unless a plugin returns `false` to the `beforeTooltipDraw`
                 * hook, in which case, plugins will not be called on `afterTooltipDraw`.
                 * @private
                 */
                _drawTooltip: function(easingValue) {
                    var me = this;
                    var tooltip = me.tooltip;
                    var args = {
                        tooltip: tooltip,
                        easingValue: easingValue
                    };

                    if (core_plugins.notify(me, 'beforeTooltipDraw', [args]) === false) {
                        return;
                    }

                    tooltip.draw();

                    core_plugins.notify(me, 'afterTooltipDraw', [args]);
                },

                /**
                 * Get the single element that was clicked on
                 * @return An object containing the dataset index and element index of the matching element. Also contains the rectangle that was draw
                 */
                getElementAtEvent: function(e) {
                    return core_interaction.modes.single(this, e);
                },

                getElementsAtEvent: function(e) {
                    return core_interaction.modes.label(this, e, {intersect: true});
                },

                getElementsAtXAxis: function(e) {
                    return core_interaction.modes['x-axis'](this, e, {intersect: true});
                },

                getElementsAtEventForMode: function(e, mode, options) {
                    var method = core_interaction.modes[mode];
                    if (typeof method === 'function') {
                        return method(this, e, options);
                    }

                    return [];
                },

                getDatasetAtEvent: function(e) {
                    return core_interaction.modes.dataset(this, e, {intersect: true});
                },

                getDatasetMeta: function(datasetIndex) {
                    var me = this;
                    var dataset = me.data.datasets[datasetIndex];
                    if (!dataset._meta) {
                        dataset._meta = {};
                    }

                    var meta = dataset._meta[me.id];
                    if (!meta) {
                        meta = dataset._meta[me.id] = {
                            type: null,
                            data: [],
                            dataset: null,
                            controller: null,
                            hidden: null,			// See isDatasetVisible() comment
                            xAxisID: null,
                            yAxisID: null,
                            order: dataset.order || 0,
                            index: datasetIndex
                        };
                    }

                    return meta;
                },

                getVisibleDatasetCount: function() {
                    var count = 0;
                    for (var i = 0, ilen = this.data.datasets.length; i < ilen; ++i) {
                        if (this.isDatasetVisible(i)) {
                            count++;
                        }
                    }
                    return count;
                },

                isDatasetVisible: function(datasetIndex) {
                    var meta = this.getDatasetMeta(datasetIndex);

                    // meta.hidden is a per chart dataset hidden flag override with 3 states: if true or false,
                    // the dataset.hidden value is ignored, else if null, the dataset hidden state is returned.
                    return typeof meta.hidden === 'boolean' ? !meta.hidden : !this.data.datasets[datasetIndex].hidden;
                },

                generateLegend: function() {
                    return this.options.legendCallback(this);
                },

                /**
                 * @private
                 */
                destroyDatasetMeta: function(datasetIndex) {
                    var id = this.id;
                    var dataset = this.data.datasets[datasetIndex];
                    var meta = dataset._meta && dataset._meta[id];

                    if (meta) {
                        meta.controller.destroy();
                        delete dataset._meta[id];
                    }
                },

                destroy: function() {
                    var me = this;
                    var canvas = me.canvas;
                    var i, ilen;

                    me.stop();

                    // dataset controllers need to cleanup associated data
                    for (i = 0, ilen = me.data.datasets.length; i < ilen; ++i) {
                        me.destroyDatasetMeta(i);
                    }

                    if (canvas) {
                        me.unbindEvents();
                        helpers$1.canvas.clear(me);
                        platform.releaseContext(me.ctx);
                        me.canvas = null;
                        me.ctx = null;
                    }

                    core_plugins.notify(me, 'destroy');

                    delete Chart.instances[me.id];
                },

                toBase64Image: function() {
                    return this.canvas.toDataURL.apply(this.canvas, arguments);
                },

                initToolTip: function() {
                    var me = this;
                    me.tooltip = new core_tooltip({
                        _chart: me,
                        _chartInstance: me, // deprecated, backward compatibility
                        _data: me.data,
                        _options: me.options.tooltips
                    }, me);
                },

                /**
                 * @private
                 */
                bindEvents: function() {
                    var me = this;
                    var listeners = me._listeners = {};
                    var listener = function() {
                        me.eventHandler.apply(me, arguments);
                    };

                    helpers$1.each(me.options.events, function(type) {
                        platform.addEventListener(me, type, listener);
                        listeners[type] = listener;
                    });

                    // Elements used to detect size change should not be injected for non responsive charts.
                    // See https://github.com/chartjs/Chart.js/issues/2210
                    if (me.options.responsive) {
                        listener = function() {
                            me.resize();
                        };

                        platform.addEventListener(me, 'resize', listener);
                        listeners.resize = listener;
                    }
                },

                /**
                 * @private
                 */
                unbindEvents: function() {
                    var me = this;
                    var listeners = me._listeners;
                    if (!listeners) {
                        return;
                    }

                    delete me._listeners;
                    helpers$1.each(listeners, function(listener, type) {
                        platform.removeEventListener(me, type, listener);
                    });
                },

                updateHoverStyle: function(elements, mode, enabled) {
                    var prefix = enabled ? 'set' : 'remove';
                    var element, i, ilen;

                    for (i = 0, ilen = elements.length; i < ilen; ++i) {
                        element = elements[i];
                        if (element) {
                            this.getDatasetMeta(element._datasetIndex).controller[prefix + 'HoverStyle'](element);
                        }
                    }

                    if (mode === 'dataset') {
                        this.getDatasetMeta(elements[0]._datasetIndex).controller['_' + prefix + 'DatasetHoverStyle']();
                    }
                },

                /**
                 * @private
                 */
                eventHandler: function(e) {
                    var me = this;
                    var tooltip = me.tooltip;

                    if (core_plugins.notify(me, 'beforeEvent', [e]) === false) {
                        return;
                    }

                    // Buffer any update calls so that renders do not occur
                    me._bufferedRender = true;
                    me._bufferedRequest = null;

                    var changed = me.handleEvent(e);
                    // for smooth tooltip animations issue #4989
                    // the tooltip should be the source of change
                    // Animation check workaround:
                    // tooltip._start will be null when tooltip isn't animating
                    if (tooltip) {
                        changed = tooltip._start
                            ? tooltip.handleEvent(e)
                            : changed | tooltip.handleEvent(e);
                    }

                    core_plugins.notify(me, 'afterEvent', [e]);

                    var bufferedRequest = me._bufferedRequest;
                    if (bufferedRequest) {
                        // If we have an update that was triggered, we need to do a normal render
                        me.render(bufferedRequest);
                    } else if (changed && !me.animating) {
                        // If entering, leaving, or changing elements, animate the change via pivot
                        me.stop();

                        // We only need to render at this point. Updating will cause scales to be
                        // recomputed generating flicker & using more memory than necessary.
                        me.render({
                            duration: me.options.hover.animationDuration,
                            lazy: true
                        });
                    }

                    me._bufferedRender = false;
                    me._bufferedRequest = null;

                    return me;
                },

                /**
                 * Handle an event
                 * @private
                 * @param {IEvent} event the event to handle
                 * @return {boolean} true if the chart needs to re-render
                 */
                handleEvent: function(e) {
                    var me = this;
                    var options = me.options || {};
                    var hoverOptions = options.hover;
                    var changed = false;

                    me.lastActive = me.lastActive || [];

                    // Find Active Elements for hover and tooltips
                    if (e.type === 'mouseout') {
                        me.active = [];
                    } else {
                        me.active = me.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions);
                    }

                    // Invoke onHover hook
                    // Need to call with native event here to not break backwards compatibility
                    helpers$1.callback(options.onHover || options.hover.onHover, [e.native, me.active], me);

                    if (e.type === 'mouseup' || e.type === 'click') {
                        if (options.onClick) {
                            // Use e.native here for backwards compatibility
                            options.onClick.call(me, e.native, me.active);
                        }
                    }

                    // Remove styling for last active (even if it may still be active)
                    if (me.lastActive.length) {
                        me.updateHoverStyle(me.lastActive, hoverOptions.mode, false);
                    }

                    // Built in hover styling
                    if (me.active.length && hoverOptions.mode) {
                        me.updateHoverStyle(me.active, hoverOptions.mode, true);
                    }

                    changed = !helpers$1.arrayEquals(me.active, me.lastActive);

                    // Remember Last Actives
                    me.lastActive = me.active;

                    return changed;
                }
            });

            /**
             * NOTE(SB) We actually don't use this container anymore but we need to keep it
             * for backward compatibility. Though, it can still be useful for plugins that
             * would need to work on multiple charts?!
             */
            Chart.instances = {};

            var core_controller = Chart;

            // DEPRECATIONS

            /**
             * Provided for backward compatibility, use Chart instead.
             * @class Chart.Controller
             * @deprecated since version 2.6
             * @todo remove at version 3
             * @private
             */
            Chart.Controller = Chart;

            /**
             * Provided for backward compatibility, not available anymore.
             * @namespace Chart
             * @deprecated since version 2.8
             * @todo remove at version 3
             * @private
             */
            Chart.types = {};

            /**
             * Provided for backward compatibility, not available anymore.
             * @namespace Chart.helpers.configMerge
             * @deprecated since version 2.8.0
             * @todo remove at version 3
             * @private
             */
            helpers$1.configMerge = mergeConfig;

            /**
             * Provided for backward compatibility, not available anymore.
             * @namespace Chart.helpers.scaleMerge
             * @deprecated since version 2.8.0
             * @todo remove at version 3
             * @private
             */
            helpers$1.scaleMerge = mergeScaleConfig;

            var core_helpers = function() {

                // -- Basic js utility methods

                helpers$1.where = function(collection, filterCallback) {
                    if (helpers$1.isArray(collection) && Array.prototype.filter) {
                        return collection.filter(filterCallback);
                    }
                    var filtered = [];

                    helpers$1.each(collection, function(item) {
                        if (filterCallback(item)) {
                            filtered.push(item);
                        }
                    });

                    return filtered;
                };
                helpers$1.findIndex = Array.prototype.findIndex ?
                    function(array, callback, scope) {
                        return array.findIndex(callback, scope);
                    } :
                    function(array, callback, scope) {
                        scope = scope === undefined ? array : scope;
                        for (var i = 0, ilen = array.length; i < ilen; ++i) {
                            if (callback.call(scope, array[i], i, array)) {
                                return i;
                            }
                        }
                        return -1;
                    };
                helpers$1.findNextWhere = function(arrayToSearch, filterCallback, startIndex) {
                    // Default to start of the array
                    if (helpers$1.isNullOrUndef(startIndex)) {
                        startIndex = -1;
                    }
                    for (var i = startIndex + 1; i < arrayToSearch.length; i++) {
                        var currentItem = arrayToSearch[i];
                        if (filterCallback(currentItem)) {
                            return currentItem;
                        }
                    }
                };
                helpers$1.findPreviousWhere = function(arrayToSearch, filterCallback, startIndex) {
                    // Default to end of the array
                    if (helpers$1.isNullOrUndef(startIndex)) {
                        startIndex = arrayToSearch.length;
                    }
                    for (var i = startIndex - 1; i >= 0; i--) {
                        var currentItem = arrayToSearch[i];
                        if (filterCallback(currentItem)) {
                            return currentItem;
                        }
                    }
                };

                // -- Math methods
                helpers$1.isNumber = function(n) {
                    return !isNaN(parseFloat(n)) && isFinite(n);
                };
                helpers$1.almostEquals = function(x, y, epsilon) {
                    return Math.abs(x - y) < epsilon;
                };
                helpers$1.almostWhole = function(x, epsilon) {
                    var rounded = Math.round(x);
                    return ((rounded - epsilon) <= x) && ((rounded + epsilon) >= x);
                };
                helpers$1.max = function(array) {
                    return array.reduce(function(max, value) {
                        if (!isNaN(value)) {
                            return Math.max(max, value);
                        }
                        return max;
                    }, Number.NEGATIVE_INFINITY);
                };
                helpers$1.min = function(array) {
                    return array.reduce(function(min, value) {
                        if (!isNaN(value)) {
                            return Math.min(min, value);
                        }
                        return min;
                    }, Number.POSITIVE_INFINITY);
                };
                helpers$1.sign = Math.sign ?
                    function(x) {
                        return Math.sign(x);
                    } :
                    function(x) {
                        x = +x; // convert to a number
                        if (x === 0 || isNaN(x)) {
                            return x;
                        }
                        return x > 0 ? 1 : -1;
                    };
                helpers$1.toRadians = function(degrees) {
                    return degrees * (Math.PI / 180);
                };
                helpers$1.toDegrees = function(radians) {
                    return radians * (180 / Math.PI);
                };

                /**
                 * Returns the number of decimal places
                 * i.e. the number of digits after the decimal point, of the value of this Number.
                 * @param {number} x - A number.
                 * @returns {number} The number of decimal places.
                 * @private
                 */
                helpers$1._decimalPlaces = function(x) {
                    if (!helpers$1.isFinite(x)) {
                        return;
                    }
                    var e = 1;
                    var p = 0;
                    while (Math.round(x * e) / e !== x) {
                        e *= 10;
                        p++;
                    }
                    return p;
                };

                // Gets the angle from vertical upright to the point about a centre.
                helpers$1.getAngleFromPoint = function(centrePoint, anglePoint) {
                    var distanceFromXCenter = anglePoint.x - centrePoint.x;
                    var distanceFromYCenter = anglePoint.y - centrePoint.y;
                    var radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);

                    var angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);

                    if (angle < (-0.5 * Math.PI)) {
                        angle += 2.0 * Math.PI; // make sure the returned angle is in the range of (-PI/2, 3PI/2]
                    }

                    return {
                        angle: angle,
                        distance: radialDistanceFromCenter
                    };
                };
                helpers$1.distanceBetweenPoints = function(pt1, pt2) {
                    return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
                };

                /**
                 * Provided for backward compatibility, not available anymore
                 * @function Chart.helpers.aliasPixel
                 * @deprecated since version 2.8.0
                 * @todo remove at version 3
                 */
                helpers$1.aliasPixel = function(pixelWidth) {
                    return (pixelWidth % 2 === 0) ? 0 : 0.5;
                };

                /**
                 * Returns the aligned pixel value to avoid anti-aliasing blur
                 * @param {Chart} chart - The chart instance.
                 * @param {number} pixel - A pixel value.
                 * @param {number} width - The width of the element.
                 * @returns {number} The aligned pixel value.
                 * @private
                 */
                helpers$1._alignPixel = function(chart, pixel, width) {
                    var devicePixelRatio = chart.currentDevicePixelRatio;
                    var halfWidth = width / 2;
                    return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
                };

                helpers$1.splineCurve = function(firstPoint, middlePoint, afterPoint, t) {
                    // Props to Rob Spencer at scaled innovation for his post on splining between points
                    // http://scaledinnovation.com/analytics/splines/aboutSplines.html

                    // This function must also respect "skipped" points

                    var previous = firstPoint.skip ? middlePoint : firstPoint;
                    var current = middlePoint;
                    var next = afterPoint.skip ? middlePoint : afterPoint;

                    var d01 = Math.sqrt(Math.pow(current.x - previous.x, 2) + Math.pow(current.y - previous.y, 2));
                    var d12 = Math.sqrt(Math.pow(next.x - current.x, 2) + Math.pow(next.y - current.y, 2));

                    var s01 = d01 / (d01 + d12);
                    var s12 = d12 / (d01 + d12);

                    // If all points are the same, s01 & s02 will be inf
                    s01 = isNaN(s01) ? 0 : s01;
                    s12 = isNaN(s12) ? 0 : s12;

                    var fa = t * s01; // scaling factor for triangle Ta
                    var fb = t * s12;

                    return {
                        previous: {
                            x: current.x - fa * (next.x - previous.x),
                            y: current.y - fa * (next.y - previous.y)
                        },
                        next: {
                            x: current.x + fb * (next.x - previous.x),
                            y: current.y + fb * (next.y - previous.y)
                        }
                    };
                };
                helpers$1.EPSILON = Number.EPSILON || 1e-14;
                helpers$1.splineCurveMonotone = function(points) {
                    // This function calculates B√©zier control points in a similar way than |splineCurve|,
                    // but preserves monotonicity of the provided data and ensures no local extremums are added
                    // between the dataset discrete points due to the interpolation.
                    // See : https://en.wikipedia.org/wiki/Monotone_cubic_interpolation

                    var pointsWithTangents = (points || []).map(function(point) {
                        return {
                            model: point._model,
                            deltaK: 0,
                            mK: 0
                        };
                    });

                    // Calculate slopes (deltaK) and initialize tangents (mK)
                    var pointsLen = pointsWithTangents.length;
                    var i, pointBefore, pointCurrent, pointAfter;
                    for (i = 0; i < pointsLen; ++i) {
                        pointCurrent = pointsWithTangents[i];
                        if (pointCurrent.model.skip) {
                            continue;
                        }

                        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
                        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
                        if (pointAfter && !pointAfter.model.skip) {
                            var slopeDeltaX = (pointAfter.model.x - pointCurrent.model.x);

                            // In the case of two points that appear at the same x pixel, slopeDeltaX is 0
                            pointCurrent.deltaK = slopeDeltaX !== 0 ? (pointAfter.model.y - pointCurrent.model.y) / slopeDeltaX : 0;
                        }

                        if (!pointBefore || pointBefore.model.skip) {
                            pointCurrent.mK = pointCurrent.deltaK;
                        } else if (!pointAfter || pointAfter.model.skip) {
                            pointCurrent.mK = pointBefore.deltaK;
                        } else if (this.sign(pointBefore.deltaK) !== this.sign(pointCurrent.deltaK)) {
                            pointCurrent.mK = 0;
                        } else {
                            pointCurrent.mK = (pointBefore.deltaK + pointCurrent.deltaK) / 2;
                        }
                    }

                    // Adjust tangents to ensure monotonic properties
                    var alphaK, betaK, tauK, squaredMagnitude;
                    for (i = 0; i < pointsLen - 1; ++i) {
                        pointCurrent = pointsWithTangents[i];
                        pointAfter = pointsWithTangents[i + 1];
                        if (pointCurrent.model.skip || pointAfter.model.skip) {
                            continue;
                        }

                        if (helpers$1.almostEquals(pointCurrent.deltaK, 0, this.EPSILON)) {
                            pointCurrent.mK = pointAfter.mK = 0;
                            continue;
                        }

                        alphaK = pointCurrent.mK / pointCurrent.deltaK;
                        betaK = pointAfter.mK / pointCurrent.deltaK;
                        squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
                        if (squaredMagnitude <= 9) {
                            continue;
                        }

                        tauK = 3 / Math.sqrt(squaredMagnitude);
                        pointCurrent.mK = alphaK * tauK * pointCurrent.deltaK;
                        pointAfter.mK = betaK * tauK * pointCurrent.deltaK;
                    }

                    // Compute control points
                    var deltaX;
                    for (i = 0; i < pointsLen; ++i) {
                        pointCurrent = pointsWithTangents[i];
                        if (pointCurrent.model.skip) {
                            continue;
                        }

                        pointBefore = i > 0 ? pointsWithTangents[i - 1] : null;
                        pointAfter = i < pointsLen - 1 ? pointsWithTangents[i + 1] : null;
                        if (pointBefore && !pointBefore.model.skip) {
                            deltaX = (pointCurrent.model.x - pointBefore.model.x) / 3;
                            pointCurrent.model.controlPointPreviousX = pointCurrent.model.x - deltaX;
                            pointCurrent.model.controlPointPreviousY = pointCurrent.model.y - deltaX * pointCurrent.mK;
                        }
                        if (pointAfter && !pointAfter.model.skip) {
                            deltaX = (pointAfter.model.x - pointCurrent.model.x) / 3;
                            pointCurrent.model.controlPointNextX = pointCurrent.model.x + deltaX;
                            pointCurrent.model.controlPointNextY = pointCurrent.model.y + deltaX * pointCurrent.mK;
                        }
                    }
                };
                helpers$1.nextItem = function(collection, index, loop) {
                    if (loop) {
                        return index >= collection.length - 1 ? collection[0] : collection[index + 1];
                    }
                    return index >= collection.length - 1 ? collection[collection.length - 1] : collection[index + 1];
                };
                helpers$1.previousItem = function(collection, index, loop) {
                    if (loop) {
                        return index <= 0 ? collection[collection.length - 1] : collection[index - 1];
                    }
                    return index <= 0 ? collection[0] : collection[index - 1];
                };
                // Implementation of the nice number algorithm used in determining where axis labels will go
                helpers$1.niceNum = function(range, round) {
                    var exponent = Math.floor(helpers$1.log10(range));
                    var fraction = range / Math.pow(10, exponent);
                    var niceFraction;

                    if (round) {
                        if (fraction < 1.5) {
                            niceFraction = 1;
                        } else if (fraction < 3) {
                            niceFraction = 2;
                        } else if (fraction < 7) {
                            niceFraction = 5;
                        } else {
                            niceFraction = 10;
                        }
                    } else if (fraction <= 1.0) {
                        niceFraction = 1;
                    } else if (fraction <= 2) {
                        niceFraction = 2;
                    } else if (fraction <= 5) {
                        niceFraction = 5;
                    } else {
                        niceFraction = 10;
                    }

                    return niceFraction * Math.pow(10, exponent);
                };
                // Request animation polyfill - https://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
                helpers$1.requestAnimFrame = (function() {
                    if (typeof window === 'undefined') {
                        return function(callback) {
                            callback();
                        };
                    }
                    return window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function(callback) {
                            return window.setTimeout(callback, 1000 / 60);
                        };
                }());
                // -- DOM methods
                helpers$1.getRelativePosition = function(evt, chart) {
                    var mouseX, mouseY;
                    var e = evt.originalEvent || evt;
                    var canvas = evt.target || evt.srcElement;
                    var boundingRect = canvas.getBoundingClientRect();

                    var touches = e.touches;
                    if (touches && touches.length > 0) {
                        mouseX = touches[0].clientX;
                        mouseY = touches[0].clientY;

                    } else {
                        mouseX = e.clientX;
                        mouseY = e.clientY;
                    }

                    // Scale mouse coordinates into canvas coordinates
                    // by following the pattern laid out by 'jerryj' in the comments of
                    // https://www.html5canvastutorials.com/advanced/html5-canvas-mouse-coordinates/
                    var paddingLeft = parseFloat(helpers$1.getStyle(canvas, 'padding-left'));
                    var paddingTop = parseFloat(helpers$1.getStyle(canvas, 'padding-top'));
                    var paddingRight = parseFloat(helpers$1.getStyle(canvas, 'padding-right'));
                    var paddingBottom = parseFloat(helpers$1.getStyle(canvas, 'padding-bottom'));
                    var width = boundingRect.right - boundingRect.left - paddingLeft - paddingRight;
                    var height = boundingRect.bottom - boundingRect.top - paddingTop - paddingBottom;

                    // We divide by the current device pixel ratio, because the canvas is scaled up by that amount in each direction. However
                    // the backend model is in unscaled coordinates. Since we are going to deal with our model coordinates, we go back here
                    mouseX = Math.round((mouseX - boundingRect.left - paddingLeft) / (width) * canvas.width / chart.currentDevicePixelRatio);
                    mouseY = Math.round((mouseY - boundingRect.top - paddingTop) / (height) * canvas.height / chart.currentDevicePixelRatio);

                    return {
                        x: mouseX,
                        y: mouseY
                    };

                };

                // Private helper function to convert max-width/max-height values that may be percentages into a number
                function parseMaxStyle(styleValue, node, parentProperty) {
                    var valueInPixels;
                    if (typeof styleValue === 'string') {
                        valueInPixels = parseInt(styleValue, 10);

                        if (styleValue.indexOf('%') !== -1) {
                            // percentage * size in dimension
                            valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
                        }
                    } else {
                        valueInPixels = styleValue;
                    }

                    return valueInPixels;
                }

                /**
                 * Returns if the given value contains an effective constraint.
                 * @private
                 */
                function isConstrainedValue(value) {
                    return value !== undefined && value !== null && value !== 'none';
                }

                /**
                 * Returns the max width or height of the given DOM node in a cross-browser compatible fashion
                 * @param {HTMLElement} domNode - the node to check the constraint on
                 * @param {string} maxStyle - the style that defines the maximum for the direction we are using ('max-width' / 'max-height')
                 * @param {string} percentageProperty - property of parent to use when calculating width as a percentage
                 * @see {@link https://www.nathanaeljones.com/blog/2013/reading-max-width-cross-browser}
                 */
                function getConstraintDimension(domNode, maxStyle, percentageProperty) {
                    var view = document.defaultView;
                    var parentNode = helpers$1._getParentNode(domNode);
                    var constrainedNode = view.getComputedStyle(domNode)[maxStyle];
                    var constrainedContainer = view.getComputedStyle(parentNode)[maxStyle];
                    var hasCNode = isConstrainedValue(constrainedNode);
                    var hasCContainer = isConstrainedValue(constrainedContainer);
                    var infinity = Number.POSITIVE_INFINITY;

                    if (hasCNode || hasCContainer) {
                        return Math.min(
                            hasCNode ? parseMaxStyle(constrainedNode, domNode, percentageProperty) : infinity,
                            hasCContainer ? parseMaxStyle(constrainedContainer, parentNode, percentageProperty) : infinity);
                    }

                    return 'none';
                }
                // returns Number or undefined if no constraint
                helpers$1.getConstraintWidth = function(domNode) {
                    return getConstraintDimension(domNode, 'max-width', 'clientWidth');
                };
                // returns Number or undefined if no constraint
                helpers$1.getConstraintHeight = function(domNode) {
                    return getConstraintDimension(domNode, 'max-height', 'clientHeight');
                };
                /**
                 * @private
                 */
                helpers$1._calculatePadding = function(container, padding, parentDimension) {
                    padding = helpers$1.getStyle(container, padding);

                    return padding.indexOf('%') > -1 ? parentDimension * parseInt(padding, 10) / 100 : parseInt(padding, 10);
                };
                /**
                 * @private
                 */
                helpers$1._getParentNode = function(domNode) {
                    var parent = domNode.parentNode;
                    if (parent && parent.toString() === '[object ShadowRoot]') {
                        parent = parent.host;
                    }
                    return parent;
                };
                helpers$1.getMaximumWidth = function(domNode) {
                    var container = helpers$1._getParentNode(domNode);
                    if (!container) {
                        return domNode.clientWidth;
                    }

                    var clientWidth = container.clientWidth;
                    var paddingLeft = helpers$1._calculatePadding(container, 'padding-left', clientWidth);
                    var paddingRight = helpers$1._calculatePadding(container, 'padding-right', clientWidth);

                    var w = clientWidth - paddingLeft - paddingRight;
                    var cw = helpers$1.getConstraintWidth(domNode);
                    return isNaN(cw) ? w : Math.min(w, cw);
                };
                helpers$1.getMaximumHeight = function(domNode) {
                    var container = helpers$1._getParentNode(domNode);
                    if (!container) {
                        return domNode.clientHeight;
                    }

                    var clientHeight = container.clientHeight;
                    var paddingTop = helpers$1._calculatePadding(container, 'padding-top', clientHeight);
                    var paddingBottom = helpers$1._calculatePadding(container, 'padding-bottom', clientHeight);

                    var h = clientHeight - paddingTop - paddingBottom;
                    var ch = helpers$1.getConstraintHeight(domNode);
                    return isNaN(ch) ? h : Math.min(h, ch);
                };
                helpers$1.getStyle = function(el, property) {
                    return el.currentStyle ?
                        el.currentStyle[property] :
                        document.defaultView.getComputedStyle(el, null).getPropertyValue(property);
                };
                helpers$1.retinaScale = function(chart, forceRatio) {
                    var pixelRatio = chart.currentDevicePixelRatio = forceRatio || (typeof window !== 'undefined' && window.devicePixelRatio) || 1;
                    if (pixelRatio === 1) {
                        return;
                    }

                    var canvas = chart.canvas;
                    var height = chart.height;
                    var width = chart.width;

                    canvas.height = height * pixelRatio;
                    canvas.width = width * pixelRatio;
                    chart.ctx.scale(pixelRatio, pixelRatio);

                    // If no style has been set on the canvas, the render size is used as display size,
                    // making the chart visually bigger, so let's enforce it to the "correct" values.
                    // See https://github.com/chartjs/Chart.js/issues/3575
                    if (!canvas.style.height && !canvas.style.width) {
                        canvas.style.height = height + 'px';
                        canvas.style.width = width + 'px';
                    }
                };
                // -- Canvas methods
                helpers$1.fontString = function(pixelSize, fontStyle, fontFamily) {
                    return fontStyle + ' ' + pixelSize + 'px ' + fontFamily;
                };
                helpers$1.longestText = function(ctx, font, arrayOfThings, cache) {
                    cache = cache || {};
                    var data = cache.data = cache.data || {};
                    var gc = cache.garbageCollect = cache.garbageCollect || [];

                    if (cache.font !== font) {
                        data = cache.data = {};
                        gc = cache.garbageCollect = [];
                        cache.font = font;
                    }

                    ctx.font = font;
                    var longest = 0;
                    var ilen = arrayOfThings.length;
                    var i, j, jlen, thing, nestedThing;
                    for (i = 0; i < ilen; i++) {
                        thing = arrayOfThings[i];

                        // Undefined strings and arrays should not be measured
                        if (thing !== undefined && thing !== null && helpers$1.isArray(thing) !== true) {
                            longest = helpers$1.measureText(ctx, data, gc, longest, thing);
                        } else if (helpers$1.isArray(thing)) {
                            // if it is an array lets measure each element
                            // to do maybe simplify this function a bit so we can do this more recursively?
                            for (j = 0, jlen = thing.length; j < jlen; j++) {
                                nestedThing = thing[j];
                                // Undefined strings and arrays should not be measured
                                if (nestedThing !== undefined && nestedThing !== null && !helpers$1.isArray(nestedThing)) {
                                    longest = helpers$1.measureText(ctx, data, gc, longest, nestedThing);
                                }
                            }
                        }
                    }

                    var gcLen = gc.length / 2;
                    if (gcLen > arrayOfThings.length) {
                        for (i = 0; i < gcLen; i++) {
                            delete data[gc[i]];
                        }
                        gc.splice(0, gcLen);
                    }
                    return longest;
                };
                helpers$1.measureText = function(ctx, data, gc, longest, string) {
                    var textWidth = data[string];
                    if (!textWidth) {
                        textWidth = data[string] = ctx.measureText(string).width;
                        gc.push(string);
                    }
                    if (textWidth > longest) {
                        longest = textWidth;
                    }
                    return longest;
                };

                /**
                 * @deprecated
                 */
                helpers$1.numberOfLabelLines = function(arrayOfThings) {
                    var numberOfLines = 1;
                    helpers$1.each(arrayOfThings, function(thing) {
                        if (helpers$1.isArray(thing)) {
                            if (thing.length > numberOfLines) {
                                numberOfLines = thing.length;
                            }
                        }
                    });
                    return numberOfLines;
                };

                helpers$1.color = !chartjsColor ?
                    function(value) {
                        console.error('Color.js not found!');
                        return value;
                    } :
                    function(value) {
                        /* global CanvasGradient */
                        if (value instanceof CanvasGradient) {
                            value = core_defaults.global.defaultColor;
                        }

                        return chartjsColor(value);
                    };

                helpers$1.getHoverColor = function(colorValue) {
                    /* global CanvasPattern */
                    return (colorValue instanceof CanvasPattern || colorValue instanceof CanvasGradient) ?
                        colorValue :
                        helpers$1.color(colorValue).saturate(0.5).darken(0.1).rgbString();
                };
            };

            function abstract() {
                throw new Error(
                    'This method is not implemented: either no adapter can ' +
                    'be found or an incomplete integration was provided.'
                );
            }

            /**
             * Date adapter (current used by the time scale)
             * @namespace Chart._adapters._date
             * @memberof Chart._adapters
             * @private
             */

            /**
             * Currently supported unit string values.
             * @typedef {('millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year')}
             * @memberof Chart._adapters._date
             * @name Unit
             */

            /**
             * @class
             */
            function DateAdapter(options) {
                this.options = options || {};
            }

            helpers$1.extend(DateAdapter.prototype, /** @lends DateAdapter */ {
                /**
                 * Returns a map of time formats for the supported formatting units defined
                 * in Unit as well as 'datetime' representing a detailed date/time string.
                 * @returns {{string: string}}
                 */
                formats: abstract,

                /**
                 * Parses the given `value` and return the associated timestamp.
                 * @param {any} value - the value to parse (usually comes from the data)
                 * @param {string} [format] - the expected data format
                 * @returns {(number|null)}
                 * @function
                 */
                parse: abstract,

                /**
                 * Returns the formatted date in the specified `format` for a given `timestamp`.
                 * @param {number} timestamp - the timestamp to format
                 * @param {string} format - the date/time token
                 * @return {string}
                 * @function
                 */
                format: abstract,

                /**
                 * Adds the specified `amount` of `unit` to the given `timestamp`.
                 * @param {number} timestamp - the input timestamp
                 * @param {number} amount - the amount to add
                 * @param {Unit} unit - the unit as string
                 * @return {number}
                 * @function
                 */
                add: abstract,

                /**
                 * Returns the number of `unit` between the given timestamps.
                 * @param {number} max - the input timestamp (reference)
                 * @param {number} min - the timestamp to substract
                 * @param {Unit} unit - the unit as string
                 * @return {number}
                 * @function
                 */
                diff: abstract,

                /**
                 * Returns start of `unit` for the given `timestamp`.
                 * @param {number} timestamp - the input timestamp
                 * @param {Unit} unit - the unit as string
                 * @param {number} [weekday] - the ISO day of the week with 1 being Monday
                 * and 7 being Sunday (only needed if param *unit* is `isoWeek`).
                 * @function
                 */
                startOf: abstract,

                /**
                 * Returns end of `unit` for the given `timestamp`.
                 * @param {number} timestamp - the input timestamp
                 * @param {Unit} unit - the unit as string
                 * @function
                 */
                endOf: abstract,

                // DEPRECATIONS

                /**
                 * Provided for backward compatibility for scale.getValueForPixel(),
                 * this method should be overridden only by the moment adapter.
                 * @deprecated since version 2.8.0
                 * @todo remove at version 3
                 * @private
                 */
                _create: function(value) {
                    return value;
                }
            });

            DateAdapter.override = function(members) {
                helpers$1.extend(DateAdapter.prototype, members);
            };

            var _date = DateAdapter;

            var core_adapters = {
                _date: _date
            };

            /**
             * Namespace to hold static tick generation functions
             * @namespace Chart.Ticks
             */
            var core_ticks = {
                /**
                 * Namespace to hold formatters for different types of ticks
                 * @namespace Chart.Ticks.formatters
                 */
                formatters: {
                    /**
                     * Formatter for value labels
                     * @method Chart.Ticks.formatters.values
                     * @param value the value to display
                     * @return {string|string[]} the label to display
                     */
                    values: function(value) {
                        return helpers$1.isArray(value) ? value : '' + value;
                    },

                    /**
                     * Formatter for linear numeric ticks
                     * @method Chart.Ticks.formatters.linear
                     * @param tickValue {number} the value to be formatted
                     * @param index {number} the position of the tickValue parameter in the ticks array
                     * @param ticks {number[]} the list of ticks being converted
                     * @return {string} string representation of the tickValue parameter
                     */
                    linear: function(tickValue, index, ticks) {
                        // If we have lots of ticks, don't use the ones
                        var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];

                        // If we have a number like 2.5 as the delta, figure out how many decimal places we need
                        if (Math.abs(delta) > 1) {
                            if (tickValue !== Math.floor(tickValue)) {
                                // not an integer
                                delta = tickValue - Math.floor(tickValue);
                            }
                        }

                        var logDelta = helpers$1.log10(Math.abs(delta));
                        var tickString = '';

                        if (tickValue !== 0) {
                            var maxTick = Math.max(Math.abs(ticks[0]), Math.abs(ticks[ticks.length - 1]));
                            if (maxTick < 1e-4) { // all ticks are small numbers; use scientific notation
                                var logTick = helpers$1.log10(Math.abs(tickValue));
                                var numExponential = Math.floor(logTick) - Math.floor(logDelta);
                                numExponential = Math.max(Math.min(numExponential, 20), 0);
                                tickString = tickValue.toExponential(numExponential);
                            } else {
                                var numDecimal = -1 * Math.floor(logDelta);
                                numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places
                                tickString = tickValue.toFixed(numDecimal);
                            }
                        } else {
                            tickString = '0'; // never show decimal places for 0
                        }

                        return tickString;
                    },

                    logarithmic: function(tickValue, index, ticks) {
                        var remain = tickValue / (Math.pow(10, Math.floor(helpers$1.log10(tickValue))));

                        if (tickValue === 0) {
                            return '0';
                        } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {
                            return tickValue.toExponential();
                        }
                        return '';
                    }
                }
            };

            var isArray = helpers$1.isArray;
            var isNullOrUndef = helpers$1.isNullOrUndef;
            var valueOrDefault$a = helpers$1.valueOrDefault;
            var valueAtIndexOrDefault = helpers$1.valueAtIndexOrDefault;

            core_defaults._set('scale', {
                display: true,
                position: 'left',
                offset: false,

                // grid line settings
                gridLines: {
                    display: true,
                    color: 'rgba(0,0,0,0.1)',
                    lineWidth: 1,
                    drawBorder: true,
                    drawOnChartArea: true,
                    drawTicks: true,
                    tickMarkLength: 10,
                    zeroLineWidth: 1,
                    zeroLineColor: 'rgba(0,0,0,0.25)',
                    zeroLineBorderDash: [],
                    zeroLineBorderDashOffset: 0.0,
                    offsetGridLines: false,
                    borderDash: [],
                    borderDashOffset: 0.0
                },

                // scale label
                scaleLabel: {
                    // display property
                    display: false,

                    // actual label
                    labelString: '',

                    // top/bottom padding
                    padding: {
                        top: 4,
                        bottom: 4
                    }
                },

                // label settings
                ticks: {
                    beginAtZero: false,
                    minRotation: 0,
                    maxRotation: 50,
                    mirror: false,
                    padding: 0,
                    reverse: false,
                    display: true,
                    autoSkip: true,
                    autoSkipPadding: 0,
                    labelOffset: 0,
                    // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.
                    callback: core_ticks.formatters.values,
                    minor: {},
                    major: {}
                }
            });

            /** Returns a new array containing numItems from arr */
            function sample(arr, numItems) {
                var result = [];
                var increment = arr.length / numItems;
                var i = 0;
                var len = arr.length;

                for (; i < len; i += increment) {
                    result.push(arr[Math.floor(i)]);
                }
                return result;
            }

            function getPixelForGridLine(scale, index, offsetGridLines) {
                var length = scale.getTicks().length;
                var validIndex = Math.min(index, length - 1);
                var lineValue = scale.getPixelForTick(validIndex);
                var start = scale._startPixel;
                var end = scale._endPixel;
                var epsilon = 1e-6; // 1e-6 is margin in pixels for accumulated error.
                var offset;

                if (offsetGridLines) {
                    if (length === 1) {
                        offset = Math.max(lineValue - start, end - lineValue);
                    } else if (index === 0) {
                        offset = (scale.getPixelForTick(1) - lineValue) / 2;
                    } else {
                        offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
                    }
                    lineValue += validIndex < index ? offset : -offset;

                    // Return undefined if the pixel is out of the range
                    if (lineValue < start - epsilon || lineValue > end + epsilon) {
                        return;
                    }
                }
                return lineValue;
            }

            function garbageCollect(caches, length) {
                helpers$1.each(caches, function(cache) {
                    var gc = cache.gc;
                    var gcLen = gc.length / 2;
                    var i;
                    if (gcLen > length) {
                        for (i = 0; i < gcLen; ++i) {
                            delete cache.data[gc[i]];
                        }
                        gc.splice(0, gcLen);
                    }
                });
            }

            /**
             * Returns {width, height, offset} objects for the first, last, widest, highest tick
             * labels where offset indicates the anchor point offset from the top in pixels.
             */
            function computeLabelSizes(ctx, tickFonts, ticks, caches) {
                var length = ticks.length;
                var widths = [];
                var heights = [];
                var offsets = [];
                var i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel, widest, highest;

                for (i = 0; i < length; ++i) {
                    label = ticks[i].label;
                    tickFont = ticks[i].major ? tickFonts.major : tickFonts.minor;
                    ctx.font = fontString = tickFont.string;
                    cache = caches[fontString] = caches[fontString] || {data: {}, gc: []};
                    lineHeight = tickFont.lineHeight;
                    width = height = 0;
                    // Undefined labels and arrays should not be measured
                    if (!isNullOrUndef(label) && !isArray(label)) {
                        width = helpers$1.measureText(ctx, cache.data, cache.gc, width, label);
                        height = lineHeight;
                    } else if (isArray(label)) {
                        // if it is an array let's measure each element
                        for (j = 0, jlen = label.length; j < jlen; ++j) {
                            nestedLabel = label[j];
                            // Undefined labels and arrays should not be measured
                            if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                                width = helpers$1.measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                                height += lineHeight;
                            }
                        }
                    }
                    widths.push(width);
                    heights.push(height);
                    offsets.push(lineHeight / 2);
                }
                garbageCollect(caches, length);

                widest = widths.indexOf(Math.max.apply(null, widths));
                highest = heights.indexOf(Math.max.apply(null, heights));

                function valueAt(idx) {
                    return {
                        width: widths[idx] || 0,
                        height: heights[idx] || 0,
                        offset: offsets[idx] || 0
                    };
                }

                return {
                    first: valueAt(0),
                    last: valueAt(length - 1),
                    widest: valueAt(widest),
                    highest: valueAt(highest)
                };
            }

            function getTickMarkLength(options) {
                return options.drawTicks ? options.tickMarkLength : 0;
            }

            function getScaleLabelHeight(options) {
                var font, padding;

                if (!options.display) {
                    return 0;
                }

                font = helpers$1.options._parseFont(options);
                padding = helpers$1.options.toPadding(options.padding);

                return font.lineHeight + padding.height;
            }

            function parseFontOptions(options, nestedOpts) {
                return helpers$1.extend(helpers$1.options._parseFont({
                    fontFamily: valueOrDefault$a(nestedOpts.fontFamily, options.fontFamily),
                    fontSize: valueOrDefault$a(nestedOpts.fontSize, options.fontSize),
                    fontStyle: valueOrDefault$a(nestedOpts.fontStyle, options.fontStyle),
                    lineHeight: valueOrDefault$a(nestedOpts.lineHeight, options.lineHeight)
                }), {
                    color: helpers$1.options.resolve([nestedOpts.fontColor, options.fontColor, core_defaults.global.defaultFontColor])
                });
            }

            function parseTickFontOptions(options) {
                var minor = parseFontOptions(options, options.minor);
                var major = options.major.enabled ? parseFontOptions(options, options.major) : minor;

                return {minor: minor, major: major};
            }

            function nonSkipped(ticksToFilter) {
                var filtered = [];
                var item, index, len;
                for (index = 0, len = ticksToFilter.length; index < len; ++index) {
                    item = ticksToFilter[index];
                    if (typeof item._index !== 'undefined') {
                        filtered.push(item);
                    }
                }
                return filtered;
            }

            function getEvenSpacing(arr) {
                var len = arr.length;
                var i, diff;

                if (len < 2) {
                    return false;
                }

                for (diff = arr[0], i = 1; i < len; ++i) {
                    if (arr[i] - arr[i - 1] !== diff) {
                        return false;
                    }
                }
                return diff;
            }

            function calculateSpacing(majorIndices, ticks, axisLength, ticksLimit) {
                var evenMajorSpacing = getEvenSpacing(majorIndices);
                var spacing = (ticks.length - 1) / ticksLimit;
                var factors, factor, i, ilen;

                // If the major ticks are evenly spaced apart, place the minor ticks
                // so that they divide the major ticks into even chunks
                if (!evenMajorSpacing) {
                    return Math.max(spacing, 1);
                }

                factors = helpers$1.math._factorize(evenMajorSpacing);
                for (i = 0, ilen = factors.length - 1; i < ilen; i++) {
                    factor = factors[i];
                    if (factor > spacing) {
                        return factor;
                    }
                }
                return Math.max(spacing, 1);
            }

            function getMajorIndices(ticks) {
                var result = [];
                var i, ilen;
                for (i = 0, ilen = ticks.length; i < ilen; i++) {
                    if (ticks[i].major) {
                        result.push(i);
                    }
                }
                return result;
            }

            function skipMajors(ticks, majorIndices, spacing) {
                var count = 0;
                var next = majorIndices[0];
                var i, tick;

                spacing = Math.ceil(spacing);
                for (i = 0; i < ticks.length; i++) {
                    tick = ticks[i];
                    if (i === next) {
                        tick._index = i;
                        count++;
                        next = majorIndices[count * spacing];
                    } else {
                        delete tick.label;
                    }
                }
            }

            function skip(ticks, spacing, majorStart, majorEnd) {
                var start = valueOrDefault$a(majorStart, 0);
                var end = Math.min(valueOrDefault$a(majorEnd, ticks.length), ticks.length);
                var count = 0;
                var length, i, tick, next;

                spacing = Math.ceil(spacing);
                if (majorEnd) {
                    length = majorEnd - majorStart;
                    spacing = length / Math.floor(length / spacing);
                }

                next = start;

                while (next < 0) {
                    count++;
                    next = Math.round(start + count * spacing);
                }

                for (i = Math.max(start, 0); i < end; i++) {
                    tick = ticks[i];
                    if (i === next) {
                        tick._index = i;
                        count++;
                        next = Math.round(start + count * spacing);
                    } else {
                        delete tick.label;
                    }
                }
            }

            var Scale = core_element.extend({

                zeroLineIndex: 0,

                /**
                 * Get the padding needed for the scale
                 * @method getPadding
                 * @private
                 * @returns {Padding} the necessary padding
                 */
                getPadding: function() {
                    var me = this;
                    return {
                        left: me.paddingLeft || 0,
                        top: me.paddingTop || 0,
                        right: me.paddingRight || 0,
                        bottom: me.paddingBottom || 0
                    };
                },

                /**
                 * Returns the scale tick objects ({label, major})
                 * @since 2.7
                 */
                getTicks: function() {
                    return this._ticks;
                },

                /**
                 * @private
                 */
                _getLabels: function() {
                    var data = this.chart.data;
                    return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels;
                },

                // These methods are ordered by lifecyle. Utilities then follow.
                // Any function defined here is inherited by all scale types.
                // Any function can be extended by the scale type

                /**
                 * Provided for backward compatibility, not available anymore
                 * @function Chart.Scale.mergeTicksOptions
                 * @deprecated since version 2.8.0
                 * @todo remove at version 3
                 */
                mergeTicksOptions: function() {
                    // noop
                },

                beforeUpdate: function() {
                    helpers$1.callback(this.options.beforeUpdate, [this]);
                },

                /**
                 * @param {number} maxWidth - the max width in pixels
                 * @param {number} maxHeight - the max height in pixels
                 * @param {object} margins - the space between the edge of the other scales and edge of the chart
                 *   This space comes from two sources:
                 *     - padding - space that's required to show the labels at the edges of the scale
                 *     - thickness of scales or legends in another orientation
                 */
                update: function(maxWidth, maxHeight, margins) {
                    var me = this;
                    var tickOpts = me.options.ticks;
                    var sampleSize = tickOpts.sampleSize;
                    var i, ilen, labels, ticks, samplingEnabled;

                    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
                    me.beforeUpdate();

                    // Absorb the master measurements
                    me.maxWidth = maxWidth;
                    me.maxHeight = maxHeight;
                    me.margins = helpers$1.extend({
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    }, margins);

                    me._ticks = null;
                    me.ticks = null;
                    me._labelSizes = null;
                    me._maxLabelLines = 0;
                    me.longestLabelWidth = 0;
                    me.longestTextCache = me.longestTextCache || {};
                    me._gridLineItems = null;
                    me._labelItems = null;

                    // Dimensions
                    me.beforeSetDimensions();
                    me.setDimensions();
                    me.afterSetDimensions();

                    // Data min/max
                    me.beforeDataLimits();
                    me.determineDataLimits();
                    me.afterDataLimits();

                    // Ticks - `this.ticks` is now DEPRECATED!
                    // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member
                    // and must not be accessed directly from outside this class. `this.ticks` being
                    // around for long time and not marked as private, we can't change its structure
                    // without unexpected breaking changes. If you need to access the scale ticks,
                    // use scale.getTicks() instead.

                    me.beforeBuildTicks();

                    // New implementations should return an array of objects but for BACKWARD COMPAT,
                    // we still support no return (`this.ticks` internally set by calling this method).
                    ticks = me.buildTicks() || [];

                    // Allow modification of ticks in callback.
                    ticks = me.afterBuildTicks(ticks) || ticks;

                    // Ensure ticks contains ticks in new tick format
                    if ((!ticks || !ticks.length) && me.ticks) {
                        ticks = [];
                        for (i = 0, ilen = me.ticks.length; i < ilen; ++i) {
                            ticks.push({
                                value: me.ticks[i],
                                major: false
                            });
                        }
                    }

                    me._ticks = ticks;

                    // Compute tick rotation and fit using a sampled subset of labels
                    // We generally don't need to compute the size of every single label for determining scale size
                    samplingEnabled = sampleSize < ticks.length;
                    labels = me._convertTicksToLabels(samplingEnabled ? sample(ticks, sampleSize) : ticks);

                    // _configure is called twice, once here, once from core.controller.updateLayout.
                    // Here we haven't been positioned yet, but dimensions are correct.
                    // Variables set in _configure are needed for calculateTickRotation, and
                    // it's ok that coordinates are not correct there, only dimensions matter.
                    me._configure();

                    // Tick Rotation
                    me.beforeCalculateTickRotation();
                    me.calculateTickRotation();
                    me.afterCalculateTickRotation();

                    me.beforeFit();
                    me.fit();
                    me.afterFit();

                    // Auto-skip
                    me._ticksToDraw = tickOpts.display && (tickOpts.autoSkip || tickOpts.source === 'auto') ? me._autoSkip(ticks) : ticks;

                    if (samplingEnabled) {
                        // Generate labels using all non-skipped ticks
                        labels = me._convertTicksToLabels(me._ticksToDraw);
                    }

                    me.ticks = labels;   // BACKWARD COMPATIBILITY

                    // IMPORTANT: after this point, we consider that `this.ticks` will NEVER change!

                    me.afterUpdate();

                    // TODO(v3): remove minSize as a public property and return value from all layout boxes. It is unused
                    // make maxWidth and maxHeight private
                    return me.minSize;
                },

                /**
                 * @private
                 */
                _configure: function() {
                    var me = this;
                    var reversePixels = me.options.ticks.reverse;
                    var startPixel, endPixel;

                    if (me.isHorizontal()) {
                        startPixel = me.left;
                        endPixel = me.right;
                    } else {
                        startPixel = me.top;
                        endPixel = me.bottom;
                        // by default vertical scales are from bottom to top, so pixels are reversed
                        reversePixels = !reversePixels;
                    }
                    me._startPixel = startPixel;
                    me._endPixel = endPixel;
                    me._reversePixels = reversePixels;
                    me._length = endPixel - startPixel;
                },

                afterUpdate: function() {
                    helpers$1.callback(this.options.afterUpdate, [this]);
                },

                //

                beforeSetDimensions: function() {
                    helpers$1.callback(this.options.beforeSetDimensions, [this]);
                },
                setDimensions: function() {
                    var me = this;
                    // Set the unconstrained dimension before label rotation
                    if (me.isHorizontal()) {
                        // Reset position before calculating rotation
                        me.width = me.maxWidth;
                        me.left = 0;
                        me.right = me.width;
                    } else {
                        me.height = me.maxHeight;

                        // Reset position before calculating rotation
                        me.top = 0;
                        me.bottom = me.height;
                    }

                    // Reset padding
                    me.paddingLeft = 0;
                    me.paddingTop = 0;
                    me.paddingRight = 0;
                    me.paddingBottom = 0;
                },
                afterSetDimensions: function() {
                    helpers$1.callback(this.options.afterSetDimensions, [this]);
                },

                // Data limits
                beforeDataLimits: function() {
                    helpers$1.callback(this.options.beforeDataLimits, [this]);
                },
                determineDataLimits: helpers$1.noop,
                afterDataLimits: function() {
                    helpers$1.callback(this.options.afterDataLimits, [this]);
                },

                //
                beforeBuildTicks: function() {
                    helpers$1.callback(this.options.beforeBuildTicks, [this]);
                },
                buildTicks: helpers$1.noop,
                afterBuildTicks: function(ticks) {
                    var me = this;
                    // ticks is empty for old axis implementations here
                    if (isArray(ticks) && ticks.length) {
                        return helpers$1.callback(me.options.afterBuildTicks, [me, ticks]);
                    }
                    // Support old implementations (that modified `this.ticks` directly in buildTicks)
                    me.ticks = helpers$1.callback(me.options.afterBuildTicks, [me, me.ticks]) || me.ticks;
                    return ticks;
                },

                beforeTickToLabelConversion: function() {
                    helpers$1.callback(this.options.beforeTickToLabelConversion, [this]);
                },
                convertTicksToLabels: function() {
                    var me = this;
                    // Convert ticks to strings
                    var tickOpts = me.options.ticks;
                    me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);
                },
                afterTickToLabelConversion: function() {
                    helpers$1.callback(this.options.afterTickToLabelConversion, [this]);
                },

                //

                beforeCalculateTickRotation: function() {
                    helpers$1.callback(this.options.beforeCalculateTickRotation, [this]);
                },
                calculateTickRotation: function() {
                    var me = this;
                    var options = me.options;
                    var tickOpts = options.ticks;
                    var numTicks = me.getTicks().length;
                    var minRotation = tickOpts.minRotation || 0;
                    var maxRotation = tickOpts.maxRotation;
                    var labelRotation = minRotation;
                    var labelSizes, maxLabelWidth, maxLabelHeight, maxWidth, tickWidth, maxHeight, maxLabelDiagonal;

                    if (!me._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !me.isHorizontal()) {
                        me.labelRotation = minRotation;
                        return;
                    }

                    labelSizes = me._getLabelSizes();
                    maxLabelWidth = labelSizes.widest.width;
                    maxLabelHeight = labelSizes.highest.height - labelSizes.highest.offset;

                    // Estimate the width of each grid based on the canvas width, the maximum
                    // label width and the number of tick intervals
                    maxWidth = Math.min(me.maxWidth, me.chart.width - maxLabelWidth);
                    tickWidth = options.offset ? me.maxWidth / numTicks : maxWidth / (numTicks - 1);

                    // Allow 3 pixels x2 padding either side for label readability
                    if (maxLabelWidth + 6 > tickWidth) {
                        tickWidth = maxWidth / (numTicks - (options.offset ? 0.5 : 1));
                        maxHeight = me.maxHeight - getTickMarkLength(options.gridLines)
                            - tickOpts.padding - getScaleLabelHeight(options.scaleLabel);
                        maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
                        labelRotation = helpers$1.toDegrees(Math.min(
                            Math.asin(Math.min((labelSizes.highest.height + 6) / tickWidth, 1)),
                            Math.asin(Math.min(maxHeight / maxLabelDiagonal, 1)) - Math.asin(maxLabelHeight / maxLabelDiagonal)
                        ));
                        labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
                    }

                    me.labelRotation = labelRotation;
                },
                afterCalculateTickRotation: function() {
                    helpers$1.callback(this.options.afterCalculateTickRotation, [this]);
                },

                //

                beforeFit: function() {
                    helpers$1.callback(this.options.beforeFit, [this]);
                },
                fit: function() {
                    var me = this;
                    // Reset
                    var minSize = me.minSize = {
                        width: 0,
                        height: 0
                    };

                    var chart = me.chart;
                    var opts = me.options;
                    var tickOpts = opts.ticks;
                    var scaleLabelOpts = opts.scaleLabel;
                    var gridLineOpts = opts.gridLines;
                    var display = me._isVisible();
                    var isBottom = opts.position === 'bottom';
                    var isHorizontal = me.isHorizontal();

                    // Width
                    if (isHorizontal) {
                        minSize.width = me.maxWidth;
                    } else if (display) {
                        minSize.width = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
                    }

                    // height
                    if (!isHorizontal) {
                        minSize.height = me.maxHeight; // fill all the height
                    } else if (display) {
                        minSize.height = getTickMarkLength(gridLineOpts) + getScaleLabelHeight(scaleLabelOpts);
                    }

                    // Don't bother fitting the ticks if we are not showing the labels
                    if (tickOpts.display && display) {
                        var tickFonts = parseTickFontOptions(tickOpts);
                        var labelSizes = me._getLabelSizes();
                        var firstLabelSize = labelSizes.first;
                        var lastLabelSize = labelSizes.last;
                        var widestLabelSize = labelSizes.widest;
                        var highestLabelSize = labelSizes.highest;
                        var lineSpace = tickFonts.minor.lineHeight * 0.4;
                        var tickPadding = tickOpts.padding;

                        if (isHorizontal) {
                            // A horizontal axis is more constrained by the height.
                            var isRotated = me.labelRotation !== 0;
                            var angleRadians = helpers$1.toRadians(me.labelRotation);
                            var cosRotation = Math.cos(angleRadians);
                            var sinRotation = Math.sin(angleRadians);

                            var labelHeight = sinRotation * widestLabelSize.width
                                + cosRotation * (highestLabelSize.height - (isRotated ? highestLabelSize.offset : 0))
                                + (isRotated ? 0 : lineSpace); // padding

                            minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);

                            var offsetLeft = me.getPixelForTick(0) - me.left;
                            var offsetRight = me.right - me.getPixelForTick(me.getTicks().length - 1);
                            var paddingLeft, paddingRight;

                            // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned
                            // which means that the right padding is dominated by the font height
                            if (isRotated) {
                                paddingLeft = isBottom ?
                                    cosRotation * firstLabelSize.width + sinRotation * firstLabelSize.offset :
                                    sinRotation * (firstLabelSize.height - firstLabelSize.offset);
                                paddingRight = isBottom ?
                                    sinRotation * (lastLabelSize.height - lastLabelSize.offset) :
                                    cosRotation * lastLabelSize.width + sinRotation * lastLabelSize.offset;
                            } else {
                                paddingLeft = firstLabelSize.width / 2;
                                paddingRight = lastLabelSize.width / 2;
                            }

                            // Adjust padding taking into account changes in offsets
                            // and add 3 px to move away from canvas edges
                            me.paddingLeft = Math.max((paddingLeft - offsetLeft) * me.width / (me.width - offsetLeft), 0) + 3;
                            me.paddingRight = Math.max((paddingRight - offsetRight) * me.width / (me.width - offsetRight), 0) + 3;
                        } else {
                            // A vertical axis is more constrained by the width. Labels are the
                            // dominant factor here, so get that length first and account for padding
                            var labelWidth = tickOpts.mirror ? 0 :
                                // use lineSpace for consistency with horizontal axis
                                // tickPadding is not implemented for horizontal
                                widestLabelSize.width + tickPadding + lineSpace;

                            minSize.width = Math.min(me.maxWidth, minSize.width + labelWidth);

                            me.paddingTop = firstLabelSize.height / 2;
                            me.paddingBottom = lastLabelSize.height / 2;
                        }
                    }

                    me.handleMargins();

                    if (isHorizontal) {
                        me.width = me._length = chart.width - me.margins.left - me.margins.right;
                        me.height = minSize.height;
                    } else {
                        me.width = minSize.width;
                        me.height = me._length = chart.height - me.margins.top - me.margins.bottom;
                    }
                },

                /**
                 * Handle margins and padding interactions
                 * @private
                 */
                handleMargins: function() {
                    var me = this;
                    if (me.margins) {
                        me.margins.left = Math.max(me.paddingLeft, me.margins.left);
                        me.margins.top = Math.max(me.paddingTop, me.margins.top);
                        me.margins.right = Math.max(me.paddingRight, me.margins.right);
                        me.margins.bottom = Math.max(me.paddingBottom, me.margins.bottom);
                    }
                },

                afterFit: function() {
                    helpers$1.callback(this.options.afterFit, [this]);
                },

                // Shared Methods
                isHorizontal: function() {
                    var pos = this.options.position;
                    return pos === 'top' || pos === 'bottom';
                },
                isFullWidth: function() {
                    return this.options.fullWidth;
                },

                // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not
                getRightValue: function(rawValue) {
                    // Null and undefined values first
                    if (isNullOrUndef(rawValue)) {
                        return NaN;
                    }
                    // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values
                    if ((typeof rawValue === 'number' || rawValue instanceof Number) && !isFinite(rawValue)) {
                        return NaN;
                    }

                    // If it is in fact an object, dive in one more level
                    if (rawValue) {
                        if (this.isHorizontal()) {
                            if (rawValue.x !== undefined) {
                                return this.getRightValue(rawValue.x);
                            }
                        } else if (rawValue.y !== undefined) {
                            return this.getRightValue(rawValue.y);
                        }
                    }

                    // Value is good, return it
                    return rawValue;
                },

                _convertTicksToLabels: function(ticks) {
                    var me = this;
                    var labels, i, ilen;

                    me.ticks = ticks.map(function(tick) {
                        return tick.value;
                    });

                    me.beforeTickToLabelConversion();

                    // New implementations should return the formatted tick labels but for BACKWARD
                    // COMPAT, we still support no return (`this.ticks` internally changed by calling
                    // this method and supposed to contain only string values).
                    labels = me.convertTicksToLabels(ticks) || me.ticks;

                    me.afterTickToLabelConversion();

                    // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)
                    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                        ticks[i].label = labels[i];
                    }

                    return labels;
                },

                /**
                 * @private
                 */
                _getLabelSizes: function() {
                    var me = this;
                    var labelSizes = me._labelSizes;

                    if (!labelSizes) {
                        me._labelSizes = labelSizes = computeLabelSizes(me.ctx, parseTickFontOptions(me.options.ticks), me.getTicks(), me.longestTextCache);
                        me.longestLabelWidth = labelSizes.widest.width;
                    }

                    return labelSizes;
                },

                /**
                 * @private
                 */
                _parseValue: function(value) {
                    var start, end, min, max;

                    if (isArray(value)) {
                        start = +this.getRightValue(value[0]);
                        end = +this.getRightValue(value[1]);
                        min = Math.min(start, end);
                        max = Math.max(start, end);
                    } else {
                        value = +this.getRightValue(value);
                        start = undefined;
                        end = value;
                        min = value;
                        max = value;
                    }

                    return {
                        min: min,
                        max: max,
                        start: start,
                        end: end
                    };
                },

                /**
                 * @private
                 */
                _getScaleLabel: function(rawValue) {
                    var v = this._parseValue(rawValue);
                    if (v.start !== undefined) {
                        return '[' + v.start + ', ' + v.end + ']';
                    }

                    return +this.getRightValue(rawValue);
                },

                /**
                 * Used to get the value to display in the tooltip for the data at the given index
                 * @param index
                 * @param datasetIndex
                 */
                getLabelForIndex: helpers$1.noop,

                /**
                 * Returns the location of the given data point. Value can either be an index or a numerical value
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 * @param value
                 * @param index
                 * @param datasetIndex
                 */
                getPixelForValue: helpers$1.noop,

                /**
                 * Used to get the data value from a given pixel. This is the inverse of getPixelForValue
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 * @param pixel
                 */
                getValueForPixel: helpers$1.noop,

                /**
                 * Returns the location of the tick at the given index
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 */
                getPixelForTick: function(index) {
                    var me = this;
                    var offset = me.options.offset;
                    var numTicks = me._ticks.length;
                    var tickWidth = 1 / Math.max(numTicks - (offset ? 0 : 1), 1);

                    return index < 0 || index > numTicks - 1
                        ? null
                        : me.getPixelForDecimal(index * tickWidth + (offset ? tickWidth / 2 : 0));
                },

                /**
                 * Utility for getting the pixel location of a percentage of scale
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 */
                getPixelForDecimal: function(decimal) {
                    var me = this;

                    if (me._reversePixels) {
                        decimal = 1 - decimal;
                    }

                    return me._startPixel + decimal * me._length;
                },

                getDecimalForPixel: function(pixel) {
                    var decimal = (pixel - this._startPixel) / this._length;
                    return this._reversePixels ? 1 - decimal : decimal;
                },

                /**
                 * Returns the pixel for the minimum chart value
                 * The coordinate (0, 0) is at the upper-left corner of the canvas
                 */
                getBasePixel: function() {
                    return this.getPixelForValue(this.getBaseValue());
                },

                getBaseValue: function() {
                    var me = this;
                    var min = me.min;
                    var max = me.max;

                    return me.beginAtZero ? 0 :
                        min < 0 && max < 0 ? max :
                            min > 0 && max > 0 ? min :
                                0;
                },

                /**
                 * Returns a subset of ticks to be plotted to avoid overlapping labels.
                 * @private
                 */
                _autoSkip: function(ticks) {
                    var me = this;
                    var tickOpts = me.options.ticks;
                    var axisLength = me._length;
                    var ticksLimit = tickOpts.maxTicksLimit || axisLength / me._tickSize() + 1;
                    var majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
                    var numMajorIndices = majorIndices.length;
                    var first = majorIndices[0];
                    var last = majorIndices[numMajorIndices - 1];
                    var i, ilen, spacing, avgMajorSpacing;

                    // If there are too many major ticks to display them all
                    if (numMajorIndices > ticksLimit) {
                        skipMajors(ticks, majorIndices, numMajorIndices / ticksLimit);
                        return nonSkipped(ticks);
                    }

                    spacing = calculateSpacing(majorIndices, ticks, axisLength, ticksLimit);

                    if (numMajorIndices > 0) {
                        for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) {
                            skip(ticks, spacing, majorIndices[i], majorIndices[i + 1]);
                        }
                        avgMajorSpacing = numMajorIndices > 1 ? (last - first) / (numMajorIndices - 1) : null;
                        skip(ticks, spacing, helpers$1.isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
                        skip(ticks, spacing, last, helpers$1.isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
                        return nonSkipped(ticks);
                    }
                    skip(ticks, spacing);
                    return nonSkipped(ticks);
                },

                /**
                 * @private
                 */
                _tickSize: function() {
                    var me = this;
                    var optionTicks = me.options.ticks;

                    // Calculate space needed by label in axis direction.
                    var rot = helpers$1.toRadians(me.labelRotation);
                    var cos = Math.abs(Math.cos(rot));
                    var sin = Math.abs(Math.sin(rot));

                    var labelSizes = me._getLabelSizes();
                    var padding = optionTicks.autoSkipPadding || 0;
                    var w = labelSizes ? labelSizes.widest.width + padding : 0;
                    var h = labelSizes ? labelSizes.highest.height + padding : 0;

                    // Calculate space needed for 1 tick in axis direction.
                    return me.isHorizontal()
                        ? h * cos > w * sin ? w / cos : h / sin
                        : h * sin < w * cos ? h / cos : w / sin;
                },

                /**
                 * @private
                 */
                _isVisible: function() {
                    var me = this;
                    var chart = me.chart;
                    var display = me.options.display;
                    var i, ilen, meta;

                    if (display !== 'auto') {
                        return !!display;
                    }

                    // When 'auto', the scale is visible if at least one associated dataset is visible.
                    for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) {
                        if (chart.isDatasetVisible(i)) {
                            meta = chart.getDatasetMeta(i);
                            if (meta.xAxisID === me.id || meta.yAxisID === me.id) {
                                return true;
                            }
                        }
                    }

                    return false;
                },

                /**
                 * @private
                 */
                _computeGridLineItems: function(chartArea) {
                    var me = this;
                    var chart = me.chart;
                    var options = me.options;
                    var gridLines = options.gridLines;
                    var position = options.position;
                    var offsetGridLines = gridLines.offsetGridLines;
                    var isHorizontal = me.isHorizontal();
                    var ticks = me._ticksToDraw;
                    var ticksLength = ticks.length + (offsetGridLines ? 1 : 0);

                    var tl = getTickMarkLength(gridLines);
                    var items = [];
                    var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
                    var axisHalfWidth = axisWidth / 2;
                    var alignPixel = helpers$1._alignPixel;
                    var alignBorderValue = function(pixel) {
                        return alignPixel(chart, pixel, axisWidth);
                    };
                    var borderValue, i, tick, lineValue, alignedLineValue;
                    var tx1, ty1, tx2, ty2, x1, y1, x2, y2, lineWidth, lineColor, borderDash, borderDashOffset;

                    if (position === 'top') {
                        borderValue = alignBorderValue(me.bottom);
                        ty1 = me.bottom - tl;
                        ty2 = borderValue - axisHalfWidth;
                        y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
                        y2 = chartArea.bottom;
                    } else if (position === 'bottom') {
                        borderValue = alignBorderValue(me.top);
                        y1 = chartArea.top;
                        y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
                        ty1 = borderValue + axisHalfWidth;
                        ty2 = me.top + tl;
                    } else if (position === 'left') {
                        borderValue = alignBorderValue(me.right);
                        tx1 = me.right - tl;
                        tx2 = borderValue - axisHalfWidth;
                        x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
                        x2 = chartArea.right;
                    } else {
                        borderValue = alignBorderValue(me.left);
                        x1 = chartArea.left;
                        x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
                        tx1 = borderValue + axisHalfWidth;
                        tx2 = me.left + tl;
                    }

                    for (i = 0; i < ticksLength; ++i) {
                        tick = ticks[i] || {};

                        // autoskipper skipped this tick (#4635)
                        if (isNullOrUndef(tick.label) && i < ticks.length) {
                            continue;
                        }

                        if (i === me.zeroLineIndex && options.offset === offsetGridLines) {
                            // Draw the first index specially
                            lineWidth = gridLines.zeroLineWidth;
                            lineColor = gridLines.zeroLineColor;
                            borderDash = gridLines.zeroLineBorderDash || [];
                            borderDashOffset = gridLines.zeroLineBorderDashOffset || 0.0;
                        } else {
                            lineWidth = valueAtIndexOrDefault(gridLines.lineWidth, i, 1);
                            lineColor = valueAtIndexOrDefault(gridLines.color, i, 'rgba(0,0,0,0.1)');
                            borderDash = gridLines.borderDash || [];
                            borderDashOffset = gridLines.borderDashOffset || 0.0;
                        }

                        lineValue = getPixelForGridLine(me, tick._index || i, offsetGridLines);

                        // Skip if the pixel is out of the range
                        if (lineValue === undefined) {
                            continue;
                        }

                        alignedLineValue = alignPixel(chart, lineValue, lineWidth);

                        if (isHorizontal) {
                            tx1 = tx2 = x1 = x2 = alignedLineValue;
                        } else {
                            ty1 = ty2 = y1 = y2 = alignedLineValue;
                        }

                        items.push({
                            tx1: tx1,
                            ty1: ty1,
                            tx2: tx2,
                            ty2: ty2,
                            x1: x1,
                            y1: y1,
                            x2: x2,
                            y2: y2,
                            width: lineWidth,
                            color: lineColor,
                            borderDash: borderDash,
                            borderDashOffset: borderDashOffset,
                        });
                    }

                    items.ticksLength = ticksLength;
                    items.borderValue = borderValue;

                    return items;
                },

                /**
                 * @private
                 */
                _computeLabelItems: function() {
                    var me = this;
                    var options = me.options;
                    var optionTicks = options.ticks;
                    var position = options.position;
                    var isMirrored = optionTicks.mirror;
                    var isHorizontal = me.isHorizontal();
                    var ticks = me._ticksToDraw;
                    var fonts = parseTickFontOptions(optionTicks);
                    var tickPadding = optionTicks.padding;
                    var tl = getTickMarkLength(options.gridLines);
                    var rotation = -helpers$1.toRadians(me.labelRotation);
                    var items = [];
                    var i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;

                    if (position === 'top') {
                        y = me.bottom - tl - tickPadding;
                        textAlign = !rotation ? 'center' : 'left';
                    } else if (position === 'bottom') {
                        y = me.top + tl + tickPadding;
                        textAlign = !rotation ? 'center' : 'right';
                    } else if (position === 'left') {
                        x = me.right - (isMirrored ? 0 : tl) - tickPadding;
                        textAlign = isMirrored ? 'left' : 'right';
                    } else {
                        x = me.left + (isMirrored ? 0 : tl) + tickPadding;
                        textAlign = isMirrored ? 'right' : 'left';
                    }

                    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                        tick = ticks[i];
                        label = tick.label;

                        // autoskipper skipped this tick (#4635)
                        if (isNullOrUndef(label)) {
                            continue;
                        }

                        pixel = me.getPixelForTick(tick._index || i) + optionTicks.labelOffset;
                        font = tick.major ? fonts.major : fonts.minor;
                        lineHeight = font.lineHeight;
                        lineCount = isArray(label) ? label.length : 1;

                        if (isHorizontal) {
                            x = pixel;
                            textOffset = position === 'top'
                                ? ((!rotation ? 0.5 : 1) - lineCount) * lineHeight
                                : (!rotation ? 0.5 : 0) * lineHeight;
                        } else {
                            y = pixel;
                            textOffset = (1 - lineCount) * lineHeight / 2;
                        }

                        items.push({
                            x: x,
                            y: y,
                            rotation: rotation,
                            label: label,
                            font: font,
                            textOffset: textOffset,
                            textAlign: textAlign
                        });
                    }

                    return items;
                },

                /**
                 * @private
                 */
                _drawGrid: function(chartArea) {
                    var me = this;
                    var gridLines = me.options.gridLines;

                    if (!gridLines.display) {
                        return;
                    }

                    var ctx = me.ctx;
                    var chart = me.chart;
                    var alignPixel = helpers$1._alignPixel;
                    var axisWidth = gridLines.drawBorder ? valueAtIndexOrDefault(gridLines.lineWidth, 0, 0) : 0;
                    var items = me._gridLineItems || (me._gridLineItems = me._computeGridLineItems(chartArea));
                    var width, color, i, ilen, item;

                    for (i = 0, ilen = items.length; i < ilen; ++i) {
                        item = items[i];
                        width = item.width;
                        color = item.color;

                        if (width && color) {
                            ctx.save();
                            ctx.lineWidth = width;
                            ctx.strokeStyle = color;
                            if (ctx.setLineDash) {
                                ctx.setLineDash(item.borderDash);
                                ctx.lineDashOffset = item.borderDashOffset;
                            }

                            ctx.beginPath();

                            if (gridLines.drawTicks) {
                                ctx.moveTo(item.tx1, item.ty1);
                                ctx.lineTo(item.tx2, item.ty2);
                            }

                            if (gridLines.drawOnChartArea) {
                                ctx.moveTo(item.x1, item.y1);
                                ctx.lineTo(item.x2, item.y2);
                            }

                            ctx.stroke();
                            ctx.restore();
                        }
                    }

                    if (axisWidth) {
                        // Draw the line at the edge of the axis
                        var firstLineWidth = axisWidth;
                        var lastLineWidth = valueAtIndexOrDefault(gridLines.lineWidth, items.ticksLength - 1, 1);
                        var borderValue = items.borderValue;
                        var x1, x2, y1, y2;

                        if (me.isHorizontal()) {
                            x1 = alignPixel(chart, me.left, firstLineWidth) - firstLineWidth / 2;
                            x2 = alignPixel(chart, me.right, lastLineWidth) + lastLineWidth / 2;
                            y1 = y2 = borderValue;
                        } else {
                            y1 = alignPixel(chart, me.top, firstLineWidth) - firstLineWidth / 2;
                            y2 = alignPixel(chart, me.bottom, lastLineWidth) + lastLineWidth / 2;
                            x1 = x2 = borderValue;
                        }

                        ctx.lineWidth = axisWidth;
                        ctx.strokeStyle = valueAtIndexOrDefault(gridLines.color, 0);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                },

                /**
                 * @private
                 */
                _drawLabels: function() {
                    var me = this;
                    var optionTicks = me.options.ticks;

                    if (!optionTicks.display) {
                        return;
                    }

                    var ctx = me.ctx;
                    var items = me._labelItems || (me._labelItems = me._computeLabelItems());
                    var i, j, ilen, jlen, item, tickFont, label, y;

                    for (i = 0, ilen = items.length; i < ilen; ++i) {
                        item = items[i];
                        tickFont = item.font;

                        // Make sure we draw text in the correct color and font
                        ctx.save();
                        ctx.translate(item.x, item.y);
                        ctx.rotate(item.rotation);
                        ctx.font = tickFont.string;
                        ctx.fillStyle = tickFont.color;
                        ctx.textBaseline = 'middle';
                        ctx.textAlign = item.textAlign;

                        label = item.label;
                        y = item.textOffset;
                        if (isArray(label)) {
                            for (j = 0, jlen = label.length; j < jlen; ++j) {
                                // We just make sure the multiline element is a string here..
                                ctx.fillText('' + label[j], 0, y);
                                y += tickFont.lineHeight;
                            }
                        } else {
                            ctx.fillText(label, 0, y);
                        }
                        ctx.restore();
                    }
                },

                /**
                 * @private
                 */
                _drawTitle: function() {
                    var me = this;
                    var ctx = me.ctx;
                    var options = me.options;
                    var scaleLabel = options.scaleLabel;

                    if (!scaleLabel.display) {
                        return;
                    }

                    var scaleLabelFontColor = valueOrDefault$a(scaleLabel.fontColor, core_defaults.global.defaultFontColor);
                    var scaleLabelFont = helpers$1.options._parseFont(scaleLabel);
                    var scaleLabelPadding = helpers$1.options.toPadding(scaleLabel.padding);
                    var halfLineHeight = scaleLabelFont.lineHeight / 2;
                    var position = options.position;
                    var rotation = 0;
                    var scaleLabelX, scaleLabelY;

                    if (me.isHorizontal()) {
                        scaleLabelX = me.left + me.width / 2; // midpoint of the width
                        scaleLabelY = position === 'bottom'
                            ? me.bottom - halfLineHeight - scaleLabelPadding.bottom
                            : me.top + halfLineHeight + scaleLabelPadding.top;
                    } else {
                        var isLeft = position === 'left';
                        scaleLabelX = isLeft
                            ? me.left + halfLineHeight + scaleLabelPadding.top
                            : me.right - halfLineHeight - scaleLabelPadding.top;
                        scaleLabelY = me.top + me.height / 2;
                        rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;
                    }

                    ctx.save();
                    ctx.translate(scaleLabelX, scaleLabelY);
                    ctx.rotate(rotation);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillStyle = scaleLabelFontColor; // render in correct colour
                    ctx.font = scaleLabelFont.string;
                    ctx.fillText(scaleLabel.labelString, 0, 0);
                    ctx.restore();
                },

                draw: function(chartArea) {
                    var me = this;

                    if (!me._isVisible()) {
                        return;
                    }

                    me._drawGrid(chartArea);
                    me._drawTitle();
                    me._drawLabels();
                },

                /**
                 * @private
                 */
                _layers: function() {
                    var me = this;
                    var opts = me.options;
                    var tz = opts.ticks && opts.ticks.z || 0;
                    var gz = opts.gridLines && opts.gridLines.z || 0;

                    if (!me._isVisible() || tz === gz || me.draw !== me._draw) {
                        // backward compatibility: draw has been overridden by custom scale
                        return [{
                            z: tz,
                            draw: function() {
                                me.draw.apply(me, arguments);
                            }
                        }];
                    }

                    return [{
                        z: gz,
                        draw: function() {
                            me._drawGrid.apply(me, arguments);
                            me._drawTitle.apply(me, arguments);
                        }
                    }, {
                        z: tz,
                        draw: function() {
                            me._drawLabels.apply(me, arguments);
                        }
                    }];
                },

                /**
                 * @private
                 */
                _getMatchingVisibleMetas: function(type) {
                    var me = this;
                    var isHorizontal = me.isHorizontal();
                    return me.chart._getSortedVisibleDatasetMetas()
                        .filter(function(meta) {
                            return (!type || meta.type === type)
                                && (isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id);
                        });
                }
            });

            Scale.prototype._draw = Scale.prototype.draw;

            var core_scale = Scale;

            var isNullOrUndef$1 = helpers$1.isNullOrUndef;

            var defaultConfig = {
                position: 'bottom'
            };

            var scale_category = core_scale.extend({
                determineDataLimits: function() {
                    var me = this;
                    var labels = me._getLabels();
                    var ticksOpts = me.options.ticks;
                    var min = ticksOpts.min;
                    var max = ticksOpts.max;
                    var minIndex = 0;
                    var maxIndex = labels.length - 1;
                    var findIndex;

                    if (min !== undefined) {
                        // user specified min value
                        findIndex = labels.indexOf(min);
                        if (findIndex >= 0) {
                            minIndex = findIndex;
                        }
                    }

                    if (max !== undefined) {
                        // user specified max value
                        findIndex = labels.indexOf(max);
                        if (findIndex >= 0) {
                            maxIndex = findIndex;
                        }
                    }

                    me.minIndex = minIndex;
                    me.maxIndex = maxIndex;
                    me.min = labels[minIndex];
                    me.max = labels[maxIndex];
                },

                buildTicks: function() {
                    var me = this;
                    var labels = me._getLabels();
                    var minIndex = me.minIndex;
                    var maxIndex = me.maxIndex;

                    // If we are viewing some subset of labels, slice the original array
                    me.ticks = (minIndex === 0 && maxIndex === labels.length - 1) ? labels : labels.slice(minIndex, maxIndex + 1);
                },

                getLabelForIndex: function(index, datasetIndex) {
                    var me = this;
                    var chart = me.chart;

                    if (chart.getDatasetMeta(datasetIndex).controller._getValueScaleId() === me.id) {
                        return me.getRightValue(chart.data.datasets[datasetIndex].data[index]);
                    }

                    return me._getLabels()[index];
                },

                _configure: function() {
                    var me = this;
                    var offset = me.options.offset;
                    var ticks = me.ticks;

                    core_scale.prototype._configure.call(me);

                    if (!me.isHorizontal()) {
                        // For backward compatibility, vertical category scale reverse is inverted.
                        me._reversePixels = !me._reversePixels;
                    }

                    if (!ticks) {
                        return;
                    }

                    me._startValue = me.minIndex - (offset ? 0.5 : 0);
                    me._valueRange = Math.max(ticks.length - (offset ? 0 : 1), 1);
                },

                // Used to get data value locations.  Value can either be an index or a numerical value
                getPixelForValue: function(value, index, datasetIndex) {
                    var me = this;
                    var valueCategory, labels, idx;

                    if (!isNullOrUndef$1(index) && !isNullOrUndef$1(datasetIndex)) {
                        value = me.chart.data.datasets[datasetIndex].data[index];
                    }

                    // If value is a data object, then index is the index in the data array,
                    // not the index of the scale. We need to change that.
                    if (!isNullOrUndef$1(value)) {
                        valueCategory = me.isHorizontal() ? value.x : value.y;
                    }
                    if (valueCategory !== undefined || (value !== undefined && isNaN(index))) {
                        labels = me._getLabels();
                        value = helpers$1.valueOrDefault(valueCategory, value);
                        idx = labels.indexOf(value);
                        index = idx !== -1 ? idx : index;
                        if (isNaN(index)) {
                            index = value;
                        }
                    }
                    return me.getPixelForDecimal((index - me._startValue) / me._valueRange);
                },

                getPixelForTick: function(index) {
                    var ticks = this.ticks;
                    return index < 0 || index > ticks.length - 1
                        ? null
                        : this.getPixelForValue(ticks[index], index + this.minIndex);
                },

                getValueForPixel: function(pixel) {
                    var me = this;
                    var value = Math.round(me._startValue + me.getDecimalForPixel(pixel) * me._valueRange);
                    return Math.min(Math.max(value, 0), me.ticks.length - 1);
                },

                getBasePixel: function() {
                    return this.bottom;
                }
            });

            // INTERNAL: static default options, registered in src/index.js
            var _defaults = defaultConfig;
            scale_category._defaults = _defaults;

            var noop = helpers$1.noop;
            var isNullOrUndef$2 = helpers$1.isNullOrUndef;

            /**
             * Generate a set of linear ticks
             * @param generationOptions the options used to generate the ticks
             * @param dataRange the range of the data
             * @returns {number[]} array of tick values
             */
            function generateTicks(generationOptions, dataRange) {
                var ticks = [];
                // To get a "nice" value for the tick spacing, we will use the appropriately named
                // "nice number" algorithm. See https://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks
                // for details.

                var MIN_SPACING = 1e-14;
                var stepSize = generationOptions.stepSize;
                var unit = stepSize || 1;
                var maxNumSpaces = generationOptions.maxTicks - 1;
                var min = generationOptions.min;
                var max = generationOptions.max;
                var precision = generationOptions.precision;
                var rmin = dataRange.min;
                var rmax = dataRange.max;
                var spacing = helpers$1.niceNum((rmax - rmin) / maxNumSpaces / unit) * unit;
                var factor, niceMin, niceMax, numSpaces;

                // Beyond MIN_SPACING floating point numbers being to lose precision
                // such that we can't do the math necessary to generate ticks
                if (spacing < MIN_SPACING && isNullOrUndef$2(min) && isNullOrUndef$2(max)) {
                    return [rmin, rmax];
                }

                numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
                if (numSpaces > maxNumSpaces) {
                    // If the calculated num of spaces exceeds maxNumSpaces, recalculate it
                    spacing = helpers$1.niceNum(numSpaces * spacing / maxNumSpaces / unit) * unit;
                }

                if (stepSize || isNullOrUndef$2(precision)) {
                    // If a precision is not specified, calculate factor based on spacing
                    factor = Math.pow(10, helpers$1._decimalPlaces(spacing));
                } else {
                    // If the user specified a precision, round to that number of decimal places
                    factor = Math.pow(10, precision);
                    spacing = Math.ceil(spacing * factor) / factor;
                }

                niceMin = Math.floor(rmin / spacing) * spacing;
                niceMax = Math.ceil(rmax / spacing) * spacing;

                // If min, max and stepSize is set and they make an evenly spaced scale use it.
                if (stepSize) {
                    // If very close to our whole number, use it.
                    if (!isNullOrUndef$2(min) && helpers$1.almostWhole(min / spacing, spacing / 1000)) {
                        niceMin = min;
                    }
                    if (!isNullOrUndef$2(max) && helpers$1.almostWhole(max / spacing, spacing / 1000)) {
                        niceMax = max;
                    }
                }

                numSpaces = (niceMax - niceMin) / spacing;
                // If very close to our rounded value, use it.
                if (helpers$1.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {
                    numSpaces = Math.round(numSpaces);
                } else {
                    numSpaces = Math.ceil(numSpaces);
                }

                niceMin = Math.round(niceMin * factor) / factor;
                niceMax = Math.round(niceMax * factor) / factor;
                ticks.push(isNullOrUndef$2(min) ? niceMin : min);
                for (var j = 1; j < numSpaces; ++j) {
                    ticks.push(Math.round((niceMin + j * spacing) * factor) / factor);
                }
                ticks.push(isNullOrUndef$2(max) ? niceMax : max);

                return ticks;
            }

            var scale_linearbase = core_scale.extend({
                getRightValue: function(value) {
                    if (typeof value === 'string') {
                        return +value;
                    }
                    return core_scale.prototype.getRightValue.call(this, value);
                },

                handleTickRangeOptions: function() {
                    var me = this;
                    var opts = me.options;
                    var tickOpts = opts.ticks;

                    // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,
                    // do nothing since that would make the chart weird. If the user really wants a weird chart
                    // axis, they can manually override it
                    if (tickOpts.beginAtZero) {
                        var minSign = helpers$1.sign(me.min);
                        var maxSign = helpers$1.sign(me.max);

                        if (minSign < 0 && maxSign < 0) {
                            // move the top up to 0
                            me.max = 0;
                        } else if (minSign > 0 && maxSign > 0) {
                            // move the bottom down to 0
                            me.min = 0;
                        }
                    }

                    var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;
                    var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;

                    if (tickOpts.min !== undefined) {
                        me.min = tickOpts.min;
                    } else if (tickOpts.suggestedMin !== undefined) {
                        if (me.min === null) {
                            me.min = tickOpts.suggestedMin;
                        } else {
                            me.min = Math.min(me.min, tickOpts.suggestedMin);
                        }
                    }

                    if (tickOpts.max !== undefined) {
                        me.max = tickOpts.max;
                    } else if (tickOpts.suggestedMax !== undefined) {
                        if (me.max === null) {
                            me.max = tickOpts.suggestedMax;
                        } else {
                            me.max = Math.max(me.max, tickOpts.suggestedMax);
                        }
                    }

                    if (setMin !== setMax) {
                        // We set the min or the max but not both.
                        // So ensure that our range is good
                        // Inverted or 0 length range can happen when
                        // ticks.min is set, and no datasets are visible
                        if (me.min >= me.max) {
                            if (setMin) {
                                me.max = me.min + 1;
                            } else {
                                me.min = me.max - 1;
                            }
                        }
                    }

                    if (me.min === me.max) {
                        me.max++;

                        if (!tickOpts.beginAtZero) {
                            me.min--;
                        }
                    }
                },

                getTickLimit: function() {
                    var me = this;
                    var tickOpts = me.options.ticks;
                    var stepSize = tickOpts.stepSize;
                    var maxTicksLimit = tickOpts.maxTicksLimit;
                    var maxTicks;

                    if (stepSize) {
                        maxTicks = Math.ceil(me.max / stepSize) - Math.floor(me.min / stepSize) + 1;
                    } else {
                        maxTicks = me._computeTickLimit();
                        maxTicksLimit = maxTicksLimit || 11;
                    }

                    if (maxTicksLimit) {
                        maxTicks = Math.min(maxTicksLimit, maxTicks);
                    }

                    return maxTicks;
                },

                _computeTickLimit: function() {
                    return Number.POSITIVE_INFINITY;
                },

                handleDirectionalChanges: noop,

                buildTicks: function() {
                    var me = this;
                    var opts = me.options;
                    var tickOpts = opts.ticks;

                    // Figure out what the max number of ticks we can support it is based on the size of
                    // the axis area. For now, we say that the minimum tick spacing in pixels must be 40
                    // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on
                    // the graph. Make sure we always have at least 2 ticks
                    var maxTicks = me.getTickLimit();
                    maxTicks = Math.max(2, maxTicks);

                    var numericGeneratorOptions = {
                        maxTicks: maxTicks,
                        min: tickOpts.min,
                        max: tickOpts.max,
                        precision: tickOpts.precision,
                        stepSize: helpers$1.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)
                    };
                    var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);

                    me.handleDirectionalChanges();

                    // At this point, we need to update our max and min given the tick values since we have expanded the
                    // range of the scale
                    me.max = helpers$1.max(ticks);
                    me.min = helpers$1.min(ticks);

                    if (tickOpts.reverse) {
                        ticks.reverse();

                        me.start = me.max;
                        me.end = me.min;
                    } else {
                        me.start = me.min;
                        me.end = me.max;
                    }
                },

                convertTicksToLabels: function() {
                    var me = this;
                    me.ticksAsNumbers = me.ticks.slice();
                    me.zeroLineIndex = me.ticks.indexOf(0);

                    core_scale.prototype.convertTicksToLabels.call(me);
                },

                _configure: function() {
                    var me = this;
                    var ticks = me.getTicks();
                    var start = me.min;
                    var end = me.max;
                    var offset;

                    core_scale.prototype._configure.call(me);

                    if (me.options.offset && ticks.length) {
                        offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
                        start -= offset;
                        end += offset;
                    }
                    me._startValue = start;
                    me._endValue = end;
                    me._valueRange = end - start;
                }
            });

            var defaultConfig$1 = {
                position: 'left',
                ticks: {
                    callback: core_ticks.formatters.linear
                }
            };

            var DEFAULT_MIN = 0;
            var DEFAULT_MAX = 1;

            function getOrCreateStack(stacks, stacked, meta) {
                var key = [
                    meta.type,
                    // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
                    stacked === undefined && meta.stack === undefined ? meta.index : '',
                    meta.stack
                ].join('.');

                if (stacks[key] === undefined) {
                    stacks[key] = {
                        pos: [],
                        neg: []
                    };
                }

                return stacks[key];
            }

            function stackData(scale, stacks, meta, data) {
                var opts = scale.options;
                var stacked = opts.stacked;
                var stack = getOrCreateStack(stacks, stacked, meta);
                var pos = stack.pos;
                var neg = stack.neg;
                var ilen = data.length;
                var i, value;

                for (i = 0; i < ilen; ++i) {
                    value = scale._parseValue(data[i]);
                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
                        continue;
                    }

                    pos[i] = pos[i] || 0;
                    neg[i] = neg[i] || 0;

                    if (opts.relativePoints) {
                        pos[i] = 100;
                    } else if (value.min < 0 || value.max < 0) {
                        neg[i] += value.min;
                    } else {
                        pos[i] += value.max;
                    }
                }
            }

            function updateMinMax(scale, meta, data) {
                var ilen = data.length;
                var i, value;

                for (i = 0; i < ilen; ++i) {
                    value = scale._parseValue(data[i]);
                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden) {
                        continue;
                    }

                    scale.min = Math.min(scale.min, value.min);
                    scale.max = Math.max(scale.max, value.max);
                }
            }

            var scale_linear = scale_linearbase.extend({
                determineDataLimits: function() {
                    var me = this;
                    var opts = me.options;
                    var chart = me.chart;
                    var datasets = chart.data.datasets;
                    var metasets = me._getMatchingVisibleMetas();
                    var hasStacks = opts.stacked;
                    var stacks = {};
                    var ilen = metasets.length;
                    var i, meta, data, values;

                    me.min = Number.POSITIVE_INFINITY;
                    me.max = Number.NEGATIVE_INFINITY;

                    if (hasStacks === undefined) {
                        for (i = 0; !hasStacks && i < ilen; ++i) {
                            meta = metasets[i];
                            hasStacks = meta.stack !== undefined;
                        }
                    }

                    for (i = 0; i < ilen; ++i) {
                        meta = metasets[i];
                        data = datasets[meta.index].data;
                        if (hasStacks) {
                            stackData(me, stacks, meta, data);
                        } else {
                            updateMinMax(me, meta, data);
                        }
                    }

                    helpers$1.each(stacks, function(stackValues) {
                        values = stackValues.pos.concat(stackValues.neg);
                        me.min = Math.min(me.min, helpers$1.min(values));
                        me.max = Math.max(me.max, helpers$1.max(values));
                    });

                    me.min = helpers$1.isFinite(me.min) && !isNaN(me.min) ? me.min : DEFAULT_MIN;
                    me.max = helpers$1.isFinite(me.max) && !isNaN(me.max) ? me.max : DEFAULT_MAX;

                    // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
                    me.handleTickRangeOptions();
                },

                // Returns the maximum number of ticks based on the scale dimension
                _computeTickLimit: function() {
                    var me = this;
                    var tickFont;

                    if (me.isHorizontal()) {
                        return Math.ceil(me.width / 40);
                    }
                    tickFont = helpers$1.options._parseFont(me.options.ticks);
                    return Math.ceil(me.height / tickFont.lineHeight);
                },

                // Called after the ticks are built. We need
                handleDirectionalChanges: function() {
                    if (!this.isHorizontal()) {
                        // We are in a vertical orientation. The top value is the highest. So reverse the array
                        this.ticks.reverse();
                    }
                },

                getLabelForIndex: function(index, datasetIndex) {
                    return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
                },

                // Utils
                getPixelForValue: function(value) {
                    var me = this;
                    return me.getPixelForDecimal((+me.getRightValue(value) - me._startValue) / me._valueRange);
                },

                getValueForPixel: function(pixel) {
                    return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
                },

                getPixelForTick: function(index) {
                    var ticks = this.ticksAsNumbers;
                    if (index < 0 || index > ticks.length - 1) {
                        return null;
                    }
                    return this.getPixelForValue(ticks[index]);
                }
            });

            // INTERNAL: static default options, registered in src/index.js
            var _defaults$1 = defaultConfig$1;
            scale_linear._defaults = _defaults$1;

            var valueOrDefault$b = helpers$1.valueOrDefault;
            var log10 = helpers$1.math.log10;

            /**
             * Generate a set of logarithmic ticks
             * @param generationOptions the options used to generate the ticks
             * @param dataRange the range of the data
             * @returns {number[]} array of tick values
             */
            function generateTicks$1(generationOptions, dataRange) {
                var ticks = [];

                var tickVal = valueOrDefault$b(generationOptions.min, Math.pow(10, Math.floor(log10(dataRange.min))));

                var endExp = Math.floor(log10(dataRange.max));
                var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));
                var exp, significand;

                if (tickVal === 0) {
                    exp = Math.floor(log10(dataRange.minNotZero));
                    significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));

                    ticks.push(tickVal);
                    tickVal = significand * Math.pow(10, exp);
                } else {
                    exp = Math.floor(log10(tickVal));
                    significand = Math.floor(tickVal / Math.pow(10, exp));
                }
                var precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;

                do {
                    ticks.push(tickVal);

                    ++significand;
                    if (significand === 10) {
                        significand = 1;
                        ++exp;
                        precision = exp >= 0 ? 1 : precision;
                    }

                    tickVal = Math.round(significand * Math.pow(10, exp) * precision) / precision;
                } while (exp < endExp || (exp === endExp && significand < endSignificand));

                var lastTick = valueOrDefault$b(generationOptions.max, tickVal);
                ticks.push(lastTick);

                return ticks;
            }

            var defaultConfig$2 = {
                position: 'left',

                // label settings
                ticks: {
                    callback: core_ticks.formatters.logarithmic
                }
            };

            // TODO(v3): change this to positiveOrDefault
            function nonNegativeOrDefault(value, defaultValue) {
                return helpers$1.isFinite(value) && value >= 0 ? value : defaultValue;
            }

            var scale_logarithmic = core_scale.extend({
                determineDataLimits: function() {
                    var me = this;
                    var opts = me.options;
                    var chart = me.chart;
                    var datasets = chart.data.datasets;
                    var isHorizontal = me.isHorizontal();
                    function IDMatches(meta) {
                        return isHorizontal ? meta.xAxisID === me.id : meta.yAxisID === me.id;
                    }
                    var datasetIndex, meta, value, data, i, ilen;

                    // Calculate Range
                    me.min = Number.POSITIVE_INFINITY;
                    me.max = Number.NEGATIVE_INFINITY;
                    me.minNotZero = Number.POSITIVE_INFINITY;

                    var hasStacks = opts.stacked;
                    if (hasStacks === undefined) {
                        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                            meta = chart.getDatasetMeta(datasetIndex);
                            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta) &&
                                meta.stack !== undefined) {
                                hasStacks = true;
                                break;
                            }
                        }
                    }

                    if (opts.stacked || hasStacks) {
                        var valuesPerStack = {};

                        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                            meta = chart.getDatasetMeta(datasetIndex);
                            var key = [
                                meta.type,
                                // we have a separate stack for stack=undefined datasets when the opts.stacked is undefined
                                ((opts.stacked === undefined && meta.stack === undefined) ? datasetIndex : ''),
                                meta.stack
                            ].join('.');

                            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                if (valuesPerStack[key] === undefined) {
                                    valuesPerStack[key] = [];
                                }

                                data = datasets[datasetIndex].data;
                                for (i = 0, ilen = data.length; i < ilen; i++) {
                                    var values = valuesPerStack[key];
                                    value = me._parseValue(data[i]);
                                    // invalid, hidden and negative values are ignored
                                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                                        continue;
                                    }
                                    values[i] = values[i] || 0;
                                    values[i] += value.max;
                                }
                            }
                        }

                        helpers$1.each(valuesPerStack, function(valuesForType) {
                            if (valuesForType.length > 0) {
                                var minVal = helpers$1.min(valuesForType);
                                var maxVal = helpers$1.max(valuesForType);
                                me.min = Math.min(me.min, minVal);
                                me.max = Math.max(me.max, maxVal);
                            }
                        });

                    } else {
                        for (datasetIndex = 0; datasetIndex < datasets.length; datasetIndex++) {
                            meta = chart.getDatasetMeta(datasetIndex);
                            if (chart.isDatasetVisible(datasetIndex) && IDMatches(meta)) {
                                data = datasets[datasetIndex].data;
                                for (i = 0, ilen = data.length; i < ilen; i++) {
                                    value = me._parseValue(data[i]);
                                    // invalid, hidden and negative values are ignored
                                    if (isNaN(value.min) || isNaN(value.max) || meta.data[i].hidden || value.min < 0 || value.max < 0) {
                                        continue;
                                    }

                                    me.min = Math.min(value.min, me.min);
                                    me.max = Math.max(value.max, me.max);

                                    if (value.min !== 0) {
                                        me.minNotZero = Math.min(value.min, me.minNotZero);
                                    }
                                }
                            }
                        }
                    }

                    me.min = helpers$1.isFinite(me.min) ? me.min : null;
                    me.max = helpers$1.isFinite(me.max) ? me.max : null;
                    me.minNotZero = helpers$1.isFinite(me.minNotZero) ? me.minNotZero : null;

                    // Common base implementation to handle ticks.min, ticks.max
                    this.handleTickRangeOptions();
                },

                handleTickRangeOptions: function() {
                    var me = this;
                    var tickOpts = me.options.ticks;
                    var DEFAULT_MIN = 1;
                    var DEFAULT_MAX = 10;

                    me.min = nonNegativeOrDefault(tickOpts.min, me.min);
                    me.max = nonNegativeOrDefault(tickOpts.max, me.max);

                    if (me.min === me.max) {
                        if (me.min !== 0 && me.min !== null) {
                            me.min = Math.pow(10, Math.floor(log10(me.min)) - 1);
                            me.max = Math.pow(10, Math.floor(log10(me.max)) + 1);
                        } else {
                            me.min = DEFAULT_MIN;
                            me.max = DEFAULT_MAX;
                        }
                    }
                    if (me.min === null) {
                        me.min = Math.pow(10, Math.floor(log10(me.max)) - 1);
                    }
                    if (me.max === null) {
                        me.max = me.min !== 0
                            ? Math.pow(10, Math.floor(log10(me.min)) + 1)
                            : DEFAULT_MAX;
                    }
                    if (me.minNotZero === null) {
                        if (me.min > 0) {
                            me.minNotZero = me.min;
                        } else if (me.max < 1) {
                            me.minNotZero = Math.pow(10, Math.floor(log10(me.max)));
                        } else {
                            me.minNotZero = DEFAULT_MIN;
                        }
                    }
                },

                buildTicks: function() {
                    var me = this;
                    var tickOpts = me.options.ticks;
                    var reverse = !me.isHorizontal();

                    var generationOptions = {
                        min: nonNegativeOrDefault(tickOpts.min),
                        max: nonNegativeOrDefault(tickOpts.max)
                    };
                    var ticks = me.ticks = generateTicks$1(generationOptions, me);

                    // At this point, we need to update our max and min given the tick values since we have expanded the
                    // range of the scale
                    me.max = helpers$1.max(ticks);
                    me.min = helpers$1.min(ticks);

                    if (tickOpts.reverse) {
                        reverse = !reverse;
                        me.start = me.max;
                        me.end = me.min;
                    } else {
                        me.start = me.min;
                        me.end = me.max;
                    }
                    if (reverse) {
                        ticks.reverse();
                    }
                },

                convertTicksToLabels: function() {
                    this.tickValues = this.ticks.slice();

                    core_scale.prototype.convertTicksToLabels.call(this);
                },

                // Get the correct tooltip label
                getLabelForIndex: function(index, datasetIndex) {
                    return this._getScaleLabel(this.chart.data.datasets[datasetIndex].data[index]);
                },

                getPixelForTick: function(index) {
                    var ticks = this.tickValues;
                    if (index < 0 || index > ticks.length - 1) {
                        return null;
                    }
                    return this.getPixelForValue(ticks[index]);
                },

                /**
                 * Returns the value of the first tick.
                 * @param {number} value - The minimum not zero value.
                 * @return {number} The first tick value.
                 * @private
                 */
                _getFirstTickValue: function(value) {
                    var exp = Math.floor(log10(value));
                    var significand = Math.floor(value / Math.pow(10, exp));

                    return significand * Math.pow(10, exp);
                },

                _configure: function() {
                    var me = this;
                    var start = me.min;
                    var offset = 0;

                    core_scale.prototype._configure.call(me);

                    if (start === 0) {
                        start = me._getFirstTickValue(me.minNotZero);
                        offset = valueOrDefault$b(me.options.ticks.fontSize, core_defaults.global.defaultFontSize) / me._length;
                    }

                    me._startValue = log10(start);
                    me._valueOffset = offset;
                    me._valueRange = (log10(me.max) - log10(start)) / (1 - offset);
                },

                getPixelForValue: function(value) {
                    var me = this;
                    var decimal = 0;

                    value = +me.getRightValue(value);

                    if (value > me.min && value > 0) {
                        decimal = (log10(value) - me._startValue) / me._valueRange + me._valueOffset;
                    }
                    return me.getPixelForDecimal(decimal);
                },

                getValueForPixel: function(pixel) {
                    var me = this;
                    var decimal = me.getDecimalForPixel(pixel);
                    return decimal === 0 && me.min === 0
                        ? 0
                        : Math.pow(10, me._startValue + (decimal - me._valueOffset) * me._valueRange);
                }
            });

            // INTERNAL: static default options, registered in src/index.js
            var _defaults$2 = defaultConfig$2;
            scale_logarithmic._defaults = _defaults$2;

            var valueOrDefault$c = helpers$1.valueOrDefault;
            var valueAtIndexOrDefault$1 = helpers$1.valueAtIndexOrDefault;
            var resolve$4 = helpers$1.options.resolve;

            var defaultConfig$3 = {
                display: true,

                // Boolean - Whether to animate scaling the chart from the centre
                animate: true,
                position: 'chartArea',

                angleLines: {
                    display: true,
                    color: 'rgba(0,0,0,0.1)',
                    lineWidth: 1,
                    borderDash: [],
                    borderDashOffset: 0.0
                },

                gridLines: {
                    circular: false
                },

                // label settings
                ticks: {
                    // Boolean - Show a backdrop to the scale label
                    showLabelBackdrop: true,

                    // String - The colour of the label backdrop
                    backdropColor: 'rgba(255,255,255,0.75)',

                    // Number - The backdrop padding above & below the label in pixels
                    backdropPaddingY: 2,

                    // Number - The backdrop padding to the side of the label in pixels
                    backdropPaddingX: 2,

                    callback: core_ticks.formatters.linear
                },

                pointLabels: {
                    // Boolean - if true, show point labels
                    display: true,

                    // Number - Point label font size in pixels
                    fontSize: 10,

                    // Function - Used to convert point labels
                    callback: function(label) {
                        return label;
                    }
                }
            };

            function getTickBackdropHeight(opts) {
                var tickOpts = opts.ticks;

                if (tickOpts.display && opts.display) {
                    return valueOrDefault$c(tickOpts.fontSize, core_defaults.global.defaultFontSize) + tickOpts.backdropPaddingY * 2;
                }
                return 0;
            }

            function measureLabelSize(ctx, lineHeight, label) {
                if (helpers$1.isArray(label)) {
                    return {
                        w: helpers$1.longestText(ctx, ctx.font, label),
                        h: label.length * lineHeight
                    };
                }

                return {
                    w: ctx.measureText(label).width,
                    h: lineHeight
                };
            }

            function determineLimits(angle, pos, size, min, max) {
                if (angle === min || angle === max) {
                    return {
                        start: pos - (size / 2),
                        end: pos + (size / 2)
                    };
                } else if (angle < min || angle > max) {
                    return {
                        start: pos - size,
                        end: pos
                    };
                }

                return {
                    start: pos,
                    end: pos + size
                };
            }

            /**
             * Helper function to fit a radial linear scale with point labels
             */
            function fitWithPointLabels(scale) {

                // Right, this is really confusing and there is a lot of maths going on here
                // The gist of the problem is here: https://gist.github.com/nnnick/696cc9c55f4b0beb8fe9
                //
                // Reaction: https://dl.dropboxusercontent.com/u/34601363/toomuchscience.gif
                //
                // Solution:
                //
                // We assume the radius of the polygon is half the size of the canvas at first
                // at each index we check if the text overlaps.
                //
                // Where it does, we store that angle and that index.
                //
                // After finding the largest index and angle we calculate how much we need to remove
                // from the shape radius to move the point inwards by that x.
                //
                // We average the left and right distances to get the maximum shape radius that can fit in the box
                // along with labels.
                //
                // Once we have that, we can find the centre point for the chart, by taking the x text protrusion
                // on each side, removing that from the size, halving it and adding the left x protrusion width.
                //
                // This will mean we have a shape fitted to the canvas, as large as it can be with the labels
                // and position it in the most space efficient manner
                //
                // https://dl.dropboxusercontent.com/u/34601363/yeahscience.gif

                var plFont = helpers$1.options._parseFont(scale.options.pointLabels);

                // Get maximum radius of the polygon. Either half the height (minus the text width) or half the width.
                // Use this to calculate the offset + change. - Make sure L/R protrusion is at least 0 to stop issues with centre points
                var furthestLimits = {
                    l: 0,
                    r: scale.width,
                    t: 0,
                    b: scale.height - scale.paddingTop
                };
                var furthestAngles = {};
                var i, textSize, pointPosition;

                scale.ctx.font = plFont.string;
                scale._pointLabelSizes = [];

                var valueCount = scale.chart.data.labels.length;
                for (i = 0; i < valueCount; i++) {
                    pointPosition = scale.getPointPosition(i, scale.drawingArea + 5);
                    textSize = measureLabelSize(scale.ctx, plFont.lineHeight, scale.pointLabels[i]);
                    scale._pointLabelSizes[i] = textSize;

                    // Add quarter circle to make degree 0 mean top of circle
                    var angleRadians = scale.getIndexAngle(i);
                    var angle = helpers$1.toDegrees(angleRadians) % 360;
                    var hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
                    var vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);

                    if (hLimits.start < furthestLimits.l) {
                        furthestLimits.l = hLimits.start;
                        furthestAngles.l = angleRadians;
                    }

                    if (hLimits.end > furthestLimits.r) {
                        furthestLimits.r = hLimits.end;
                        furthestAngles.r = angleRadians;
                    }

                    if (vLimits.start < furthestLimits.t) {
                        furthestLimits.t = vLimits.start;
                        furthestAngles.t = angleRadians;
                    }

                    if (vLimits.end > furthestLimits.b) {
                        furthestLimits.b = vLimits.end;
                        furthestAngles.b = angleRadians;
                    }
                }

                scale.setReductions(scale.drawingArea, furthestLimits, furthestAngles);
            }

            function getTextAlignForAngle(angle) {
                if (angle === 0 || angle === 180) {
                    return 'center';
                } else if (angle < 180) {
                    return 'left';
                }

                return 'right';
            }

            function fillText(ctx, text, position, lineHeight) {
                var y = position.y + lineHeight / 2;
                var i, ilen;

                if (helpers$1.isArray(text)) {
                    for (i = 0, ilen = text.length; i < ilen; ++i) {
                        ctx.fillText(text[i], position.x, y);
                        y += lineHeight;
                    }
                } else {
                    ctx.fillText(text, position.x, y);
                }
            }

            function adjustPointPositionForLabelHeight(angle, textSize, position) {
                if (angle === 90 || angle === 270) {
                    position.y -= (textSize.h / 2);
                } else if (angle > 270 || angle < 90) {
                    position.y -= textSize.h;
                }
            }

            function drawPointLabels(scale) {
                var ctx = scale.ctx;
                var opts = scale.options;
                var pointLabelOpts = opts.pointLabels;
                var tickBackdropHeight = getTickBackdropHeight(opts);
                var outerDistance = scale.getDistanceFromCenterForValue(opts.ticks.reverse ? scale.min : scale.max);
                var plFont = helpers$1.options._parseFont(pointLabelOpts);

                ctx.save();

                ctx.font = plFont.string;
                ctx.textBaseline = 'middle';

                for (var i = scale.chart.data.labels.length - 1; i >= 0; i--) {
                    // Extra pixels out for some label spacing
                    var extra = (i === 0 ? tickBackdropHeight / 2 : 0);
                    var pointLabelPosition = scale.getPointPosition(i, outerDistance + extra + 5);

                    // Keep this in loop since we may support array properties here
                    var pointLabelFontColor = valueAtIndexOrDefault$1(pointLabelOpts.fontColor, i, core_defaults.global.defaultFontColor);
                    ctx.fillStyle = pointLabelFontColor;

                    var angleRadians = scale.getIndexAngle(i);
                    var angle = helpers$1.toDegrees(angleRadians);
                    ctx.textAlign = getTextAlignForAngle(angle);
                    adjustPointPositionForLabelHeight(angle, scale._pointLabelSizes[i], pointLabelPosition);
                    fillText(ctx, scale.pointLabels[i], pointLabelPosition, plFont.lineHeight);
                }
                ctx.restore();
            }

            function drawRadiusLine(scale, gridLineOpts, radius, index) {
                var ctx = scale.ctx;
                var circular = gridLineOpts.circular;
                var valueCount = scale.chart.data.labels.length;
                var lineColor = valueAtIndexOrDefault$1(gridLineOpts.color, index - 1);
                var lineWidth = valueAtIndexOrDefault$1(gridLineOpts.lineWidth, index - 1);
                var pointPosition;

                if ((!circular && !valueCount) || !lineColor || !lineWidth) {
                    return;
                }

                ctx.save();
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = lineWidth;
                if (ctx.setLineDash) {
                    ctx.setLineDash(gridLineOpts.borderDash || []);
                    ctx.lineDashOffset = gridLineOpts.borderDashOffset || 0.0;
                }

                ctx.beginPath();
                if (circular) {
                    // Draw circular arcs between the points
                    ctx.arc(scale.xCenter, scale.yCenter, radius, 0, Math.PI * 2);
                } else {
                    // Draw straight lines connecting each index
                    pointPosition = scale.getPointPosition(0, radius);
                    ctx.moveTo(pointPosition.x, pointPosition.y);

                    for (var i = 1; i < valueCount; i++) {
                        pointPosition = scale.getPointPosition(i, radius);
                        ctx.lineTo(pointPosition.x, pointPosition.y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }

            function numberOrZero(param) {
                return helpers$1.isNumber(param) ? param : 0;
            }

            var scale_radialLinear = scale_linearbase.extend({
                setDimensions: function() {
                    var me = this;

                    // Set the unconstrained dimension before label rotation
                    me.width = me.maxWidth;
                    me.height = me.maxHeight;
                    me.paddingTop = getTickBackdropHeight(me.options) / 2;
                    me.xCenter = Math.floor(me.width / 2);
                    me.yCenter = Math.floor((me.height - me.paddingTop) / 2);
                    me.drawingArea = Math.min(me.height - me.paddingTop, me.width) / 2;
                },

                determineDataLimits: function() {
                    var me = this;
                    var chart = me.chart;
                    var min = Number.POSITIVE_INFINITY;
                    var max = Number.NEGATIVE_INFINITY;

                    helpers$1.each(chart.data.datasets, function(dataset, datasetIndex) {
                        if (chart.isDatasetVisible(datasetIndex)) {
                            var meta = chart.getDatasetMeta(datasetIndex);

                            helpers$1.each(dataset.data, function(rawValue, index) {
                                var value = +me.getRightValue(rawValue);
                                if (isNaN(value) || meta.data[index].hidden) {
                                    return;
                                }

                                min = Math.min(value, min);
                                max = Math.max(value, max);
                            });
                        }
                    });

                    me.min = (min === Number.POSITIVE_INFINITY ? 0 : min);
                    me.max = (max === Number.NEGATIVE_INFINITY ? 0 : max);

                    // Common base implementation to handle ticks.min, ticks.max, ticks.beginAtZero
                    me.handleTickRangeOptions();
                },

                // Returns the maximum number of ticks based on the scale dimension
                _computeTickLimit: function() {
                    return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
                },

                convertTicksToLabels: function() {
                    var me = this;

                    scale_linearbase.prototype.convertTicksToLabels.call(me);

                    // Point labels
                    me.pointLabels = me.chart.data.labels.map(function() {
                        var label = helpers$1.callback(me.options.pointLabels.callback, arguments, me);
                        return label || label === 0 ? label : '';
                    });
                },

                getLabelForIndex: function(index, datasetIndex) {
                    return +this.getRightValue(this.chart.data.datasets[datasetIndex].data[index]);
                },

                fit: function() {
                    var me = this;
                    var opts = me.options;

                    if (opts.display && opts.pointLabels.display) {
                        fitWithPointLabels(me);
                    } else {
                        me.setCenterPoint(0, 0, 0, 0);
                    }
                },

                /**
                 * Set radius reductions and determine new radius and center point
                 * @private
                 */
                setReductions: function(largestPossibleRadius, furthestLimits, furthestAngles) {
                    var me = this;
                    var radiusReductionLeft = furthestLimits.l / Math.sin(furthestAngles.l);
                    var radiusReductionRight = Math.max(furthestLimits.r - me.width, 0) / Math.sin(furthestAngles.r);
                    var radiusReductionTop = -furthestLimits.t / Math.cos(furthestAngles.t);
                    var radiusReductionBottom = -Math.max(furthestLimits.b - (me.height - me.paddingTop), 0) / Math.cos(furthestAngles.b);

                    radiusReductionLeft = numberOrZero(radiusReductionLeft);
                    radiusReductionRight = numberOrZero(radiusReductionRight);
                    radiusReductionTop = numberOrZero(radiusReductionTop);
                    radiusReductionBottom = numberOrZero(radiusReductionBottom);

                    me.drawingArea = Math.min(
                        Math.floor(largestPossibleRadius - (radiusReductionLeft + radiusReductionRight) / 2),
                        Math.floor(largestPossibleRadius - (radiusReductionTop + radiusReductionBottom) / 2));
                    me.setCenterPoint(radiusReductionLeft, radiusReductionRight, radiusReductionTop, radiusReductionBottom);
                },

                setCenterPoint: function(leftMovement, rightMovement, topMovement, bottomMovement) {
                    var me = this;
                    var maxRight = me.width - rightMovement - me.drawingArea;
                    var maxLeft = leftMovement + me.drawingArea;
                    var maxTop = topMovement + me.drawingArea;
                    var maxBottom = (me.height - me.paddingTop) - bottomMovement - me.drawingArea;

                    me.xCenter = Math.floor(((maxLeft + maxRight) / 2) + me.left);
                    me.yCenter = Math.floor(((maxTop + maxBottom) / 2) + me.top + me.paddingTop);
                },

                getIndexAngle: function(index) {
                    var chart = this.chart;
                    var angleMultiplier = 360 / chart.data.labels.length;
                    var options = chart.options || {};
                    var startAngle = options.startAngle || 0;

                    // Start from the top instead of right, so remove a quarter of the circle
                    var angle = (index * angleMultiplier + startAngle) % 360;

                    return (angle < 0 ? angle + 360 : angle) * Math.PI * 2 / 360;
                },

                getDistanceFromCenterForValue: function(value) {
                    var me = this;

                    if (helpers$1.isNullOrUndef(value)) {
                        return NaN;
                    }

                    // Take into account half font size + the yPadding of the top value
                    var scalingFactor = me.drawingArea / (me.max - me.min);
                    if (me.options.ticks.reverse) {
                        return (me.max - value) * scalingFactor;
                    }
                    return (value - me.min) * scalingFactor;
                },

                getPointPosition: function(index, distanceFromCenter) {
                    var me = this;
                    var thisAngle = me.getIndexAngle(index) - (Math.PI / 2);
                    return {
                        x: Math.cos(thisAngle) * distanceFromCenter + me.xCenter,
                        y: Math.sin(thisAngle) * distanceFromCenter + me.yCenter
                    };
                },

                getPointPositionForValue: function(index, value) {
                    return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
                },

                getBasePosition: function(index) {
                    var me = this;
                    var min = me.min;
                    var max = me.max;

                    return me.getPointPositionForValue(index || 0,
                        me.beginAtZero ? 0 :
                            min < 0 && max < 0 ? max :
                                min > 0 && max > 0 ? min :
                                    0);
                },

                /**
                 * @private
                 */
                _drawGrid: function() {
                    var me = this;
                    var ctx = me.ctx;
                    var opts = me.options;
                    var gridLineOpts = opts.gridLines;
                    var angleLineOpts = opts.angleLines;
                    var lineWidth = valueOrDefault$c(angleLineOpts.lineWidth, gridLineOpts.lineWidth);
                    var lineColor = valueOrDefault$c(angleLineOpts.color, gridLineOpts.color);
                    var i, offset, position;

                    if (opts.pointLabels.display) {
                        drawPointLabels(me);
                    }

                    if (gridLineOpts.display) {
                        helpers$1.each(me.ticks, function(label, index) {
                            if (index !== 0) {
                                offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);
                                drawRadiusLine(me, gridLineOpts, offset, index);
                            }
                        });
                    }

                    if (angleLineOpts.display && lineWidth && lineColor) {
                        ctx.save();
                        ctx.lineWidth = lineWidth;
                        ctx.strokeStyle = lineColor;
                        if (ctx.setLineDash) {
                            ctx.setLineDash(resolve$4([angleLineOpts.borderDash, gridLineOpts.borderDash, []]));
                            ctx.lineDashOffset = resolve$4([angleLineOpts.borderDashOffset, gridLineOpts.borderDashOffset, 0.0]);
                        }

                        for (i = me.chart.data.labels.length - 1; i >= 0; i--) {
                            offset = me.getDistanceFromCenterForValue(opts.ticks.reverse ? me.min : me.max);
                            position = me.getPointPosition(i, offset);
                            ctx.beginPath();
                            ctx.moveTo(me.xCenter, me.yCenter);
                            ctx.lineTo(position.x, position.y);
                            ctx.stroke();
                        }

                        ctx.restore();
                    }
                },

                /**
                 * @private
                 */
                _drawLabels: function() {
                    var me = this;
                    var ctx = me.ctx;
                    var opts = me.options;
                    var tickOpts = opts.ticks;

                    if (!tickOpts.display) {
                        return;
                    }

                    var startAngle = me.getIndexAngle(0);
                    var tickFont = helpers$1.options._parseFont(tickOpts);
                    var tickFontColor = valueOrDefault$c(tickOpts.fontColor, core_defaults.global.defaultFontColor);
                    var offset, width;

                    ctx.save();
                    ctx.font = tickFont.string;
                    ctx.translate(me.xCenter, me.yCenter);
                    ctx.rotate(startAngle);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    helpers$1.each(me.ticks, function(label, index) {
                        if (index === 0 && !tickOpts.reverse) {
                            return;
                        }

                        offset = me.getDistanceFromCenterForValue(me.ticksAsNumbers[index]);

                        if (tickOpts.showLabelBackdrop) {
                            width = ctx.measureText(label).width;
                            ctx.fillStyle = tickOpts.backdropColor;

                            ctx.fillRect(
                                -width / 2 - tickOpts.backdropPaddingX,
                                -offset - tickFont.size / 2 - tickOpts.backdropPaddingY,
                                width + tickOpts.backdropPaddingX * 2,
                                tickFont.size + tickOpts.backdropPaddingY * 2
                            );
                        }

                        ctx.fillStyle = tickFontColor;
                        ctx.fillText(label, 0, -offset);
                    });

                    ctx.restore();
                },

                /**
                 * @private
                 */
                _drawTitle: helpers$1.noop
            });

            // INTERNAL: static default options, registered in src/index.js
            var _defaults$3 = defaultConfig$3;
            scale_radialLinear._defaults = _defaults$3;

            var deprecated$1 = helpers$1._deprecated;
            var resolve$5 = helpers$1.options.resolve;
            var valueOrDefault$d = helpers$1.valueOrDefault;

            // Integer constants are from the ES6 spec.
            var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
            var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;

            var INTERVALS = {
                millisecond: {
                    common: true,
                    size: 1,
                    steps: 1000
                },
                second: {
                    common: true,
                    size: 1000,
                    steps: 60
                },
                minute: {
                    common: true,
                    size: 60000,
                    steps: 60
                },
                hour: {
                    common: true,
                    size: 3600000,
                    steps: 24
                },
                day: {
                    common: true,
                    size: 86400000,
                    steps: 30
                },
                week: {
                    common: false,
                    size: 604800000,
                    steps: 4
                },
                month: {
                    common: true,
                    size: 2.628e9,
                    steps: 12
                },
                quarter: {
                    common: false,
                    size: 7.884e9,
                    steps: 4
                },
                year: {
                    common: true,
                    size: 3.154e10
                }
            };

            var UNITS = Object.keys(INTERVALS);

            function sorter(a, b) {
                return a - b;
            }

            function arrayUnique(items) {
                var hash = {};
                var out = [];
                var i, ilen, item;

                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    item = items[i];
                    if (!hash[item]) {
                        hash[item] = true;
                        out.push(item);
                    }
                }

                return out;
            }

            function getMin(options) {
                return helpers$1.valueOrDefault(options.time.min, options.ticks.min);
            }

            function getMax(options) {
                return helpers$1.valueOrDefault(options.time.max, options.ticks.max);
            }

            /**
             * Returns an array of {time, pos} objects used to interpolate a specific `time` or position
             * (`pos`) on the scale, by searching entries before and after the requested value. `pos` is
             * a decimal between 0 and 1: 0 being the start of the scale (left or top) and 1 the other
             * extremity (left + width or top + height). Note that it would be more optimized to directly
             * store pre-computed pixels, but the scale dimensions are not guaranteed at the time we need
             * to create the lookup table. The table ALWAYS contains at least two items: min and max.
             *
             * @param {number[]} timestamps - timestamps sorted from lowest to highest.
             * @param {string} distribution - If 'linear', timestamps will be spread linearly along the min
             * and max range, so basically, the table will contains only two items: {min, 0} and {max, 1}.
             * If 'series', timestamps will be positioned at the same distance from each other. In this
             * case, only timestamps that break the time linearity are registered, meaning that in the
             * best case, all timestamps are linear, the table contains only min and max.
             */
            function buildLookupTable(timestamps, min, max, distribution) {
                if (distribution === 'linear' || !timestamps.length) {
                    return [
                        {time: min, pos: 0},
                        {time: max, pos: 1}
                    ];
                }

                var table = [];
                var items = [min];
                var i, ilen, prev, curr, next;

                for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                    curr = timestamps[i];
                    if (curr > min && curr < max) {
                        items.push(curr);
                    }
                }

                items.push(max);

                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    next = items[i + 1];
                    prev = items[i - 1];
                    curr = items[i];

                    // only add points that breaks the scale linearity
                    if (prev === undefined || next === undefined || Math.round((next + prev) / 2) !== curr) {
                        table.push({time: curr, pos: i / (ilen - 1)});
                    }
                }

                return table;
            }

            // @see adapted from https://www.anujgakhar.com/2014/03/01/binary-search-in-javascript/
            function lookup(table, key, value) {
                var lo = 0;
                var hi = table.length - 1;
                var mid, i0, i1;

                while (lo >= 0 && lo <= hi) {
                    mid = (lo + hi) >> 1;
                    i0 = table[mid - 1] || null;
                    i1 = table[mid];

                    if (!i0) {
                        // given value is outside table (before first item)
                        return {lo: null, hi: i1};
                    } else if (i1[key] < value) {
                        lo = mid + 1;
                    } else if (i0[key] > value) {
                        hi = mid - 1;
                    } else {
                        return {lo: i0, hi: i1};
                    }
                }

                // given value is outside table (after last item)
                return {lo: i1, hi: null};
            }

            /**
             * Linearly interpolates the given source `value` using the table items `skey` values and
             * returns the associated `tkey` value. For example, interpolate(table, 'time', 42, 'pos')
             * returns the position for a timestamp equal to 42. If value is out of bounds, values at
             * index [0, 1] or [n - 1, n] are used for the interpolation.
             */
            function interpolate$1(table, skey, sval, tkey) {
                var range = lookup(table, skey, sval);

                // Note: the lookup table ALWAYS contains at least 2 items (min and max)
                var prev = !range.lo ? table[0] : !range.hi ? table[table.length - 2] : range.lo;
                var next = !range.lo ? table[1] : !range.hi ? table[table.length - 1] : range.hi;

                var span = next[skey] - prev[skey];
                var ratio = span ? (sval - prev[skey]) / span : 0;
                var offset = (next[tkey] - prev[tkey]) * ratio;

                return prev[tkey] + offset;
            }

            function toTimestamp(scale, input) {
                var adapter = scale._adapter;
                var options = scale.options.time;
                var parser = options.parser;
                var format = parser || options.format;
                var value = input;

                if (typeof parser === 'function') {
                    value = parser(value);
                }

                // Only parse if its not a timestamp already
                if (!helpers$1.isFinite(value)) {
                    value = typeof format === 'string'
                        ? adapter.parse(value, format)
                        : adapter.parse(value);
                }

                if (value !== null) {
                    return +value;
                }

                // Labels are in an incompatible format and no `parser` has been provided.
                // The user might still use the deprecated `format` option for parsing.
                if (!parser && typeof format === 'function') {
                    value = format(input);

                    // `format` could return something else than a timestamp, if so, parse it
                    if (!helpers$1.isFinite(value)) {
                        value = adapter.parse(value);
                    }
                }

                return value;
            }

            function parse(scale, input) {
                if (helpers$1.isNullOrUndef(input)) {
                    return null;
                }

                var options = scale.options.time;
                var value = toTimestamp(scale, scale.getRightValue(input));
                if (value === null) {
                    return value;
                }

                if (options.round) {
                    value = +scale._adapter.startOf(value, options.round);
                }

                return value;
            }

            /**
             * Figures out what unit results in an appropriate number of auto-generated ticks
             */
            function determineUnitForAutoTicks(minUnit, min, max, capacity) {
                var ilen = UNITS.length;
                var i, interval, factor;

                for (i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
                    interval = INTERVALS[UNITS[i]];
                    factor = interval.steps ? interval.steps : MAX_INTEGER;

                    if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) {
                        return UNITS[i];
                    }
                }

                return UNITS[ilen - 1];
            }

            /**
             * Figures out what unit to format a set of ticks with
             */
            function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
                var i, unit;

                for (i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
                    unit = UNITS[i];
                    if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) {
                        return unit;
                    }
                }

                return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
            }

            function determineMajorUnit(unit) {
                for (var i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) {
                    if (INTERVALS[UNITS[i]].common) {
                        return UNITS[i];
                    }
                }
            }

            /**
             * Generates a maximum of `capacity` timestamps between min and max, rounded to the
             * `minor` unit using the given scale time `options`.
             * Important: this method can return ticks outside the min and max range, it's the
             * responsibility of the calling code to clamp values if needed.
             */
            function generate(scale, min, max, capacity) {
                var adapter = scale._adapter;
                var options = scale.options;
                var timeOpts = options.time;
                var minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, capacity);
                var stepSize = resolve$5([timeOpts.stepSize, timeOpts.unitStepSize, 1]);
                var weekday = minor === 'week' ? timeOpts.isoWeekday : false;
                var first = min;
                var ticks = [];
                var time;

                // For 'week' unit, handle the first day of week option
                if (weekday) {
                    first = +adapter.startOf(first, 'isoWeek', weekday);
                }

                // Align first ticks on unit
                first = +adapter.startOf(first, weekday ? 'day' : minor);

                // Prevent browser from freezing in case user options request millions of milliseconds
                if (adapter.diff(max, min, minor) > 100000 * stepSize) {
                    throw min + ' and ' + max + ' are too far apart with stepSize of ' + stepSize + ' ' + minor;
                }

                for (time = first; time < max; time = +adapter.add(time, stepSize, minor)) {
                    ticks.push(time);
                }

                if (time === max || options.bounds === 'ticks') {
                    ticks.push(time);
                }

                return ticks;
            }

            /**
             * Returns the start and end offsets from edges in the form of {start, end}
             * where each value is a relative width to the scale and ranges between 0 and 1.
             * They add extra margins on the both sides by scaling down the original scale.
             * Offsets are added when the `offset` option is true.
             */
            function computeOffsets(table, ticks, min, max, options) {
                var start = 0;
                var end = 0;
                var first, last;

                if (options.offset && ticks.length) {
                    first = interpolate$1(table, 'time', ticks[0], 'pos');
                    if (ticks.length === 1) {
                        start = 1 - first;
                    } else {
                        start = (interpolate$1(table, 'time', ticks[1], 'pos') - first) / 2;
                    }
                    last = interpolate$1(table, 'time', ticks[ticks.length - 1], 'pos');
                    if (ticks.length === 1) {
                        end = last;
                    } else {
                        end = (last - interpolate$1(table, 'time', ticks[ticks.length - 2], 'pos')) / 2;
                    }
                }

                return {start: start, end: end, factor: 1 / (start + 1 + end)};
            }

            function setMajorTicks(scale, ticks, map, majorUnit) {
                var adapter = scale._adapter;
                var first = +adapter.startOf(ticks[0].value, majorUnit);
                var last = ticks[ticks.length - 1].value;
                var major, index;

                for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
                    index = map[major];
                    if (index >= 0) {
                        ticks[index].major = true;
                    }
                }
                return ticks;
            }

            function ticksFromTimestamps(scale, values, majorUnit) {
                var ticks = [];
                var map = {};
                var ilen = values.length;
                var i, value;

                for (i = 0; i < ilen; ++i) {
                    value = values[i];
                    map[value] = i;

                    ticks.push({
                        value: value,
                        major: false
                    });
                }

                // We set the major ticks separately from the above loop because calling startOf for every tick
                // is expensive when there is a large number of ticks
                return (ilen === 0 || !majorUnit) ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
            }

            var defaultConfig$4 = {
                position: 'bottom',

                /**
                 * Data distribution along the scale:
                 * - 'linear': data are spread according to their time (distances can vary),
                 * - 'series': data are spread at the same distance from each other.
                 * @see https://github.com/chartjs/Chart.js/pull/4507
                 * @since 2.7.0
                 */
                distribution: 'linear',

                /**
                 * Scale boundary strategy (bypassed by min/max time options)
                 * - `data`: make sure data are fully visible, ticks outside are removed
                 * - `ticks`: make sure ticks are fully visible, data outside are truncated
                 * @see https://github.com/chartjs/Chart.js/pull/4556
                 * @since 2.7.0
                 */
                bounds: 'data',

                adapters: {},
                time: {
                    parser: false, // false == a pattern string from https://momentjs.com/docs/#/parsing/string-format/ or a custom callback that converts its argument to a moment
                    unit: false, // false == automatic or override with week, month, year, etc.
                    round: false, // none, or override with week, month, year, etc.
                    displayFormat: false, // DEPRECATED
                    isoWeekday: false, // override week start day - see https://momentjs.com/docs/#/get-set/iso-weekday/
                    minUnit: 'millisecond',
                    displayFormats: {}
                },
                ticks: {
                    autoSkip: false,

                    /**
                     * Ticks generation input values:
                     * - 'auto': generates "optimal" ticks based on scale size and time options.
                     * - 'data': generates ticks from data (including labels from data {t|x|y} objects).
                     * - 'labels': generates ticks from user given `data.labels` values ONLY.
                     * @see https://github.com/chartjs/Chart.js/pull/4507
                     * @since 2.7.0
                     */
                    source: 'auto',

                    major: {
                        enabled: false
                    }
                }
            };

            var scale_time = core_scale.extend({
                initialize: function() {
                    this.mergeTicksOptions();
                    core_scale.prototype.initialize.call(this);
                },

                update: function() {
                    var me = this;
                    var options = me.options;
                    var time = options.time || (options.time = {});
                    var adapter = me._adapter = new core_adapters._date(options.adapters.date);

                    // DEPRECATIONS: output a message only one time per update
                    deprecated$1('time scale', time.format, 'time.format', 'time.parser');
                    deprecated$1('time scale', time.min, 'time.min', 'ticks.min');
                    deprecated$1('time scale', time.max, 'time.max', 'ticks.max');

                    // Backward compatibility: before introducing adapter, `displayFormats` was
                    // supposed to contain *all* unit/string pairs but this can't be resolved
                    // when loading the scale (adapters are loaded afterward), so let's populate
                    // missing formats on update
                    helpers$1.mergeIf(time.displayFormats, adapter.formats());

                    return core_scale.prototype.update.apply(me, arguments);
                },

                /**
                 * Allows data to be referenced via 't' attribute
                 */
                getRightValue: function(rawValue) {
                    if (rawValue && rawValue.t !== undefined) {
                        rawValue = rawValue.t;
                    }
                    return core_scale.prototype.getRightValue.call(this, rawValue);
                },

                determineDataLimits: function() {
                    var me = this;
                    var chart = me.chart;
                    var adapter = me._adapter;
                    var options = me.options;
                    var unit = options.time.unit || 'day';
                    var min = MAX_INTEGER;
                    var max = MIN_INTEGER;
                    var timestamps = [];
                    var datasets = [];
                    var labels = [];
                    var i, j, ilen, jlen, data, timestamp, labelsAdded;
                    var dataLabels = me._getLabels();

                    for (i = 0, ilen = dataLabels.length; i < ilen; ++i) {
                        labels.push(parse(me, dataLabels[i]));
                    }

                    for (i = 0, ilen = (chart.data.datasets || []).length; i < ilen; ++i) {
                        if (chart.isDatasetVisible(i)) {
                            data = chart.data.datasets[i].data;

                            // Let's consider that all data have the same format.
                            if (helpers$1.isObject(data[0])) {
                                datasets[i] = [];

                                for (j = 0, jlen = data.length; j < jlen; ++j) {
                                    timestamp = parse(me, data[j]);
                                    timestamps.push(timestamp);
                                    datasets[i][j] = timestamp;
                                }
                            } else {
                                datasets[i] = labels.slice(0);
                                if (!labelsAdded) {
                                    timestamps = timestamps.concat(labels);
                                    labelsAdded = true;
                                }
                            }
                        } else {
                            datasets[i] = [];
                        }
                    }

                    if (labels.length) {
                        min = Math.min(min, labels[0]);
                        max = Math.max(max, labels[labels.length - 1]);
                    }

                    if (timestamps.length) {
                        timestamps = ilen > 1 ? arrayUnique(timestamps).sort(sorter) : timestamps.sort(sorter);
                        min = Math.min(min, timestamps[0]);
                        max = Math.max(max, timestamps[timestamps.length - 1]);
                    }

                    min = parse(me, getMin(options)) || min;
                    max = parse(me, getMax(options)) || max;

                    // In case there is no valid min/max, set limits based on unit time option
                    min = min === MAX_INTEGER ? +adapter.startOf(Date.now(), unit) : min;
                    max = max === MIN_INTEGER ? +adapter.endOf(Date.now(), unit) + 1 : max;

                    // Make sure that max is strictly higher than min (required by the lookup table)
                    me.min = Math.min(min, max);
                    me.max = Math.max(min + 1, max);

                    // PRIVATE
                    me._table = [];
                    me._timestamps = {
                        data: timestamps,
                        datasets: datasets,
                        labels: labels
                    };
                },

                buildTicks: function() {
                    var me = this;
                    var min = me.min;
                    var max = me.max;
                    var options = me.options;
                    var tickOpts = options.ticks;
                    var timeOpts = options.time;
                    var timestamps = me._timestamps;
                    var ticks = [];
                    var capacity = me.getLabelCapacity(min);
                    var source = tickOpts.source;
                    var distribution = options.distribution;
                    var i, ilen, timestamp;

                    if (source === 'data' || (source === 'auto' && distribution === 'series')) {
                        timestamps = timestamps.data;
                    } else if (source === 'labels') {
                        timestamps = timestamps.labels;
                    } else {
                        timestamps = generate(me, min, max, capacity);
                    }

                    if (options.bounds === 'ticks' && timestamps.length) {
                        min = timestamps[0];
                        max = timestamps[timestamps.length - 1];
                    }

                    // Enforce limits with user min/max options
                    min = parse(me, getMin(options)) || min;
                    max = parse(me, getMax(options)) || max;

                    // Remove ticks outside the min/max range
                    for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                        timestamp = timestamps[i];
                        if (timestamp >= min && timestamp <= max) {
                            ticks.push(timestamp);
                        }
                    }

                    me.min = min;
                    me.max = max;

                    // PRIVATE
                    // determineUnitForFormatting relies on the number of ticks so we don't use it when
                    // autoSkip is enabled because we don't yet know what the final number of ticks will be
                    me._unit = timeOpts.unit || (tickOpts.autoSkip
                        ? determineUnitForAutoTicks(timeOpts.minUnit, me.min, me.max, capacity)
                        : determineUnitForFormatting(me, ticks.length, timeOpts.minUnit, me.min, me.max));
                    me._majorUnit = !tickOpts.major.enabled || me._unit === 'year' ? undefined
                        : determineMajorUnit(me._unit);
                    me._table = buildLookupTable(me._timestamps.data, min, max, distribution);
                    me._offsets = computeOffsets(me._table, ticks, min, max, options);

                    if (tickOpts.reverse) {
                        ticks.reverse();
                    }

                    return ticksFromTimestamps(me, ticks, me._majorUnit);
                },

                getLabelForIndex: function(index, datasetIndex) {
                    var me = this;
                    var adapter = me._adapter;
                    var data = me.chart.data;
                    var timeOpts = me.options.time;
                    var label = data.labels && index < data.labels.length ? data.labels[index] : '';
                    var value = data.datasets[datasetIndex].data[index];

                    if (helpers$1.isObject(value)) {
                        label = me.getRightValue(value);
                    }
                    if (timeOpts.tooltipFormat) {
                        return adapter.format(toTimestamp(me, label), timeOpts.tooltipFormat);
                    }
                    if (typeof label === 'string') {
                        return label;
                    }
                    return adapter.format(toTimestamp(me, label), timeOpts.displayFormats.datetime);
                },

                /**
                 * Function to format an individual tick mark
                 * @private
                 */
                tickFormatFunction: function(time, index, ticks, format) {
                    var me = this;
                    var adapter = me._adapter;
                    var options = me.options;
                    var formats = options.time.displayFormats;
                    var minorFormat = formats[me._unit];
                    var majorUnit = me._majorUnit;
                    var majorFormat = formats[majorUnit];
                    var tick = ticks[index];
                    var tickOpts = options.ticks;
                    var major = majorUnit && majorFormat && tick && tick.major;
                    var label = adapter.format(time, format ? format : major ? majorFormat : minorFormat);
                    var nestedTickOpts = major ? tickOpts.major : tickOpts.minor;
                    var formatter = resolve$5([
                        nestedTickOpts.callback,
                        nestedTickOpts.userCallback,
                        tickOpts.callback,
                        tickOpts.userCallback
                    ]);

                    return formatter ? formatter(label, index, ticks) : label;
                },

                convertTicksToLabels: function(ticks) {
                    var labels = [];
                    var i, ilen;

                    for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                        labels.push(this.tickFormatFunction(ticks[i].value, i, ticks));
                    }

                    return labels;
                },

                /**
                 * @private
                 */
                getPixelForOffset: function(time) {
                    var me = this;
                    var offsets = me._offsets;
                    var pos = interpolate$1(me._table, 'time', time, 'pos');
                    return me.getPixelForDecimal((offsets.start + pos) * offsets.factor);
                },

                getPixelForValue: function(value, index, datasetIndex) {
                    var me = this;
                    var time = null;

                    if (index !== undefined && datasetIndex !== undefined) {
                        time = me._timestamps.datasets[datasetIndex][index];
                    }

                    if (time === null) {
                        time = parse(me, value);
                    }

                    if (time !== null) {
                        return me.getPixelForOffset(time);
                    }
                },

                getPixelForTick: function(index) {
                    var ticks = this.getTicks();
                    return index >= 0 && index < ticks.length ?
                        this.getPixelForOffset(ticks[index].value) :
                        null;
                },

                getValueForPixel: function(pixel) {
                    var me = this;
                    var offsets = me._offsets;
                    var pos = me.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                    var time = interpolate$1(me._table, 'pos', pos, 'time');

                    // DEPRECATION, we should return time directly
                    return me._adapter._create(time);
                },

                /**
                 * @private
                 */
                _getLabelSize: function(label) {
                    var me = this;
                    var ticksOpts = me.options.ticks;
                    var tickLabelWidth = me.ctx.measureText(label).width;
                    var angle = helpers$1.toRadians(me.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
                    var cosRotation = Math.cos(angle);
                    var sinRotation = Math.sin(angle);
                    var tickFontSize = valueOrDefault$d(ticksOpts.fontSize, core_defaults.global.defaultFontSize);

                    return {
                        w: (tickLabelWidth * cosRotation) + (tickFontSize * sinRotation),
                        h: (tickLabelWidth * sinRotation) + (tickFontSize * cosRotation)
                    };
                },

                /**
                 * Crude approximation of what the label width might be
                 * @private
                 */
                getLabelWidth: function(label) {
                    return this._getLabelSize(label).w;
                },

                /**
                 * @private
                 */
                getLabelCapacity: function(exampleTime) {
                    var me = this;
                    var timeOpts = me.options.time;
                    var displayFormats = timeOpts.displayFormats;

                    // pick the longest format (milliseconds) for guestimation
                    var format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
                    var exampleLabel = me.tickFormatFunction(exampleTime, 0, ticksFromTimestamps(me, [exampleTime], me._majorUnit), format);
                    var size = me._getLabelSize(exampleLabel);
                    var capacity = Math.floor(me.isHorizontal() ? me.width / size.w : me.height / size.h);

                    if (me.options.offset) {
                        capacity--;
                    }

                    return capacity > 0 ? capacity : 1;
                }
            });

            // INTERNAL: static default options, registered in src/index.js
            var _defaults$4 = defaultConfig$4;
            scale_time._defaults = _defaults$4;

            var scales = {
                category: scale_category,
                linear: scale_linear,
                logarithmic: scale_logarithmic,
                radialLinear: scale_radialLinear,
                time: scale_time
            };

            var FORMATS = {
                datetime: 'MMM D, YYYY, h:mm:ss a',
                millisecond: 'h:mm:ss.SSS a',
                second: 'h:mm:ss a',
                minute: 'h:mm a',
                hour: 'hA',
                day: 'MMM D',
                week: 'll',
                month: 'MMM YYYY',
                quarter: '[Q]Q - YYYY',
                year: 'YYYY'
            };

            core_adapters._date.override(typeof moment === 'function' ? {
                _id: 'moment', // DEBUG ONLY

                formats: function() {
                    return FORMATS;
                },

                parse: function(value, format) {
                    if (typeof value === 'string' && typeof format === 'string') {
                        value = moment(value, format);
                    } else if (!(value instanceof moment)) {
                        value = moment(value);
                    }
                    return value.isValid() ? value.valueOf() : null;
                },

                format: function(time, format) {
                    return moment(time).format(format);
                },

                add: function(time, amount, unit) {
                    return moment(time).add(amount, unit).valueOf();
                },

                diff: function(max, min, unit) {
                    return moment(max).diff(moment(min), unit);
                },

                startOf: function(time, unit, weekday) {
                    time = moment(time);
                    if (unit === 'isoWeek') {
                        return time.isoWeekday(weekday).valueOf();
                    }
                    return time.startOf(unit).valueOf();
                },

                endOf: function(time, unit) {
                    return moment(time).endOf(unit).valueOf();
                },

                // DEPRECATIONS

                /**
                 * Provided for backward compatibility with scale.getValueForPixel().
                 * @deprecated since version 2.8.0
                 * @todo remove at version 3
                 * @private
                 */
                _create: function(time) {
                    return moment(time);
                },
            } : {});

            core_defaults._set('global', {
                plugins: {
                    filler: {
                        propagate: true
                    }
                }
            });

            var mappers = {
                dataset: function(source) {
                    var index = source.fill;
                    var chart = source.chart;
                    var meta = chart.getDatasetMeta(index);
                    var visible = meta && chart.isDatasetVisible(index);
                    var points = (visible && meta.dataset._children) || [];
                    var length = points.length || 0;

                    return !length ? null : function(point, i) {
                        return (i < length && points[i]._view) || null;
                    };
                },

                boundary: function(source) {
                    var boundary = source.boundary;
                    var x = boundary ? boundary.x : null;
                    var y = boundary ? boundary.y : null;

                    if (helpers$1.isArray(boundary)) {
                        return function(point, i) {
                            return boundary[i];
                        };
                    }

                    return function(point) {
                        return {
                            x: x === null ? point.x : x,
                            y: y === null ? point.y : y,
                        };
                    };
                }
            };

            // @todo if (fill[0] === '#')
            function decodeFill(el, index, count) {
                var model = el._model || {};
                var fill = model.fill;
                var target;

                if (fill === undefined) {
                    fill = !!model.backgroundColor;
                }

                if (fill === false || fill === null) {
                    return false;
                }

                if (fill === true) {
                    return 'origin';
                }

                target = parseFloat(fill, 10);
                if (isFinite(target) && Math.floor(target) === target) {
                    if (fill[0] === '-' || fill[0] === '+') {
                        target = index + target;
                    }

                    if (target === index || target < 0 || target >= count) {
                        return false;
                    }

                    return target;
                }

                switch (fill) {
                    // compatibility
                    case 'bottom':
                        return 'start';
                    case 'top':
                        return 'end';
                    case 'zero':
                        return 'origin';
                    // supported boundaries
                    case 'origin':
                    case 'start':
                    case 'end':
                        return fill;
                    // invalid fill values
                    default:
                        return false;
                }
            }

            function computeLinearBoundary(source) {
                var model = source.el._model || {};
                var scale = source.el._scale || {};
                var fill = source.fill;
                var target = null;
                var horizontal;

                if (isFinite(fill)) {
                    return null;
                }

                // Backward compatibility: until v3, we still need to support boundary values set on
                // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and
                // controllers might still use it (e.g. the Smith chart).

                if (fill === 'start') {
                    target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;
                } else if (fill === 'end') {
                    target = model.scaleTop === undefined ? scale.top : model.scaleTop;
                } else if (model.scaleZero !== undefined) {
                    target = model.scaleZero;
                } else if (scale.getBasePixel) {
                    target = scale.getBasePixel();
                }

                if (target !== undefined && target !== null) {
                    if (target.x !== undefined && target.y !== undefined) {
                        return target;
                    }

                    if (helpers$1.isFinite(target)) {
                        horizontal = scale.isHorizontal();
                        return {
                            x: horizontal ? target : null,
                            y: horizontal ? null : target
                        };
                    }
                }

                return null;
            }

            function computeCircularBoundary(source) {
                var scale = source.el._scale;
                var options = scale.options;
                var length = scale.chart.data.labels.length;
                var fill = source.fill;
                var target = [];
                var start, end, center, i, point;

                if (!length) {
                    return null;
                }

                start = options.ticks.reverse ? scale.max : scale.min;
                end = options.ticks.reverse ? scale.min : scale.max;
                center = scale.getPointPositionForValue(0, start);
                for (i = 0; i < length; ++i) {
                    point = fill === 'start' || fill === 'end'
                        ? scale.getPointPositionForValue(i, fill === 'start' ? start : end)
                        : scale.getBasePosition(i);
                    if (options.gridLines.circular) {
                        point.cx = center.x;
                        point.cy = center.y;
                        point.angle = scale.getIndexAngle(i) - Math.PI / 2;
                    }
                    target.push(point);
                }
                return target;
            }

            function computeBoundary(source) {
                var scale = source.el._scale || {};

                if (scale.getPointPositionForValue) {
                    return computeCircularBoundary(source);
                }
                return computeLinearBoundary(source);
            }

            function resolveTarget(sources, index, propagate) {
                var source = sources[index];
                var fill = source.fill;
                var visited = [index];
                var target;

                if (!propagate) {
                    return fill;
                }

                while (fill !== false && visited.indexOf(fill) === -1) {
                    if (!isFinite(fill)) {
                        return fill;
                    }

                    target = sources[fill];
                    if (!target) {
                        return false;
                    }

                    if (target.visible) {
                        return fill;
                    }

                    visited.push(fill);
                    fill = target.fill;
                }

                return false;
            }

            function createMapper(source) {
                var fill = source.fill;
                var type = 'dataset';

                if (fill === false) {
                    return null;
                }

                if (!isFinite(fill)) {
                    type = 'boundary';
                }

                return mappers[type](source);
            }

            function isDrawable(point) {
                return point && !point.skip;
            }

            function drawArea(ctx, curve0, curve1, len0, len1) {
                var i, cx, cy, r;

                if (!len0 || !len1) {
                    return;
                }

                // building first area curve (normal)
                ctx.moveTo(curve0[0].x, curve0[0].y);
                for (i = 1; i < len0; ++i) {
                    helpers$1.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);
                }

                if (curve1[0].angle !== undefined) {
                    cx = curve1[0].cx;
                    cy = curve1[0].cy;
                    r = Math.sqrt(Math.pow(curve1[0].x - cx, 2) + Math.pow(curve1[0].y - cy, 2));
                    for (i = len1 - 1; i > 0; --i) {
                        ctx.arc(cx, cy, r, curve1[i].angle, curve1[i - 1].angle, true);
                    }
                    return;
                }

                // joining the two area curves
                ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);

                // building opposite area curve (reverse)
                for (i = len1 - 1; i > 0; --i) {
                    helpers$1.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);
                }
            }

            function doFill(ctx, points, mapper, view, color, loop) {
                var count = points.length;
                var span = view.spanGaps;
                var curve0 = [];
                var curve1 = [];
                var len0 = 0;
                var len1 = 0;
                var i, ilen, index, p0, p1, d0, d1, loopOffset;

                ctx.beginPath();

                for (i = 0, ilen = count; i < ilen; ++i) {
                    index = i % count;
                    p0 = points[index]._view;
                    p1 = mapper(p0, index, view);
                    d0 = isDrawable(p0);
                    d1 = isDrawable(p1);

                    if (loop && loopOffset === undefined && d0) {
                        loopOffset = i + 1;
                        ilen = count + loopOffset;
                    }

                    if (d0 && d1) {
                        len0 = curve0.push(p0);
                        len1 = curve1.push(p1);
                    } else if (len0 && len1) {
                        if (!span) {
                            drawArea(ctx, curve0, curve1, len0, len1);
                            len0 = len1 = 0;
                            curve0 = [];
                            curve1 = [];
                        } else {
                            if (d0) {
                                curve0.push(p0);
                            }
                            if (d1) {
                                curve1.push(p1);
                            }
                        }
                    }
                }

                drawArea(ctx, curve0, curve1, len0, len1);

                ctx.closePath();
                ctx.fillStyle = color;
                ctx.fill();
            }

            var plugin_filler = {
                id: 'filler',

                afterDatasetsUpdate: function(chart, options) {
                    var count = (chart.data.datasets || []).length;
                    var propagate = options.propagate;
                    var sources = [];
                    var meta, i, el, source;

                    for (i = 0; i < count; ++i) {
                        meta = chart.getDatasetMeta(i);
                        el = meta.dataset;
                        source = null;

                        if (el && el._model && el instanceof elements.Line) {
                            source = {
                                visible: chart.isDatasetVisible(i),
                                fill: decodeFill(el, i, count),
                                chart: chart,
                                el: el
                            };
                        }

                        meta.$filler = source;
                        sources.push(source);
                    }

                    for (i = 0; i < count; ++i) {
                        source = sources[i];
                        if (!source) {
                            continue;
                        }

                        source.fill = resolveTarget(sources, i, propagate);
                        source.boundary = computeBoundary(source);
                        source.mapper = createMapper(source);
                    }
                },

                beforeDatasetsDraw: function(chart) {
                    var metasets = chart._getSortedVisibleDatasetMetas();
                    var ctx = chart.ctx;
                    var meta, i, el, view, points, mapper, color;

                    for (i = metasets.length - 1; i >= 0; --i) {
                        meta = metasets[i].$filler;

                        if (!meta || !meta.visible) {
                            continue;
                        }

                        el = meta.el;
                        view = el._view;
                        points = el._children || [];
                        mapper = meta.mapper;
                        color = view.backgroundColor || core_defaults.global.defaultColor;

                        if (mapper && color && points.length) {
                            helpers$1.canvas.clipArea(ctx, chart.chartArea);
                            doFill(ctx, points, mapper, view, color, el._loop);
                            helpers$1.canvas.unclipArea(ctx);
                        }
                    }
                }
            };

            var getRtlHelper$1 = helpers$1.rtl.getRtlAdapter;
            var noop$1 = helpers$1.noop;
            var valueOrDefault$e = helpers$1.valueOrDefault;

            core_defaults._set('global', {
                legend: {
                    display: true,
                    position: 'top',
                    align: 'center',
                    fullWidth: true,
                    reverse: false,
                    weight: 1000,

                    // a callback that will handle
                    onClick: function(e, legendItem) {
                        var index = legendItem.datasetIndex;
                        var ci = this.chart;
                        var meta = ci.getDatasetMeta(index);

                        // See controller.isDatasetVisible comment
                        meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;

                        // We hid a dataset ... rerender the chart
                        ci.update();
                    },

                    onHover: null,
                    onLeave: null,

                    labels: {
                        boxWidth: 40,
                        padding: 10,
                        // Generates labels shown in the legend
                        // Valid properties to return:
                        // text : text to display
                        // fillStyle : fill of coloured box
                        // strokeStyle: stroke of coloured box
                        // hidden : if this legend item refers to a hidden item
                        // lineCap : cap style for line
                        // lineDash
                        // lineDashOffset :
                        // lineJoin :
                        // lineWidth :
                        generateLabels: function(chart) {
                            var datasets = chart.data.datasets;
                            var options = chart.options.legend || {};
                            var usePointStyle = options.labels && options.labels.usePointStyle;

                            return chart._getSortedDatasetMetas().map(function(meta) {
                                var style = meta.controller.getStyle(usePointStyle ? 0 : undefined);

                                return {
                                    text: datasets[meta.index].label,
                                    fillStyle: style.backgroundColor,
                                    hidden: !chart.isDatasetVisible(meta.index),
                                    lineCap: style.borderCapStyle,
                                    lineDash: style.borderDash,
                                    lineDashOffset: style.borderDashOffset,
                                    lineJoin: style.borderJoinStyle,
                                    lineWidth: style.borderWidth,
                                    strokeStyle: style.borderColor,
                                    pointStyle: style.pointStyle,
                                    rotation: style.rotation,

                                    // Below is extra data used for toggling the datasets
                                    datasetIndex: meta.index
                                };
                            }, this);
                        }
                    }
                },

                legendCallback: function(chart) {
                    var list = document.createElement('ul');
                    var datasets = chart.data.datasets;
                    var i, ilen, listItem, listItemSpan;

                    list.setAttribute('class', chart.id + '-legend');

                    for (i = 0, ilen = datasets.length; i < ilen; i++) {
                        listItem = list.appendChild(document.createElement('li'));
                        listItemSpan = listItem.appendChild(document.createElement('span'));
                        listItemSpan.style.backgroundColor = datasets[i].backgroundColor;
                        if (datasets[i].label) {
                            listItem.appendChild(document.createTextNode(datasets[i].label));
                        }
                    }

                    return list.outerHTML;
                }
            });

            /**
             * Helper function to get the box width based on the usePointStyle option
             * @param {object} labelopts - the label options on the legend
             * @param {number} fontSize - the label font size
             * @return {number} width of the color box area
             */
            function getBoxWidth(labelOpts, fontSize) {
                return labelOpts.usePointStyle && labelOpts.boxWidth > fontSize ?
                    fontSize :
                    labelOpts.boxWidth;
            }

            /**
             * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
             */
            var Legend = core_element.extend({

                initialize: function(config) {
                    var me = this;
                    helpers$1.extend(me, config);

                    // Contains hit boxes for each dataset (in dataset order)
                    me.legendHitBoxes = [];

                    /**
                     * @private
                     */
                    me._hoveredItem = null;

                    // Are we in doughnut mode which has a different data type
                    me.doughnutMode = false;
                },

                // These methods are ordered by lifecycle. Utilities then follow.
                // Any function defined here is inherited by all legend types.
                // Any function can be extended by the legend type

                beforeUpdate: noop$1,
                update: function(maxWidth, maxHeight, margins) {
                    var me = this;

                    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
                    me.beforeUpdate();

                    // Absorb the master measurements
                    me.maxWidth = maxWidth;
                    me.maxHeight = maxHeight;
                    me.margins = margins;

                    // Dimensions
                    me.beforeSetDimensions();
                    me.setDimensions();
                    me.afterSetDimensions();
                    // Labels
                    me.beforeBuildLabels();
                    me.buildLabels();
                    me.afterBuildLabels();

                    // Fit
                    me.beforeFit();
                    me.fit();
                    me.afterFit();
                    //
                    me.afterUpdate();

                    return me.minSize;
                },
                afterUpdate: noop$1,

                //

                beforeSetDimensions: noop$1,
                setDimensions: function() {
                    var me = this;
                    // Set the unconstrained dimension before label rotation
                    if (me.isHorizontal()) {
                        // Reset position before calculating rotation
                        me.width = me.maxWidth;
                        me.left = 0;
                        me.right = me.width;
                    } else {
                        me.height = me.maxHeight;

                        // Reset position before calculating rotation
                        me.top = 0;
                        me.bottom = me.height;
                    }

                    // Reset padding
                    me.paddingLeft = 0;
                    me.paddingTop = 0;
                    me.paddingRight = 0;
                    me.paddingBottom = 0;

                    // Reset minSize
                    me.minSize = {
                        width: 0,
                        height: 0
                    };
                },
                afterSetDimensions: noop$1,

                //

                beforeBuildLabels: noop$1,
                buildLabels: function() {
                    var me = this;
                    var labelOpts = me.options.labels || {};
                    var legendItems = helpers$1.callback(labelOpts.generateLabels, [me.chart], me) || [];

                    if (labelOpts.filter) {
                        legendItems = legendItems.filter(function(item) {
                            return labelOpts.filter(item, me.chart.data);
                        });
                    }

                    if (me.options.reverse) {
                        legendItems.reverse();
                    }

                    me.legendItems = legendItems;
                },
                afterBuildLabels: noop$1,

                //

                beforeFit: noop$1,
                fit: function() {
                    var me = this;
                    var opts = me.options;
                    var labelOpts = opts.labels;
                    var display = opts.display;

                    var ctx = me.ctx;

                    var labelFont = helpers$1.options._parseFont(labelOpts);
                    var fontSize = labelFont.size;

                    // Reset hit boxes
                    var hitboxes = me.legendHitBoxes = [];

                    var minSize = me.minSize;
                    var isHorizontal = me.isHorizontal();

                    if (isHorizontal) {
                        minSize.width = me.maxWidth; // fill all the width
                        minSize.height = display ? 10 : 0;
                    } else {
                        minSize.width = display ? 10 : 0;
                        minSize.height = me.maxHeight; // fill all the height
                    }

                    // Increase sizes here
                    if (!display) {
                        me.width = minSize.width = me.height = minSize.height = 0;
                        return;
                    }
                    ctx.font = labelFont.string;

                    if (isHorizontal) {
                        // Labels

                        // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one
                        var lineWidths = me.lineWidths = [0];
                        var totalHeight = 0;

                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';

                        helpers$1.each(me.legendItems, function(legendItem, i) {
                            var boxWidth = getBoxWidth(labelOpts, fontSize);
                            var width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

                            if (i === 0 || lineWidths[lineWidths.length - 1] + width + 2 * labelOpts.padding > minSize.width) {
                                totalHeight += fontSize + labelOpts.padding;
                                lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                            }

                            // Store the hitbox width and height here. Final position will be updated in `draw`
                            hitboxes[i] = {
                                left: 0,
                                top: 0,
                                width: width,
                                height: fontSize
                            };

                            lineWidths[lineWidths.length - 1] += width + labelOpts.padding;
                        });

                        minSize.height += totalHeight;

                    } else {
                        var vPadding = labelOpts.padding;
                        var columnWidths = me.columnWidths = [];
                        var columnHeights = me.columnHeights = [];
                        var totalWidth = labelOpts.padding;
                        var currentColWidth = 0;
                        var currentColHeight = 0;

                        helpers$1.each(me.legendItems, function(legendItem, i) {
                            var boxWidth = getBoxWidth(labelOpts, fontSize);
                            var itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;

                            // If too tall, go to new column
                            if (i > 0 && currentColHeight + fontSize + 2 * vPadding > minSize.height) {
                                totalWidth += currentColWidth + labelOpts.padding;
                                columnWidths.push(currentColWidth); // previous column width
                                columnHeights.push(currentColHeight);
                                currentColWidth = 0;
                                currentColHeight = 0;
                            }

                            // Get max width
                            currentColWidth = Math.max(currentColWidth, itemWidth);
                            currentColHeight += fontSize + vPadding;

                            // Store the hitbox width and height here. Final position will be updated in `draw`
                            hitboxes[i] = {
                                left: 0,
                                top: 0,
                                width: itemWidth,
                                height: fontSize
                            };
                        });

                        totalWidth += currentColWidth;
                        columnWidths.push(currentColWidth);
                        columnHeights.push(currentColHeight);
                        minSize.width += totalWidth;
                    }

                    me.width = minSize.width;
                    me.height = minSize.height;
                },
                afterFit: noop$1,

                // Shared Methods
                isHorizontal: function() {
                    return this.options.position === 'top' || this.options.position === 'bottom';
                },

                // Actually draw the legend on the canvas
                draw: function() {
                    var me = this;
                    var opts = me.options;
                    var labelOpts = opts.labels;
                    var globalDefaults = core_defaults.global;
                    var defaultColor = globalDefaults.defaultColor;
                    var lineDefault = globalDefaults.elements.line;
                    var legendHeight = me.height;
                    var columnHeights = me.columnHeights;
                    var legendWidth = me.width;
                    var lineWidths = me.lineWidths;

                    if (!opts.display) {
                        return;
                    }

                    var rtlHelper = getRtlHelper$1(opts.rtl, me.left, me.minSize.width);
                    var ctx = me.ctx;
                    var fontColor = valueOrDefault$e(labelOpts.fontColor, globalDefaults.defaultFontColor);
                    var labelFont = helpers$1.options._parseFont(labelOpts);
                    var fontSize = labelFont.size;
                    var cursor;

                    // Canvas setup
                    ctx.textAlign = rtlHelper.textAlign('left');
                    ctx.textBaseline = 'middle';
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = fontColor; // for strikethrough effect
                    ctx.fillStyle = fontColor; // render in correct colour
                    ctx.font = labelFont.string;

                    var boxWidth = getBoxWidth(labelOpts, fontSize);
                    var hitboxes = me.legendHitBoxes;

                    // current position
                    var drawLegendBox = function(x, y, legendItem) {
                        if (isNaN(boxWidth) || boxWidth <= 0) {
                            return;
                        }

                        // Set the ctx for the box
                        ctx.save();

                        var lineWidth = valueOrDefault$e(legendItem.lineWidth, lineDefault.borderWidth);
                        ctx.fillStyle = valueOrDefault$e(legendItem.fillStyle, defaultColor);
                        ctx.lineCap = valueOrDefault$e(legendItem.lineCap, lineDefault.borderCapStyle);
                        ctx.lineDashOffset = valueOrDefault$e(legendItem.lineDashOffset, lineDefault.borderDashOffset);
                        ctx.lineJoin = valueOrDefault$e(legendItem.lineJoin, lineDefault.borderJoinStyle);
                        ctx.lineWidth = lineWidth;
                        ctx.strokeStyle = valueOrDefault$e(legendItem.strokeStyle, defaultColor);

                        if (ctx.setLineDash) {
                            // IE 9 and 10 do not support line dash
                            ctx.setLineDash(valueOrDefault$e(legendItem.lineDash, lineDefault.borderDash));
                        }

                        if (labelOpts && labelOpts.usePointStyle) {
                            // Recalculate x and y for drawPoint() because its expecting
                            // x and y to be center of figure (instead of top left)
                            var radius = boxWidth * Math.SQRT2 / 2;
                            var centerX = rtlHelper.xPlus(x, boxWidth / 2);
                            var centerY = y + fontSize / 2;

                            // Draw pointStyle as legend symbol
                            helpers$1.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY, legendItem.rotation);
                        } else {
                            // Draw box as legend symbol
                            ctx.fillRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                            if (lineWidth !== 0) {
                                ctx.strokeRect(rtlHelper.leftForLtr(x, boxWidth), y, boxWidth, fontSize);
                            }
                        }

                        ctx.restore();
                    };

                    var fillText = function(x, y, legendItem, textWidth) {
                        var halfFontSize = fontSize / 2;
                        var xLeft = rtlHelper.xPlus(x, boxWidth + halfFontSize);
                        var yMiddle = y + halfFontSize;

                        ctx.fillText(legendItem.text, xLeft, yMiddle);

                        if (legendItem.hidden) {
                            // Strikethrough the text if hidden
                            ctx.beginPath();
                            ctx.lineWidth = 2;
                            ctx.moveTo(xLeft, yMiddle);
                            ctx.lineTo(rtlHelper.xPlus(xLeft, textWidth), yMiddle);
                            ctx.stroke();
                        }
                    };

                    var alignmentOffset = function(dimension, blockSize) {
                        switch (opts.align) {
                            case 'start':
                                return labelOpts.padding;
                            case 'end':
                                return dimension - blockSize;
                            default: // center
                                return (dimension - blockSize + labelOpts.padding) / 2;
                        }
                    };

                    // Horizontal
                    var isHorizontal = me.isHorizontal();
                    if (isHorizontal) {
                        cursor = {
                            x: me.left + alignmentOffset(legendWidth, lineWidths[0]),
                            y: me.top + labelOpts.padding,
                            line: 0
                        };
                    } else {
                        cursor = {
                            x: me.left + labelOpts.padding,
                            y: me.top + alignmentOffset(legendHeight, columnHeights[0]),
                            line: 0
                        };
                    }

                    helpers$1.rtl.overrideTextDirection(me.ctx, opts.textDirection);

                    var itemHeight = fontSize + labelOpts.padding;
                    helpers$1.each(me.legendItems, function(legendItem, i) {
                        var textWidth = ctx.measureText(legendItem.text).width;
                        var width = boxWidth + (fontSize / 2) + textWidth;
                        var x = cursor.x;
                        var y = cursor.y;

                        rtlHelper.setWidth(me.minSize.width);

                        // Use (me.left + me.minSize.width) and (me.top + me.minSize.height)
                        // instead of me.right and me.bottom because me.width and me.height
                        // may have been changed since me.minSize was calculated
                        if (isHorizontal) {
                            if (i > 0 && x + width + labelOpts.padding > me.left + me.minSize.width) {
                                y = cursor.y += itemHeight;
                                cursor.line++;
                                x = cursor.x = me.left + alignmentOffset(legendWidth, lineWidths[cursor.line]);
                            }
                        } else if (i > 0 && y + itemHeight > me.top + me.minSize.height) {
                            x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;
                            cursor.line++;
                            y = cursor.y = me.top + alignmentOffset(legendHeight, columnHeights[cursor.line]);
                        }

                        var realX = rtlHelper.x(x);

                        drawLegendBox(realX, y, legendItem);

                        hitboxes[i].left = rtlHelper.leftForLtr(realX, hitboxes[i].width);
                        hitboxes[i].top = y;

                        // Fill the actual label
                        fillText(realX, y, legendItem, textWidth);

                        if (isHorizontal) {
                            cursor.x += width + labelOpts.padding;
                        } else {
                            cursor.y += itemHeight;
                        }
                    });

                    helpers$1.rtl.restoreTextDirection(me.ctx, opts.textDirection);
                },

                /**
                 * @private
                 */
                _getLegendItemAt: function(x, y) {
                    var me = this;
                    var i, hitBox, lh;

                    if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {
                        // See if we are touching one of the dataset boxes
                        lh = me.legendHitBoxes;
                        for (i = 0; i < lh.length; ++i) {
                            hitBox = lh[i];

                            if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {
                                // Touching an element
                                return me.legendItems[i];
                            }
                        }
                    }

                    return null;
                },

                /**
                 * Handle an event
                 * @private
                 * @param {IEvent} event - The event to handle
                 */
                handleEvent: function(e) {
                    var me = this;
                    var opts = me.options;
                    var type = e.type === 'mouseup' ? 'click' : e.type;
                    var hoveredItem;

                    if (type === 'mousemove') {
                        if (!opts.onHover && !opts.onLeave) {
                            return;
                        }
                    } else if (type === 'click') {
                        if (!opts.onClick) {
                            return;
                        }
                    } else {
                        return;
                    }

                    // Chart event already has relative position in it
                    hoveredItem = me._getLegendItemAt(e.x, e.y);

                    if (type === 'click') {
                        if (hoveredItem && opts.onClick) {
                            // use e.native for backwards compatibility
                            opts.onClick.call(me, e.native, hoveredItem);
                        }
                    } else {
                        if (opts.onLeave && hoveredItem !== me._hoveredItem) {
                            if (me._hoveredItem) {
                                opts.onLeave.call(me, e.native, me._hoveredItem);
                            }
                            me._hoveredItem = hoveredItem;
                        }

                        if (opts.onHover && hoveredItem) {
                            // use e.native for backwards compatibility
                            opts.onHover.call(me, e.native, hoveredItem);
                        }
                    }
                }
            });

            function createNewLegendAndAttach(chart, legendOpts) {
                var legend = new Legend({
                    ctx: chart.ctx,
                    options: legendOpts,
                    chart: chart
                });

                core_layouts.configure(chart, legend, legendOpts);
                core_layouts.addBox(chart, legend);
                chart.legend = legend;
            }

            var plugin_legend = {
                id: 'legend',

                /**
                 * Backward compatibility: since 2.1.5, the legend is registered as a plugin, making
                 * Chart.Legend obsolete. To avoid a breaking change, we export the Legend as part of
                 * the plugin, which one will be re-exposed in the chart.js file.
                 * https://github.com/chartjs/Chart.js/pull/2640
                 * @private
                 */
                _element: Legend,

                beforeInit: function(chart) {
                    var legendOpts = chart.options.legend;

                    if (legendOpts) {
                        createNewLegendAndAttach(chart, legendOpts);
                    }
                },

                beforeUpdate: function(chart) {
                    var legendOpts = chart.options.legend;
                    var legend = chart.legend;

                    if (legendOpts) {
                        helpers$1.mergeIf(legendOpts, core_defaults.global.legend);

                        if (legend) {
                            core_layouts.configure(chart, legend, legendOpts);
                            legend.options = legendOpts;
                        } else {
                            createNewLegendAndAttach(chart, legendOpts);
                        }
                    } else if (legend) {
                        core_layouts.removeBox(chart, legend);
                        delete chart.legend;
                    }
                },

                afterEvent: function(chart, e) {
                    var legend = chart.legend;
                    if (legend) {
                        legend.handleEvent(e);
                    }
                }
            };

            var noop$2 = helpers$1.noop;

            core_defaults._set('global', {
                title: {
                    display: false,
                    fontStyle: 'bold',
                    fullWidth: true,
                    padding: 10,
                    position: 'top',
                    text: '',
                    weight: 2000         // by default greater than legend (1000) to be above
                }
            });

            /**
             * IMPORTANT: this class is exposed publicly as Chart.Legend, backward compatibility required!
             */
            var Title = core_element.extend({
                initialize: function(config) {
                    var me = this;
                    helpers$1.extend(me, config);

                    // Contains hit boxes for each dataset (in dataset order)
                    me.legendHitBoxes = [];
                },

                // These methods are ordered by lifecycle. Utilities then follow.

                beforeUpdate: noop$2,
                update: function(maxWidth, maxHeight, margins) {
                    var me = this;

                    // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)
                    me.beforeUpdate();

                    // Absorb the master measurements
                    me.maxWidth = maxWidth;
                    me.maxHeight = maxHeight;
                    me.margins = margins;

                    // Dimensions
                    me.beforeSetDimensions();
                    me.setDimensions();
                    me.afterSetDimensions();
                    // Labels
                    me.beforeBuildLabels();
                    me.buildLabels();
                    me.afterBuildLabels();

                    // Fit
                    me.beforeFit();
                    me.fit();
                    me.afterFit();
                    //
                    me.afterUpdate();

                    return me.minSize;

                },
                afterUpdate: noop$2,

                //

                beforeSetDimensions: noop$2,
                setDimensions: function() {
                    var me = this;
                    // Set the unconstrained dimension before label rotation
                    if (me.isHorizontal()) {
                        // Reset position before calculating rotation
                        me.width = me.maxWidth;
                        me.left = 0;
                        me.right = me.width;
                    } else {
                        me.height = me.maxHeight;

                        // Reset position before calculating rotation
                        me.top = 0;
                        me.bottom = me.height;
                    }

                    // Reset padding
                    me.paddingLeft = 0;
                    me.paddingTop = 0;
                    me.paddingRight = 0;
                    me.paddingBottom = 0;

                    // Reset minSize
                    me.minSize = {
                        width: 0,
                        height: 0
                    };
                },
                afterSetDimensions: noop$2,

                //

                beforeBuildLabels: noop$2,
                buildLabels: noop$2,
                afterBuildLabels: noop$2,

                //

                beforeFit: noop$2,
                fit: function() {
                    var me = this;
                    var opts = me.options;
                    var minSize = me.minSize = {};
                    var isHorizontal = me.isHorizontal();
                    var lineCount, textSize;

                    if (!opts.display) {
                        me.width = minSize.width = me.height = minSize.height = 0;
                        return;
                    }

                    lineCount = helpers$1.isArray(opts.text) ? opts.text.length : 1;
                    textSize = lineCount * helpers$1.options._parseFont(opts).lineHeight + opts.padding * 2;

                    me.width = minSize.width = isHorizontal ? me.maxWidth : textSize;
                    me.height = minSize.height = isHorizontal ? textSize : me.maxHeight;
                },
                afterFit: noop$2,

                // Shared Methods
                isHorizontal: function() {
                    var pos = this.options.position;
                    return pos === 'top' || pos === 'bottom';
                },

                // Actually draw the title block on the canvas
                draw: function() {
                    var me = this;
                    var ctx = me.ctx;
                    var opts = me.options;

                    if (!opts.display) {
                        return;
                    }

                    var fontOpts = helpers$1.options._parseFont(opts);
                    var lineHeight = fontOpts.lineHeight;
                    var offset = lineHeight / 2 + opts.padding;
                    var rotation = 0;
                    var top = me.top;
                    var left = me.left;
                    var bottom = me.bottom;
                    var right = me.right;
                    var maxWidth, titleX, titleY;

                    ctx.fillStyle = helpers$1.valueOrDefault(opts.fontColor, core_defaults.global.defaultFontColor); // render in correct colour
                    ctx.font = fontOpts.string;

                    // Horizontal
                    if (me.isHorizontal()) {
                        titleX = left + ((right - left) / 2); // midpoint of the width
                        titleY = top + offset;
                        maxWidth = right - left;
                    } else {
                        titleX = opts.position === 'left' ? left + offset : right - offset;
                        titleY = top + ((bottom - top) / 2);
                        maxWidth = bottom - top;
                        rotation = Math.PI * (opts.position === 'left' ? -0.5 : 0.5);
                    }

                    ctx.save();
                    ctx.translate(titleX, titleY);
                    ctx.rotate(rotation);
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    var text = opts.text;
                    if (helpers$1.isArray(text)) {
                        var y = 0;
                        for (var i = 0; i < text.length; ++i) {
                            ctx.fillText(text[i], 0, y, maxWidth);
                            y += lineHeight;
                        }
                    } else {
                        ctx.fillText(text, 0, 0, maxWidth);
                    }

                    ctx.restore();
                }
            });

            function createNewTitleBlockAndAttach(chart, titleOpts) {
                var title = new Title({
                    ctx: chart.ctx,
                    options: titleOpts,
                    chart: chart
                });

                core_layouts.configure(chart, title, titleOpts);
                core_layouts.addBox(chart, title);
                chart.titleBlock = title;
            }

            var plugin_title = {
                id: 'title',

                /**
                 * Backward compatibility: since 2.1.5, the title is registered as a plugin, making
                 * Chart.Title obsolete. To avoid a breaking change, we export the Title as part of
                 * the plugin, which one will be re-exposed in the chart.js file.
                 * https://github.com/chartjs/Chart.js/pull/2640
                 * @private
                 */
                _element: Title,

                beforeInit: function(chart) {
                    var titleOpts = chart.options.title;

                    if (titleOpts) {
                        createNewTitleBlockAndAttach(chart, titleOpts);
                    }
                },

                beforeUpdate: function(chart) {
                    var titleOpts = chart.options.title;
                    var titleBlock = chart.titleBlock;

                    if (titleOpts) {
                        helpers$1.mergeIf(titleOpts, core_defaults.global.title);

                        if (titleBlock) {
                            core_layouts.configure(chart, titleBlock, titleOpts);
                            titleBlock.options = titleOpts;
                        } else {
                            createNewTitleBlockAndAttach(chart, titleOpts);
                        }
                    } else if (titleBlock) {
                        core_layouts.removeBox(chart, titleBlock);
                        delete chart.titleBlock;
                    }
                }
            };

            var plugins = {};
            var filler = plugin_filler;
            var legend = plugin_legend;
            var title = plugin_title;
            plugins.filler = filler;
            plugins.legend = legend;
            plugins.title = title;

            /**
             * @namespace Chart
             */


            core_controller.helpers = helpers$1;

            // @todo dispatch these helpers into appropriated helpers/helpers.* file and write unit tests!
            core_helpers();

            core_controller._adapters = core_adapters;
            core_controller.Animation = core_animation;
            core_controller.animationService = core_animations;
            core_controller.controllers = controllers;
            core_controller.DatasetController = core_datasetController;
            core_controller.defaults = core_defaults;
            core_controller.Element = core_element;
            core_controller.elements = elements;
            core_controller.Interaction = core_interaction;
            core_controller.layouts = core_layouts;
            core_controller.platform = platform;
            core_controller.plugins = core_plugins;
            core_controller.Scale = core_scale;
            core_controller.scaleService = core_scaleService;
            core_controller.Ticks = core_ticks;
            core_controller.Tooltip = core_tooltip;

            // Register built-in scales

            core_controller.helpers.each(scales, function(scale, type) {
                core_controller.scaleService.registerScaleType(type, scale, scale._defaults);
            });

            // Load to register built-in adapters (as side effects)


            // Loading built-in plugins

            for (var k in plugins) {
                if (plugins.hasOwnProperty(k)) {
                    core_controller.plugins.register(plugins[k]);
                }
            }

            core_controller.platform.initialize();

            var src = core_controller;
            if (typeof window !== 'undefined') {
                window.Chart = core_controller;
            }

            // DEPRECATIONS

            /**
             * Provided for backward compatibility, not available anymore
             * @namespace Chart.Chart
             * @deprecated since version 2.8.0
             * @todo remove at version 3
             * @private
             */
            core_controller.Chart = core_controller;

            /**
             * Provided for backward compatibility, not available anymore
             * @namespace Chart.Legend
             * @deprecated since version 2.1.5
             * @todo remove at version 3
             * @private
             */
            core_controller.Legend = plugins.legend._element;

            /**
             * Provided for backward compatibility, not available anymore
             * @namespace Chart.Title
             * @deprecated since version 2.1.5
             * @todo remove at version 3
             * @private
             */
            core_controller.Title = plugins.title._element;

            /**
             * Provided for backward compatibility, use Chart.plugins instead
             * @namespace Chart.pluginService
             * @deprecated since version 2.1.5
             * @todo remove at version 3
             * @private
             */
            core_controller.pluginService = core_controller.plugins;

            /**
             * Provided for backward compatibility, inheriting from Chart.PlugingBase has no
             * effect, instead simply create/register plugins via plain JavaScript objects.
             * @interface Chart.PluginBase
             * @deprecated since version 2.5.0
             * @todo remove at version 3
             * @private
             */
            core_controller.PluginBase = core_controller.Element.extend({});

            /**
             * Provided for backward compatibility, use Chart.helpers.canvas instead.
             * @namespace Chart.canvasHelpers
             * @deprecated since version 2.6.0
             * @todo remove at version 3
             * @private
             */
            core_controller.canvasHelpers = core_controller.helpers.canvas;

            /**
             * Provided for backward compatibility, use Chart.layouts instead.
             * @namespace Chart.layoutService
             * @deprecated since version 2.7.3
             * @todo remove at version 3
             * @private
             */
            core_controller.layoutService = core_controller.layouts;

            /**
             * Provided for backward compatibility, not available anymore.
             * @namespace Chart.LinearScaleBase
             * @deprecated since version 2.8
             * @todo remove at version 3
             * @private
             */
            core_controller.LinearScaleBase = scale_linearbase;

            /**
             * Provided for backward compatibility, instead we should create a new Chart
             * by setting the type in the config (`new Chart(id, {type: '{chart-type}'}`).
             * @deprecated since version 2.8.0
             * @todo remove at version 3
             */
            core_controller.helpers.each(
                [
                    'Bar',
                    'Bubble',
                    'Doughnut',
                    'Line',
                    'PolarArea',
                    'Radar',
                    'Scatter'
                ],
                function(klass) {
                    core_controller[klass] = function(ctx, cfg) {
                        return new core_controller(ctx, core_controller.helpers.merge(cfg || {}, {
                            type: klass.charAt(0).toLowerCase() + klass.slice(1)
                        }));
                    };
                }
            );

            return src;

        })));

        /**
         * --------------------------------------------------------------------------
         * Custom Tooltips for Chart.js (vv2.0.0-beta.0): custom-tooltips.js
         * Licensed under MIT (https://coreui.io/plugins/chart.js)
         * --------------------------------------------------------------------------
         */
        function customTooltips(tooltipModel) {
            var _this = this;

            // Add unique id if not exist
            var _setCanvasId = function _setCanvasId() {
                var _idMaker = function _idMaker() {
                    var _hex = 16;
                    var _multiplier = 0x10000;
                    return ((1 + Math.random()) * _multiplier | 0).toString(_hex);
                };

                var _canvasId = "_canvas-" + (_idMaker() + _idMaker());

                _this._chart.canvas.id = _canvasId;
                return _canvasId;
            };

            var ClassName = {
                ABOVE: 'c-above',
                BELOW: 'c-below',
                CHARTJS_TOOLTIP: 'c-chartjs-tooltip',
                NO_TRANSFORM: 'c-no-transform',
                TOOLTIP_BODY: 'c-tooltip-body',
                TOOLTIP_BODY_ITEM: 'c-tooltip-body-item',
                TOOLTIP_BODY_ITEM_COLOR: 'c-tooltip-body-item-color',
                TOOLTIP_BODY_ITEM_LABEL: 'c-tooltip-body-item-label',
                TOOLTIP_BODY_ITEM_VALUE: 'c-tooltip-body-item-value',
                TOOLTIP_HEADER: 'c-tooltip-header',
                TOOLTIP_HEADER_ITEM: 'c-tooltip-header-item'
            };
            var Selector = {
                DIV: 'div',
                SPAN: 'span',
                TOOLTIP: (this._chart.canvas.id || _setCanvasId()) + "-tooltip"
            };
            var tooltip = document.getElementById(Selector.TOOLTIP);

            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = Selector.TOOLTIP;
                tooltip.className = ClassName.CHARTJS_TOOLTIP;

                this._chart.canvas.parentNode.appendChild(tooltip);
            } // Hide if no tooltip


            if (tooltipModel.opacity === 0) {
                tooltip.style.opacity = 0;
                return;
            } // Set caret Position


            tooltip.classList.remove(ClassName.ABOVE, ClassName.BELOW, ClassName.NO_TRANSFORM);

            if (tooltipModel.yAlign) {
                tooltip.classList.add(tooltipModel.yAlign);
            } else {
                tooltip.classList.add(ClassName.NO_TRANSFORM);
            } // Set Text


            if (tooltipModel.body) {
                var titleLines = tooltipModel.title || [];
                var tooltipHeader = document.createElement(Selector.DIV);
                tooltipHeader.className = ClassName.TOOLTIP_HEADER;
                titleLines.forEach(function (title) {
                    var tooltipHeaderTitle = document.createElement(Selector.DIV);
                    tooltipHeaderTitle.className = ClassName.TOOLTIP_HEADER_ITEM;
                    tooltipHeaderTitle.innerHTML = title;
                    tooltipHeader.appendChild(tooltipHeaderTitle);
                });
                var tooltipBody = document.createElement(Selector.DIV);
                tooltipBody.className = ClassName.TOOLTIP_BODY;
                var tooltipBodyItems = tooltipModel.body.map(function (item) {
                    return item.lines;
                });
                tooltipBodyItems.forEach(function (item, i) {
                    var tooltipBodyItem = document.createElement(Selector.DIV);
                    tooltipBodyItem.className = ClassName.TOOLTIP_BODY_ITEM;
                    var colors = tooltipModel.labelColors[i];
                    var tooltipBodyItemColor = document.createElement(Selector.SPAN);
                    tooltipBodyItemColor.className = ClassName.TOOLTIP_BODY_ITEM_COLOR;
                    tooltipBodyItemColor.style.backgroundColor = colors.backgroundColor;
                    tooltipBodyItem.appendChild(tooltipBodyItemColor);

                    if (item[0].split(':').length > 1) {
                        var tooltipBodyItemLabel = document.createElement(Selector.SPAN);
                        tooltipBodyItemLabel.className = ClassName.TOOLTIP_BODY_ITEM_LABEL;
                        tooltipBodyItemLabel.innerHTML = item[0].split(': ')[0];
                        tooltipBodyItem.appendChild(tooltipBodyItemLabel);
                        var tooltipBodyItemValue = document.createElement(Selector.SPAN);
                        tooltipBodyItemValue.className = ClassName.TOOLTIP_BODY_ITEM_VALUE;
                        tooltipBodyItemValue.innerHTML = item[0].split(': ').pop();
                        tooltipBodyItem.appendChild(tooltipBodyItemValue);
                    } else {
                        var _tooltipBodyItemValue = document.createElement(Selector.SPAN);

                        _tooltipBodyItemValue.className = ClassName.TOOLTIP_BODY_ITEM_VALUE;
                        _tooltipBodyItemValue.innerHTML = item[0];
                        tooltipBodyItem.appendChild(_tooltipBodyItemValue);
                    }

                    tooltipBody.appendChild(tooltipBodyItem);
                });
                tooltip.innerHTML = '';
                tooltip.appendChild(tooltipHeader);
                tooltip.appendChild(tooltipBody);
            }

            var position = this._chart.canvas.getBoundingClientRect();

            var positionY = this._chart.canvas.offsetTop;
            var positionX = this._chart.canvas.offsetLeft;
            var positionLeft = positionX + tooltipModel.caretX;
            var positionTop = positionY + tooltipModel.caretY; // eslint-disable-next-line

            var halfWidth = tooltipModel.width / 2;

            if (positionLeft + halfWidth > position.width) {
                positionLeft -= halfWidth;
            } else if (positionLeft < halfWidth) {
                positionLeft += halfWidth;
            } // Display, position, and set styles for font


            tooltip.style.opacity = 1;
            tooltip.style.left = positionLeft + "px";
            tooltip.style.top = positionTop + "px";
        }

        /**
         * --------------------------------------------------------------------------
         * Custom Tooltips for Chart.js (vv2.0.0-beta.0): index.umd.js
         * Licensed under MIT (https://github.com/@coreui/coreui-chartjs/LICENSE)
         * --------------------------------------------------------------------------
         */
        var index_umd = {
            customTooltips: customTooltips
        };

        return index_umd;

    })));
    //# sourceMappingURL=coreui-chartjs.bundle.js.map

    !function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Utils=t():(e.coreui=e.coreui||{},e.coreui.Utils=t())}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,r),o.l=!0,o.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)r.d(n,o,function(t){return e[t]}.bind(null,o));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=0)}([function(e,t,r){"use strict";r.r(t);var n=function e(t,r){for(var n=0,o=Object.keys(r);n<o.length;n++){var c=o[n];r[c]instanceof Object&&Object.assign(r[c],e(t[c],r[c]))}return Object.assign(t||{},r),t},o=function(){for(var e={},t=document.styleSheets,r="",n=t.length-1;n>-1;n--){for(var o=t[n].cssRules,c=o.length-1;c>-1;c--)if(".ie-custom-properties"===o[c].selectorText){r=o[c].cssText;break}if(r)break}return(r=r.substring(r.lastIndexOf("{")+1,r.lastIndexOf("}"))).split(";").forEach((function(t){if(t){var r=t.split(": ")[0],n=t.split(": ")[1];r&&n&&(e["--".concat(r.trim())]=n.trim())}})),e},c=function(){return Boolean(document.documentMode)&&document.documentMode>=10},i=function(e){return e.match(/^--.*/i)},a=function(e){var t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document.body;if(i(e)&&c()){var n=o();t=n[e]}else t=window.getComputedStyle(r,null).getPropertyValue(e).replace(/^\s/,"");return t},s=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:document.body,r="--".concat(e),n=a(r,t);return n||e},u=function(e){if(void 0===e)throw new TypeError("Hex color is not defined");var t,r,n;if(!e.match(/^#(?:[0-9a-f]{3}){1,2}$/i))throw new Error("".concat(e," is not a valid hex color"));return 7===e.length?(t=parseInt(e.slice(1,3),16),r=parseInt(e.slice(3,5),16),n=parseInt(e.slice(5,7),16)):(t=parseInt(e.slice(1,2),16),r=parseInt(e.slice(2,3),16),n=parseInt(e.slice(3,5),16)),"rgba(".concat(t,", ").concat(r,", ").concat(n,")")},l=function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:100;if(void 0===e)throw new TypeError("Hex color is not defined");var r,n,o,c=e.match(/^#(?:[0-9a-f]{3}){1,2}$/i);if(!c)throw new Error("".concat(e," is not a valid hex color"));return 7===e.length?(r=parseInt(e.slice(1,3),16),n=parseInt(e.slice(3,5),16),o=parseInt(e.slice(5,7),16)):(r=parseInt(e.slice(1,2),16),n=parseInt(e.slice(2,3),16),o=parseInt(e.slice(3,5),16)),"rgba(".concat(r,", ").concat(n,", ").concat(o,", ").concat(t/100,")")},f=function(){return"uid-"+Math.random().toString(36).substr(2)},d=function(e,t){for(var r={},n=0;n<t.length;n++)r[t[n]]=e[t[n]];return r},p=function(e){if(void 0===e)throw new TypeError("Hex color is not defined");if("transparent"===e)return"#00000000";var t=e.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);if(!t)throw new Error("".concat(e," is not a valid rgb color"));var r="0".concat(parseInt(t[1],10).toString(16)),n="0".concat(parseInt(t[2],10).toString(16)),o="0".concat(parseInt(t[3],10).toString(16));return"#".concat(r.slice(-2)).concat(n.slice(-2)).concat(o.slice(-2))};t.default={deepObjectsMerge:n,getColor:s,getStyle:a,hexToRgb:u,hexToRgba:l,makeUid:f,pickByKeys:d,rgbToHex:p}}]).default}));

    /* eslint-disable object-shorthand */
    /* global Chart, coreui, coreui.Utils.getStyle, coreui.Utils.hexToRgba */

    /**
     * --------------------------------------------------------------------------
     * CoreUI Boostrap Admin Template (v3.2.0): main.js
     * Licensed under MIT (https://coreui.io/license)
     * --------------------------------------------------------------------------
     */

    /* eslint-disable no-magic-numbers */
    // Disable the on-canvas tooltip
    Chart.defaults.global.pointHitDetectionRadius = 1
    Chart.defaults.global.tooltips.enabled = false
    Chart.defaults.global.tooltips.mode = 'index'
    Chart.defaults.global.tooltips.position = 'nearest'
    Chart.defaults.global.tooltips.custom = coreui.ChartJS.customTooltips
    Chart.defaults.global.defaultFontColor = '#646470'
    Chart.defaults.global.responsiveAnimationDuration = 1

    document.body.addEventListener('classtoggle', event => {
        if (event.detail.className === 'c-dark-theme') {
            if (document.body.classList.contains('c-dark-theme')) {
                cardChart1.data.datasets[0].pointBackgroundColor = coreui.Utils.getStyle('--primary-dark-theme')
                cardChart2.data.datasets[0].pointBackgroundColor = coreui.Utils.getStyle('--info-dark-theme')
                Chart.defaults.global.defaultFontColor = '#fff'
            } else {
                cardChart1.data.datasets[0].pointBackgroundColor = coreui.Utils.getStyle('--primary')
                cardChart2.data.datasets[0].pointBackgroundColor = coreui.Utils.getStyle('--info')
                Chart.defaults.global.defaultFontColor = '#646470'
            }

            cardChart1.update()
            cardChart2.update()
            mainChart.update()
        }
    })

    // eslint-disable-next-line no-unused-vars
    const cardChart1 = new Chart(document.getElementById('card-chart1'), {
        type: 'line',
        data: {
            labels: ['January', 'February', 'March', 'April', 'May', 'June', 'July'],
            datasets: [
                {
                    label: 'Month',
                    backgroundColor: 'transparent',
                    borderColor: 'rgba(255,255,255,.55)',
                    pointBackgroundColor: coreui.Utils.getStyle('--primary'),
                    data: [190, 195, 201, 199, 194, 197, 200]
                }
            ]
        },
        options: {
            maintainAspectRatio: false,
            legend: {
                display: false
            },
            scales: {
                xAxes: [{
                    gridLines: {
                        color: 'transparent',
                        zeroLineColor: 'transparent'
                    },
                    ticks: {
                        fontSize: 2,
                        fontColor: 'transparent'
                    }
                }],
                yAxes: [{
                    display: false,
                    ticks: {
                        display: false,
                        min: 185,
                        max: 210
                    }
                }]
            },
            elements: {
                line: {
                    borderWidth: 1
                },
                point: {
                    radius: 4,
                    hitRadius: 10,
                    hoverRadius: 4
                }
            }
        }
    })


    // eslint-disable-next-line no-unused-vars
    const cardChart3 = new Chart(document.getElementById('card-chart3'), {
        type: 'bar',
        data: {
            labels: ['18-28', '29-38', '39-48', '49+'],
            datasets: [
                {
                    label: 'Age Range',
                    backgroundColor: 'rgba(255,255,255,.2)',
                    borderColor: 'rgba(255,255,255,.55)',
                    data: [94, 62, 35, 9]
                }
            ]
        },
        options: {
            maintainAspectRatio: false,
            legend: {
                display: false
            },
            scales: {
                xAxes: [{
                    display: false
                }],
                yAxes: [{
                    display: false
                }]
            }
        }
    })

    // eslint-disable-next-line no-unused-vars
    const cardChart4 = new Chart(document.getElementById('card-chart4'), {
        type: 'bar',
        data: {
            labels: ['Marketing', 'Finances', 'Development', 'Client Support', 'Sales', 'Someteam'],
            datasets: [
                {
                    label: 'Team',
                    backgroundColor: 'rgba(255,255,255,.2)',
                    borderColor: 'rgba(255,255,255,.55)',
                    data: [21, 14, 20, 18.5, 22, 0],
                    barPercentage: 0.6
                }
            ]
        },
        options: {
            maintainAspectRatio: false,
            legend: {
                display: false
            },
            scales: {
                xAxes: [{
                    display: false
                }],
                yAxes: [{
                    display: false
                }]
            }
        }
    })

    // eslint-disable-next-line no-unused-vars
    const mainChart = new Chart(document.getElementById('main-chart'), {
        type: 'line',
        data: {
            labels: ['M', 'T', 'W', 'T', 'F', 'S', 'S', 'M', 'T', 'W', 'T', 'F', 'S', 'S', 'M', 'T', 'W', 'T', 'F', 'S', 'S', 'M', 'T', 'W', 'T', 'F', 'S', 'S'],
            datasets: [
                {
                    label: 'Marketing',
                    backgroundColor: coreui.Utils.hexToRgba(coreui.Utils.getStyle('--info'), 10),
                    borderColor: coreui.Utils.getStyle('--info'),
                    pointHoverBackgroundColor: '#fff',
                    borderWidth: 2,
                    data: [165, 180, 70, 69, 77, 57, 125, 165, 172, 91, 173, 138, 155, 89, 50, 161, 65, 163, 160, 103, 114, 185, 125, 196, 183, 64, 137, 95, 112, 175]
                },
                {
                    label: 'Finances',
                    backgroundColor: 'transparent',
                    borderColor: coreui.Utils.getStyle('--success'),
                    pointHoverBackgroundColor: '#fff',
                    borderWidth: 2,
                    data: [92, 97, 80, 100, 86, 97, 83, 98, 87, 98, 93, 83, 87, 98, 96, 84, 91, 97, 88, 86, 94, 86, 95, 91, 98, 91, 92, 80, 83, 82]
                },
                {
                    label: 'Development',
                    backgroundColor: 'transparent',
                    borderColor: coreui.Utils.getStyle('--danger'),
                    pointHoverBackgroundColor: '#fff',
                    borderWidth: 2,
                    data: [96, 54, 50, 22, 22, 4, 6, 43, 28, 74, 82, 63, 91, 72, 29, 28, 82, 35, 68, 33, 64, 42, 19, 95, 33, 59, 29, 23, 34, 67]
                },
                {
                    label: 'Client support',
                    backgroundColor: 'transparent',
                    borderColor: coreui.Utils.getStyle('--warning'),
                    pointHoverBackgroundColor: '#fff',
                    borderWidth: 2,
                    data: [61, 64, 60, 63, 12, 31, 35, 55, 43, 7, 41, 13, 21, 61, 38, 26, 43, 8, 61, 39, 20, 50, 50, 97, 50, 62, 20, 46, 7, 37]
                },
                {
                    label: 'Sales',
                    backgroundColor: 'transparent',
                    borderColor: coreui.Utils.getStyle('--dark'),
                    pointHoverBackgroundColor: '#fff',
                    borderWidth: 2,
                    data: [24, 27, 7, 72, 24, 98, 25, 28, 26, 45, 35, 59, 34, 4, 100, 74, 73, 36, 13, 37, 98, 70, 76, 21, 62, 69, 38, 7, 88, 55]
                }
            ]
        },
        options: {
            maintainAspectRatio: false,
            legend: {
                display: false
            },
            scales: {
                xAxes: [{
                    gridLines: {
                        drawOnChartArea: false
                    }
                }],
                yAxes: [{
                    ticks: {
                        beginAtZero: true,
                        maxTicksLimit: 5,
                        stepSize: Math.ceil(250 / 5),
                        max: 250
                    }
                }]
            },
            elements: {
                point: {
                    radius: 0,
                    hitRadius: 10,
                    hoverRadius: 4,
                    hoverBorderWidth: 3
                }
            }
        }
    })


    const random = () => Math.round(Math.random() * 100)

    const genderRatio = new Chart(document.getElementById('canvas-2'), {
        type: 'pie',
        data: {
            labels: ['Female', 'Male'],
            datasets: [{
                data: [76,124],
                backgroundColor: ['#FF6384', '#36A2EB'],
                hoverBackgroundColor: ['#FF6384', '#36A2EB']
            }]
        },
        options: {
            responsive: true
        }
    })

    const vacationStats = new Chart(document.getElementById('canvas-3'), {
        type: 'doughnut',
        data: {
            labels: ['Working', 'Home Office', 'Sick Leave', 'Vacation'],
            datasets: [{
                data: [120, 36, 18, 6],
                backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#646470'],
                hoverBackgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#646470']
            }]
        },
        options: {
            responsive: true
        }
    })

    const employeesOnTheBreak = new Chart(document.getElementById('canvas-6'), {
        type: 'pie',
        data: {
            labels: ['On the break','Working'],
            datasets: [{
                data: [35, 121],
                backgroundColor: ['#FF6384', '#36A2EB'],
                hoverBackgroundColor: ['#FF6384', '#36A2EB']
            }]
        },
        options: {
            responsive: true
        }
    })

    const employmentStatus = new Chart(document.getElementById('canvas-7'), {
        type: 'pie',
        data: {
            labels: ['Full time', 'Part time'],
            datasets: [{
                data: [120,80],
                backgroundColor: ['#FF6384', '#36A2EB'],
                hoverBackgroundColor: ['#FF6384', '#36A2EB']
            }]
        },
        options: {
            responsive: true
        }
    })

    const employmentGrowth = new Chart(document.getElementById('canvas-8'), {
        type: 'doughnut',
        data: {
            labels: ['< 1 year', '1 to 3 years', '3 to 5 years', '> 5 years'],
            datasets: [{
                data: [46, 68, 54, 32],
                backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#646470'],
                hoverBackgroundColor: ['#FF6384', '#36A2EB', '#FFCE56', '#646470']
            }]
        },
        options: {
            responsive: true
        }
    })

    // eslint-disable-next-line no-unused-vars
    const barChart = new Chart(document.getElementById('canvas-12'), {
        type: 'bar',
        data: {
            labels : ['January', 'February', 'March', 'April', 'May', 'June', 'July'],
            datasets : [
                {
                    backgroundColor : 'rgba(220, 220, 220, 0.5)',
                    borderColor : 'rgba(220, 220, 220, 0.8)',
                    highlightFill: 'rgba(220, 220, 220, 0.75)',
                    highlightStroke: 'rgba(220, 220, 220, 1)',
                    data : [random(), random(), random(), random(), random(), random(), random()]
                },
                {
                    backgroundColor : 'rgba(151, 187, 205, 0.5)',
                    borderColor : 'rgba(151, 187, 205, 0.8)',
                    highlightFill : 'rgba(151, 187, 205, 0.75)',
                    highlightStroke : 'rgba(151, 187, 205, 1)',
                    data : [random(), random(), random(), random(), random(), random(), random()]
                }
            ]
        },
        options: {
            responsive: true
        }
    })

    // eslint-disable-next-line no-unused-vars
    const doughnutChart = new Chart(document.getElementById('canvas-13'), {
        type: 'doughnut',
        data: {
            labels: ['Red', 'Green', 'Yellow'],
            datasets: [{
                data: [300, 50, 100],
                backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56'],
                hoverBackgroundColor: ['#FF6384', '#36A2EB', '#FFCE56']
            }]
        },
        options: {
            responsive: true
        }
    })

    // eslint-disable-next-line no-unused-vars
    const pieChart = new Chart(document.getElementById('canvas-235'), {
        type: 'pie',
        data: {
            labels: ['Red', 'Green', 'Yellow'],
            datasets: [{
                data: [300, 50, 100],
                backgroundColor: ['#FF6384', '#36A2EB', '#FFCE56'],
                hoverBackgroundColor: ['#FF6384', '#36A2EB', '#FFCE56']
            }]
        },
        options: {
            responsive: true
        }
    })

</script>
</html>
